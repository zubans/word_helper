"use strict";
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertProject = void 0;
const adm_zip_1 = __importDefault(require("adm-zip"));
const fs_1 = __importDefault(require("fs"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const util_1 = __importDefault(require("util"));
const child_process_1 = require("child_process");
const office_addin_manifest_converter_1 = require("office-addin-manifest-converter");
const office_addin_usage_data_1 = require("office-addin-usage-data");
/* global console process */
const execAsync = util_1.default.promisify(child_process_1.exec);
const skipBackup = ["node_modules"];
function convertProject(manifestPath = "./manifest.xml", backupPath = "./backup.zip", projectDir = "", devPreview = false) {
    return __awaiter(this, void 0, void 0, function* () {
        if (manifestPath.endsWith(".json")) {
            throw new office_addin_usage_data_1.ExpectedError(`The convert command only works on xml manifest based projects`);
        }
        if (!fs_1.default.existsSync(manifestPath)) {
            throw new office_addin_usage_data_1.ExpectedError(`The manifest file '${manifestPath}' does not exist`);
        }
        const outputPath = path_1.default.dirname(manifestPath);
        const currentDir = process.cwd();
        yield backupProject(backupPath);
        try {
            // assume project dir is the same as manifest dir if not specified
            projectDir = projectDir === "" ? outputPath : projectDir;
            process.chdir(projectDir);
            if (!devPreview) {
                yield (0, office_addin_manifest_converter_1.convert)(manifestPath, outputPath, false /* imageDownload */);
            }
            else {
                // override the schema used in the json manifest to use the devPreview schema
                yield (0, office_addin_manifest_converter_1.convert)(manifestPath, outputPath, false /* imageDownload */, "https://developer.microsoft.com/json-schemas/teams/vDevPreview/MicrosoftTeams.schema.json", "devPreview");
            }
            yield updatePackages();
            yield updateManifestXmlReferences();
            fs_1.default.unlinkSync(manifestPath);
        }
        catch (err) {
            console.log(`Error in conversion. Restoring project initial state.`);
            yield restoreBackup(backupPath);
            throw err;
        }
        finally {
            process.chdir(currentDir);
        }
    });
}
exports.convertProject = convertProject;
function backupProject(backupPath) {
    return __awaiter(this, void 0, void 0, function* () {
        const zip = new adm_zip_1.default();
        const outputPath = path_1.default.resolve(backupPath);
        const rootDir = path_1.default.resolve();
        const files = fs_1.default.readdirSync(rootDir);
        files.forEach((entry) => {
            const fullPath = path_1.default.resolve(entry);
            const entryStats = fs_1.default.lstatSync(fullPath);
            if (skipBackup.includes(entry)) {
                // Don't add it to the backup
            }
            else if (entryStats.isDirectory()) {
                zip.addLocalFolder(entry, entry);
            }
            else {
                zip.addLocalFile(entry);
            }
        });
        fs_extra_1.default.ensureDirSync(path_1.default.dirname(outputPath));
        if (yield zip.writeZipPromise(outputPath)) {
            console.log(`A backup of your project was created to ${outputPath}`);
        }
        else {
            throw new Error(`Error writting zip file to ${outputPath}`);
        }
    });
}
function restoreBackup(backupPath) {
    return __awaiter(this, void 0, void 0, function* () {
        var zip = new adm_zip_1.default(backupPath); // reading archives
        zip.extractAllTo("./", true); // overwrite
    });
}
function updatePackages() {
    return __awaiter(this, void 0, void 0, function* () {
        // Contains name of the package and minimum version
        const depedentPackages = ["office-addin-debugging", "office-addin-manifest"];
        let command = "npm install";
        let messageToBePrinted = "Installing latest versions of";
        for (let i = 0; i < depedentPackages.length; i++) {
            const depedentPackage = depedentPackages[i];
            command += ` ${depedentPackage}@latest`;
            messageToBePrinted += ` ${depedentPackage}`;
            if (i === depedentPackages.length - 2) {
                messageToBePrinted += " and";
            }
            else {
                messageToBePrinted += ",";
            }
        }
        command += ` --save-dev`;
        console.log(messageToBePrinted.slice(0, -1));
        yield execAsync(command);
    });
}
function updateManifestXmlReferences() {
    return __awaiter(this, void 0, void 0, function* () {
        yield updatePackageJson();
        yield updateWebpackConfig();
    });
}
function updatePackageJson() {
    return __awaiter(this, void 0, void 0, function* () {
        const packageJson = `./package.json`;
        const readFileAsync = util_1.default.promisify(fs_1.default.readFile);
        const data = yield readFileAsync(packageJson, "utf8");
        let content = JSON.parse(data);
        // Change .xml references to .json
        Object.keys(content.scripts).forEach(function (key) {
            content.scripts[key] = content.scripts[key].replace(/manifest.xml/gi, `manifest.json`);
        });
        // write updated json to file
        const writeFileAsync = util_1.default.promisify(fs_1.default.writeFile);
        yield writeFileAsync(packageJson, JSON.stringify(content, null, 2));
    });
}
function updateWebpackConfig() {
    return __awaiter(this, void 0, void 0, function* () {
        const weppackConfig = `./webpack.config.js`;
        const readFileAsync = util_1.default.promisify(fs_1.default.readFile);
        const data = yield readFileAsync(weppackConfig, "utf8");
        // switching to json extension is the easy fix.
        // TODO: update to remove the manifest copy plugin since it's not needed in webpack
        let content = data.replace(/"(manifest\*\.)xml"/gi, '"$1json"');
        const writeFileAsync = util_1.default.promisify(fs_1.default.writeFile);
        yield writeFileAsync(weppackConfig, content);
    });
}
//# sourceMappingURL=convert.js.map
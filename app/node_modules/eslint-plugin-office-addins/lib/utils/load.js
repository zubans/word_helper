"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isLoadFunction = isLoadFunction;
exports.isLoadCall = isLoadCall;
exports.isLoadReference = isLoadReference;
exports.isContextLoadArgumentReference = isContextLoadArgumentReference;
exports.parseLoadArguments = parseLoadArguments;
exports.parsePropertiesArgument = parsePropertiesArgument;
const utils_1 = require("@typescript-eslint/utils");
const utils_2 = require("./utils");
function isLoadFunction(node) {
    const methodCall = (0, utils_2.findCallExpression)(node);
    return methodCall !== undefined && isLoadCall(methodCall);
}
function isLoadCall(node) {
    return (node &&
        node.callee.type === utils_1.AST_NODE_TYPES.MemberExpression &&
        node.callee.property.type === utils_1.AST_NODE_TYPES.Identifier &&
        node.callee.property.name === "load");
}
function isLoadReference(node) {
    return (node.parent &&
        node.parent.type === utils_1.TSESTree.AST_NODE_TYPES.MemberExpression &&
        isLoadFunction(node.parent));
}
function isContextLoadArgumentReference(node) {
    var _a;
    return (((_a = node.parent) === null || _a === void 0 ? void 0 : _a.type) === utils_1.AST_NODE_TYPES.CallExpression &&
        node.parent.callee.type === utils_1.AST_NODE_TYPES.MemberExpression &&
        node.parent.callee.object.type === utils_1.AST_NODE_TYPES.Identifier &&
        node.parent.callee.object.name === "context" &&
        node.parent.callee.property.type === utils_1.AST_NODE_TYPES.Identifier &&
        node.parent.callee.property.name === "load");
}
function parseObjectExpressionProperty(objectExpression) {
    let composedProperties = [];
    objectExpression.properties.forEach((property) => {
        if (property.type === utils_1.AST_NODE_TYPES.Property &&
            property.key.type === utils_1.AST_NODE_TYPES.Identifier) {
            const propertyName = property.key.name;
            if (property.value.type === utils_1.AST_NODE_TYPES.ObjectExpression) {
                const composedProperty = parseObjectExpressionProperty(property.value);
                if (composedProperty.length !== 0) {
                    composedProperties = composedProperties.concat(propertyName + "/" + composedProperty);
                }
            }
            else if (property.value.type === utils_1.AST_NODE_TYPES.Literal &&
                property.value.value // Checking if the value assigined to the property is true
            ) {
                composedProperties = composedProperties.concat(propertyName);
            }
        }
    });
    return composedProperties;
}
function parseLoadStringArgument(argument) {
    const properties = [];
    argument
        .replace(/\s/g, "")
        .split(",")
        .forEach((property) => {
        properties.push(property);
    });
    return properties;
}
function parseLoadArguments(node) {
    const methodCall = (0, utils_2.findCallExpression)(node);
    if (methodCall && isLoadCall(methodCall)) {
        const argument = methodCall.arguments[0];
        if (!argument) {
            return [];
        }
        return parsePropertiesArgument(argument);
    }
    throw new Error("error in parseLoadArgument function.");
}
function parsePropertiesArgument(argument) {
    let properties = [];
    if (argument.type === utils_1.AST_NODE_TYPES.ArrayExpression) {
        argument.elements.forEach((element) => {
            if (element != null && element.type === utils_1.TSESTree.AST_NODE_TYPES.Literal) {
                properties = properties.concat(parseLoadStringArgument(element.value));
            }
        });
    }
    else if (argument.type === utils_1.TSESTree.AST_NODE_TYPES.Literal) {
        properties = parseLoadStringArgument(argument.value);
    }
    else if (argument.type === utils_1.TSESTree.AST_NODE_TYPES.ObjectExpression) {
        properties = parseObjectExpressionProperty(argument);
    }
    return properties;
}
//# sourceMappingURL=load.js.map
"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.FxCore = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const jsonschema = tslib_1.__importStar(require("jsonschema"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const typedi_1 = require("typedi");
const url_1 = require("url");
const constants_1 = require("../common/constants");
const globalVars_1 = require("../common/globalVars");
const localizeUtils_1 = require("../common/localizeUtils");
const projectSettingsHelper_1 = require("../common/projectSettingsHelper");
const projectTypeChecker_1 = require("../common/projectTypeChecker");
const telemetry_1 = require("../common/telemetry");
const versionMetadata_1 = require("../common/versionMetadata");
const parser_1 = require("../component/configManager/parser");
const constants_2 = require("../component/constants");
const coordinator_1 = require("../component/coordinator");
const buildAadManifest_1 = require("../component/driver/aad/utility/buildAadManifest");
require("../component/driver/index");
require("../component/driver/script/scriptDriver");
const appStudio_1 = require("../component/driver/teamsApp/appStudio");
const errors_1 = require("../component/driver/teamsApp/errors");
const results_1 = require("../component/driver/teamsApp/results");
const teamsappMgr_1 = require("../component/driver/teamsApp/teamsappMgr");
const CopilotGptManifestUtils_1 = require("../component/driver/teamsApp/utils/CopilotGptManifestUtils");
const ManifestUtils_1 = require("../component/driver/teamsApp/utils/ManifestUtils");
const PluginManifestUtils_1 = require("../component/driver/teamsApp/utils/PluginManifestUtils");
const utils_1 = require("../component/driver/teamsApp/utils/utils");
const utils_2 = require("../component/driver/util/utils");
require("../component/feature/sso");
const helper_1 = require("../component/generator/apiSpec/helper");
const launchHelper_1 = require("../component/m365/launchHelper");
const envMW_1 = require("../component/middleware/envMW");
const questionMW_1 = require("../component/middleware/questionMW");
const common_1 = require("../component/utils/common");
const envUtil_1 = require("../component/utils/envUtil");
const metadataUtil_1 = require("../component/utils/metadataUtil");
const pathUtils_1 = require("../component/utils/pathUtils");
const settingsUtil_1 = require("../component/utils/settingsUtil");
const common_2 = require("../error/common");
const upgrade_1 = require("../error/upgrade");
const yml_1 = require("../error/yml");
const constants_3 = require("../question/constants");
const create_1 = require("../question/create");
const other_1 = require("../question/other");
const callback_1 = require("./callback");
const collaborator_1 = require("./collaborator");
const crypto_1 = require("./crypto");
const environmentName_1 = require("./environmentName");
const concurrentLocker_1 = require("./middleware/concurrentLocker");
const contextInjector_1 = require("./middleware/contextInjector");
const errorHandler_1 = require("./middleware/errorHandler");
const projectMigratorV3_1 = require("./middleware/projectMigratorV3");
const v3MigrationUtils_1 = require("./middleware/utils/v3MigrationUtils");
const telemetry_2 = require("./telemetry");
const packageService_1 = require("../component/m365/packageService");
const serviceConstant_1 = require("../component/m365/serviceConstant");
const teamsDevPortalClient_1 = require("../client/teamsDevPortalClient");
const utils_3 = require("../common/utils");
const helper_2 = require("../component/generator/copilotExtension/helper");
const featureFlags_1 = require("../common/featureFlags");
class FxCore {
    constructor(tools) {
        (0, globalVars_1.setTools)(tools);
    }
    /**
     * @todo this's a really primitive implement. Maybe could use Subscription Model to
     * refactor later.
     */
    on(event, callback) {
        return callback_1.CallbackRegistry.set(event, callback);
    }
    async createProject(inputs) {
        const context = (0, globalVars_1.createContext)();
        if (inputs[constants_3.QuestionNames.ProjectType] === constants_3.ProjectTypeOptions.startWithGithubCopilot().id) {
            return (0, teamsfx_api_1.ok)({ projectPath: "", shouldInvokeTeamsAgent: true });
        }
        inputs[constants_3.QuestionNames.Scratch] = constants_3.ScratchOptions.yes().id;
        if (inputs.teamsAppFromTdp) {
            // should never happen as we do same check on Developer Portal.
            if ((0, utils_1.containsUnsupportedFeature)(inputs.teamsAppFromTdp)) {
                return (0, teamsfx_api_1.err)(new common_2.InputValidationError("manifest.json", "Teams app contains unsupported features"));
            }
            else {
                context.telemetryReporter.sendTelemetryEvent(telemetry_2.CoreTelemetryEvent.CreateFromTdpStart, {
                    [telemetry_2.CoreTelemetryProperty.TdpTeamsAppFeatures]: (0, utils_1.getFeaturesFromAppDefinition)(inputs.teamsAppFromTdp).join(","),
                    [telemetry_2.CoreTelemetryProperty.TdpTeamsAppId]: inputs.teamsAppFromTdp.teamsAppId,
                });
            }
        }
        const res = await coordinator_1.coordinator.create(context, inputs);
        inputs.projectPath = context.projectPath;
        return res;
    }
    async createProjectByCustomizedGenerator(inputs, generator) {
        //1. input validation
        let folder = inputs["folder"];
        if (!folder) {
            return (0, teamsfx_api_1.err)(new common_2.MissingRequiredInputError("folder"));
        }
        folder = path.resolve(folder);
        const appName = inputs["app-name"];
        if (undefined === appName)
            return (0, teamsfx_api_1.err)(new common_2.MissingRequiredInputError(constants_3.QuestionNames.AppName));
        const validateResult = jsonschema.validate(appName, {
            pattern: constants_3.AppNamePattern,
        });
        if (validateResult.errors && validateResult.errors.length > 0) {
            return (0, teamsfx_api_1.err)(new common_2.InputValidationError(constants_3.QuestionNames.AppName, validateResult.errors[0].message));
        }
        const projectPath = path.join(folder, appName);
        //2. run generator
        const context = (0, globalVars_1.createContext)();
        const genRes = await generator.run(context, inputs, projectPath);
        if (genRes.isErr())
            return (0, teamsfx_api_1.err)(genRes.error);
        //3. ensure unique projectId in teamsapp.yaml (optional)
        const ymlPath = path.join(projectPath, versionMetadata_1.MetadataV3.configFile);
        const result = { projectPath: projectPath };
        if (await fs_extra_1.default.pathExists(ymlPath)) {
            const ensureRes = await coordinator_1.coordinator.ensureTrackingId(projectPath, inputs.projectId);
            if (ensureRes.isErr())
                return (0, teamsfx_api_1.err)(ensureRes.error);
            result.projectId = ensureRes.value;
        }
        return (0, teamsfx_api_1.ok)(result);
    }
    /**
     * lifecycle command: create new sample project
     */
    async createSampleProject(inputs) {
        const context = (0, globalVars_1.createContext)();
        inputs[constants_3.QuestionNames.Scratch] = constants_3.ScratchOptions.no().id;
        const res = await coordinator_1.coordinator.create(context, inputs);
        inputs.projectPath = context.projectPath;
        return res;
    }
    /**
     * lifecycle commands: provision
     */
    async provisionResources(inputs, ctx) {
        inputs.stage = teamsfx_api_1.Stage.provision;
        const context = (0, utils_2.createDriverContext)(inputs);
        try {
            const res = await coordinator_1.coordinator.provision(context, inputs);
            if (res.isOk()) {
                ctx.envVars = res.value;
                return (0, teamsfx_api_1.ok)(undefined);
            }
            else {
                // for partial success scenario, output is set in inputs object
                ctx.envVars = inputs.envVars;
                return (0, teamsfx_api_1.err)(res.error);
            }
        }
        finally {
            //reset subscription
            try {
                await globalVars_1.TOOLS.tokenProvider.azureAccountProvider.setSubscription("");
            }
            catch (e) { }
        }
    }
    /**
     * none lifecycle command, uninstall provisioned resources
     */
    async uninstall(inputs) {
        switch (inputs[constants_3.QuestionNames.UninstallMode]) {
            case constants_3.QuestionNames.UninstallModeManifestId:
                return await this.uninstallByManifestId(inputs);
            case constants_3.QuestionNames.UninstallModeEnv:
                return await this.uninstallByEnv(inputs);
            case constants_3.QuestionNames.UninstallModeTitleId:
                return await this.uninstallByTitleId(inputs);
            default:
                return (0, teamsfx_api_1.err)(new common_2.UnhandledError(new Error("Uninstall mode not supported"), "FxCore"));
        }
    }
    /**
     * uninstall provisioned resources by manifest ID
     */
    async uninstallByManifestId(inputs) {
        const manifestId = inputs[constants_3.QuestionNames.ManifestId];
        if (!manifestId) {
            return (0, teamsfx_api_1.err)(new common_2.MissingRequiredInputError("manifest-id", "FxCore"));
        }
        const uninstallOptions = inputs[constants_3.QuestionNames.UninstallOptions];
        const m356AppOption = uninstallOptions === null || uninstallOptions === void 0 ? void 0 : uninstallOptions.includes(constants_3.QuestionNames.UninstallOptionM365);
        const tdpOption = uninstallOptions === null || uninstallOptions === void 0 ? void 0 : uninstallOptions.includes(constants_3.QuestionNames.UninstallOptionTDP);
        const botOption = uninstallOptions === null || uninstallOptions === void 0 ? void 0 : uninstallOptions.includes(constants_3.QuestionNames.UninstallOptionBot);
        if (m356AppOption) {
            const res = await this.uninstallM365App(undefined, manifestId);
            if (res.isErr()) {
                return (0, teamsfx_api_1.err)(res.error);
            }
        }
        if (botOption) {
            const res = await this.uninstallBotFrameworRegistration(undefined, manifestId);
            if (res.isErr()) {
                return (0, teamsfx_api_1.err)(res.error);
            }
        }
        // App registraion should be the last to remove, because we might need to query some metadata from TDP.
        if (tdpOption) {
            const res = await this.uninstallAppRegistration(manifestId);
            if (res.isErr()) {
                return (0, teamsfx_api_1.err)(res.error);
            }
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /**
     * uninstall provisioned resources by a given environment
     */
    async uninstallByEnv(inputs, ctx) {
        var _a, _b, _c, _d, _e;
        if (!inputs.env) {
            return (0, teamsfx_api_1.err)(new common_2.MissingRequiredInputError("env", "FxCore"));
        }
        const teamsappYamlPath = pathUtils_1.pathUtils.getYmlFilePath(inputs.projectPath, inputs.env);
        const yamlProjectModel = await metadataUtil_1.metadataUtil.parse(teamsappYamlPath, inputs.env);
        if (yamlProjectModel.isErr()) {
            return (0, teamsfx_api_1.err)(yamlProjectModel.error);
        }
        const projectModel = yamlProjectModel.value;
        let teamsAppId;
        let botId;
        let m365TitleId;
        let teamsAppIdKeyName = "";
        let botIdKeyName = "";
        let m365TitleIdKeyName = "";
        for (const action of (_b = (_a = projectModel.provision) === null || _a === void 0 ? void 0 : _a.driverDefs) !== null && _b !== void 0 ? _b : []) {
            if (action.uses === "teamsApp/create") {
                teamsAppIdKeyName = ((_c = action.writeToEnvironmentFile) === null || _c === void 0 ? void 0 : _c.teamsAppId) || "TEAMS_APP_ID";
                teamsAppId = process.env[teamsAppIdKeyName];
            }
            else if (action.uses === "botFramework/create") {
                botIdKeyName = ((_d = action.writeToEnvironmentFile) === null || _d === void 0 ? void 0 : _d.botId) || "BOT_ID";
                botId = process.env[botIdKeyName];
            }
            else if (action.uses === "teamsApp/extendToM365") {
                m365TitleIdKeyName = ((_e = action.writeToEnvironmentFile) === null || _e === void 0 ? void 0 : _e.titleId) || "M365_TITLE_ID";
                m365TitleId = process.env[m365TitleIdKeyName];
            }
        }
        const uninstallOptions = inputs[constants_3.QuestionNames.UninstallOptions];
        const m356AppOption = uninstallOptions === null || uninstallOptions === void 0 ? void 0 : uninstallOptions.includes(constants_3.QuestionNames.UninstallOptionM365);
        const tdpOption = uninstallOptions === null || uninstallOptions === void 0 ? void 0 : uninstallOptions.includes(constants_3.QuestionNames.UninstallOptionTDP);
        const botOption = uninstallOptions === null || uninstallOptions === void 0 ? void 0 : uninstallOptions.includes(constants_3.QuestionNames.UninstallOptionBot);
        if ((teamsAppId || m365TitleId) && m356AppOption) {
            const res = await this.uninstallM365App(m365TitleId, teamsAppId);
            if (res.isErr()) {
                return (0, teamsfx_api_1.err)(res.error);
            }
            this.resetEnvVar(teamsAppIdKeyName, ctx);
            this.resetEnvVar(m365TitleIdKeyName, ctx);
        }
        if (botId && botOption) {
            const res = await this.uninstallBotFrameworRegistration(botId);
            if (res.isErr()) {
                return (0, teamsfx_api_1.err)(res.error);
            }
            this.resetEnvVar(botIdKeyName, ctx);
        }
        // App registraion should be the last to remove, because we might need to query some metadata from TDP.
        if (teamsAppId && tdpOption) {
            const res = await this.uninstallAppRegistration(teamsAppId);
            if (res.isErr()) {
                return (0, teamsfx_api_1.err)(res.error);
            }
            this.resetEnvVar(teamsAppIdKeyName, ctx);
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    resetEnvVar(key, ctx, skipIfNotExist = true, resetValue = "") {
        if (!ctx) {
            return;
        }
        if (!ctx.envVars) {
            ctx.envVars = {};
        }
        if (skipIfNotExist && !ctx.envVars[key]) {
            return;
        }
        ctx.envVars[key] = resetValue;
        return;
    }
    /**
     * uninstall provisioned resources by title ID. Titlle mode only uninstalls M365 app.
     */
    async uninstallByTitleId(inputs) {
        const titleId = inputs[constants_3.QuestionNames.TitleId];
        if (!titleId) {
            return (0, teamsfx_api_1.err)(new common_2.MissingRequiredInputError("title-id", "FxCore"));
        }
        const res = await this.uninstallM365App(titleId);
        if (res.isErr()) {
            return (0, teamsfx_api_1.err)(res.error);
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /**
     * uninstall sideloaded appps in M365
     */
    async uninstallM365App(titleId, manifestId) {
        var _a, _b, _c, _d;
        if (titleId === undefined && manifestId === undefined) {
            return (0, teamsfx_api_1.err)(new common_2.MissingRequiredInputError("title id or manifest id", "FxCore"));
        }
        const sideloadingServiceEndpoint = (_a = process.env.SIDELOADING_SERVICE_ENDPOINT) !== null && _a !== void 0 ? _a : serviceConstant_1.MosServiceEndpoint;
        const sideloadingServiceScope = (_b = process.env.SIDELOADING_SERVICE_SCOPE) !== null && _b !== void 0 ? _b : serviceConstant_1.MosServiceScope;
        const sideloadingTokenRes = await globalVars_1.TOOLS.tokenProvider.m365TokenProvider.getAccessToken({
            scopes: [sideloadingServiceScope],
        });
        if (sideloadingTokenRes.isErr()) {
            return (0, teamsfx_api_1.err)(sideloadingTokenRes.error);
        }
        const packageService = new packageService_1.PackageService(sideloadingServiceEndpoint, globalVars_1.TOOLS.logProvider);
        if (titleId === undefined) {
            try {
                titleId = await packageService.retrieveTitleId(sideloadingTokenRes.value, manifestId !== null && manifestId !== void 0 ? manifestId : "");
            }
            catch (err) {
                await globalVars_1.TOOLS.ui.showMessage("info", (0, localizeUtils_1.getLocalizedString)("core.uninstall.failed.titleId"), false);
                throw (0, common_2.assembleError)(err);
            }
        }
        const confirmRes = await ((_d = (_c = globalVars_1.TOOLS.ui).confirm) === null || _d === void 0 ? void 0 : _d.call(_c, {
            name: "uninstallM365App",
            title: (0, localizeUtils_1.getLocalizedString)("core.uninstall.confirm.m365App", titleId),
            default: true,
        }));
        if ((confirmRes === null || confirmRes === void 0 ? void 0 : confirmRes.isOk()) && confirmRes.value.result === true) {
            await packageService.unacquire(sideloadingTokenRes.value, titleId);
            await globalVars_1.TOOLS.ui.showMessage("info", (0, localizeUtils_1.getLocalizedString)("core.uninstall.success.m365App", titleId), false);
            await globalVars_1.TOOLS.ui.showMessage("info", (0, localizeUtils_1.getLocalizedString)("core.uninstall.success.delayWarning"), false);
        }
        else {
            await globalVars_1.TOOLS.ui.showMessage("info", (0, localizeUtils_1.getLocalizedString)("core.uninstall.confirm.cancel.m365App"), false);
            return (0, teamsfx_api_1.err)(new common_2.UserCancelError("Uninstall M365 App"));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /**
     * uninstall sideloaded apps in Teams Developer Portal
     */
    async uninstallAppRegistration(manifestId) {
        var _a, _b;
        const appStudioTokenRes = await globalVars_1.TOOLS.tokenProvider.m365TokenProvider.getAccessToken({
            scopes: constants_1.AppStudioScopes,
        });
        if (appStudioTokenRes.isErr()) {
            return (0, teamsfx_api_1.err)(appStudioTokenRes.error);
        }
        const confirmRes = await ((_b = (_a = globalVars_1.TOOLS.ui).confirm) === null || _b === void 0 ? void 0 : _b.call(_a, {
            name: "uninstallAppRegistration",
            title: (0, localizeUtils_1.getLocalizedString)("core.uninstall.confirm.tdp", manifestId),
            default: true,
        }));
        if ((confirmRes === null || confirmRes === void 0 ? void 0 : confirmRes.isOk()) && confirmRes.value.result === true) {
            const token = appStudioTokenRes.value;
            await teamsDevPortalClient_1.teamsDevPortalClient.deleteApp(token, manifestId);
            await globalVars_1.TOOLS.ui.showMessage("info", (0, localizeUtils_1.getLocalizedString)("core.uninstall.success.tdp", manifestId), false);
            return (0, teamsfx_api_1.ok)(undefined);
        }
        else {
            await globalVars_1.TOOLS.ui.showMessage("info", (0, localizeUtils_1.getLocalizedString)("core.uninstall.confirm.cancel.tdp"), false);
            return (0, teamsfx_api_1.err)(new common_2.UserCancelError("Uninstall App Registration"));
        }
    }
    /**
     * uninstall bots created in dev.botframework.com
     */
    async uninstallBotFrameworRegistration(botId, manifestId) {
        var _a, _b;
        if (!botId && !manifestId) {
            return (0, teamsfx_api_1.err)(new common_2.MissingRequiredInputError("bot id or manifest id", "FxCore"));
        }
        const appStudioTokenRes = await globalVars_1.TOOLS.tokenProvider.m365TokenProvider.getAccessToken({
            scopes: constants_1.AppStudioScopes,
        });
        if (appStudioTokenRes.isErr()) {
            return (0, teamsfx_api_1.err)(appStudioTokenRes.error);
        }
        const token = appStudioTokenRes.value;
        if (!botId) {
            const botIdRes = await teamsDevPortalClient_1.teamsDevPortalClient.getBotId(token, manifestId);
            if (!botIdRes) {
                const msg = (0, localizeUtils_1.getLocalizedString)("core.uninstall.botNotFound", manifestId);
                return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError("FxCore", "Uninstall", msg, msg));
            }
            botId = botIdRes;
        }
        const confirmRes = await ((_b = (_a = globalVars_1.TOOLS.ui).confirm) === null || _b === void 0 ? void 0 : _b.call(_a, {
            name: "uninstallBotFrameworRegistration",
            title: (0, localizeUtils_1.getLocalizedString)("core.uninstall.confirm.bot", botId),
            default: true,
        }));
        if ((confirmRes === null || confirmRes === void 0 ? void 0 : confirmRes.isOk()) && confirmRes.value.result === true) {
            await teamsDevPortalClient_1.teamsDevPortalClient.deleteBot(token, botId);
            await globalVars_1.TOOLS.ui.showMessage("info", (0, localizeUtils_1.getLocalizedString)("core.uninstall.success.bot", botId), false);
        }
        else {
            await globalVars_1.TOOLS.ui.showMessage("info", (0, localizeUtils_1.getLocalizedString)("core.uninstall.confirm.cancel.bot"), false);
            return (0, teamsfx_api_1.err)(new common_2.UserCancelError("Uninstall Bot Framework Registration"));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /**
     * lifecycle commands: deploy
     */
    async deployArtifacts(inputs, ctx) {
        inputs.stage = teamsfx_api_1.Stage.deploy;
        const context = (0, utils_2.createDriverContext)(inputs);
        const res = await coordinator_1.coordinator.deploy(context, inputs);
        if (res.isOk()) {
            ctx.envVars = res.value;
            return (0, teamsfx_api_1.ok)(undefined);
        }
        else {
            // for partial success scenario, output is set in inputs object
            ctx.envVars = inputs.envVars;
            return (0, teamsfx_api_1.err)(res.error);
        }
    }
    async localDebug(inputs) {
        inputs.env = environmentName_1.environmentNameManager.getLocalEnvName();
        return this.provisionResources(inputs);
    }
    /**
     * none lifecycle command, v3 only
     */
    async deployAadManifest(inputs) {
        inputs.stage = teamsfx_api_1.Stage.deployAad;
        const updateAadClient = typedi_1.Container.get("aadApp/update");
        // In V3, the aad.template.json exist at .fx folder, and output to root build folder.
        const manifestTemplatePath = inputs[constants_3.QuestionNames.AadAppManifestFilePath];
        if (!(await fs_extra_1.default.pathExists(manifestTemplatePath))) {
            return (0, teamsfx_api_1.err)(new common_2.FileNotFoundError("deployAadManifest", manifestTemplatePath));
        }
        let manifestOutputPath = manifestTemplatePath;
        if (inputs.env && (await (0, other_1.isAadMainifestContainsPlaceholder)(inputs))) {
            await fs_extra_1.default.ensureDir(path.join(inputs.projectPath, "build"));
            manifestOutputPath = path.join(inputs.projectPath, "build", `aad.manifest.${inputs.env}.json`);
        }
        const inputArgs = {
            manifestPath: manifestTemplatePath,
            outputFilePath: manifestOutputPath,
        };
        const Context = (0, utils_2.createDriverContext)(inputs);
        (0, globalVars_1.setErrorContext)({ component: "aadAppUpdate" });
        const res = await updateAadClient.execute(inputArgs, Context);
        if (res.result.isErr()) {
            return (0, teamsfx_api_1.err)(res.result.error);
        }
        if (Context.platform === teamsfx_api_1.Platform.CLI) {
            const msg = (0, localizeUtils_1.getLocalizedString)("core.deploy.aadManifestOnCLISuccessNotice");
            void Context.ui.showMessage("info", msg, false);
        }
        else {
            const msg = (0, localizeUtils_1.getLocalizedString)("core.deploy.aadManifestSuccessNotice");
            void Context.ui.showMessage("info", msg, false, (0, localizeUtils_1.getLocalizedString)("core.deploy.aadManifestLearnMore")).then((result) => {
                const userSelected = result.isOk() ? result.value : undefined;
                if (userSelected === (0, localizeUtils_1.getLocalizedString)("core.deploy.aadManifestLearnMore")) {
                    void Context.ui.openUrl(constants_2.ViewAadAppHelpLinkV5);
                }
            });
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /**
     * none lifecycle command, v3 only
     */
    async addWebpart(inputs) {
        (0, globalVars_1.setErrorContext)({ component: "spfxAdd", method: "run" });
        const driver = typedi_1.Container.get("spfx/add");
        const args = {
            manifestPath: inputs[constants_3.QuestionNames.ManifestPath],
            localManifestPath: inputs[constants_3.QuestionNames.LocalTeamsAppManifestFilePath],
            spfxFolder: inputs[constants_3.QuestionNames.SPFxFolder],
            webpartName: inputs[constants_3.QuestionNames.SPFxWebpartName],
            framework: inputs[constants_3.QuestionNames.SPFxFramework],
            spfxPackage: constants_3.SPFxVersionOptionIds.installLocally,
        };
        const Context = (0, utils_2.createDriverContext)(inputs);
        const res = await driver.run(args, Context);
        if (res.isErr()) {
            return (0, teamsfx_api_1.err)(res.error);
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /**
     * lifecycle command: publish
     */
    async publishApplication(inputs, ctx) {
        inputs.stage = teamsfx_api_1.Stage.publish;
        const context = (0, utils_2.createDriverContext)(inputs);
        const res = await coordinator_1.coordinator.publish(context, inputs);
        if (res.isOk()) {
            ctx.envVars = res.value;
            return (0, teamsfx_api_1.ok)(undefined);
        }
        else {
            // for partial success scenario, output is set in inputs object
            ctx.envVars = inputs.envVars;
            return (0, teamsfx_api_1.err)(res.error);
        }
    }
    /**
     * most commands will be deprecated in V3
     */
    async executeUserTask(func, inputs) {
        let res = (0, teamsfx_api_1.ok)(undefined);
        const context = (0, utils_2.createDriverContext)(inputs);
        if (func.method === "addSso") {
            // used in v3 only in VS
            inputs.stage = teamsfx_api_1.Stage.addFeature;
            inputs[constants_3.QuestionNames.Features] = constants_2.SingleSignOnOptionItem.id;
            const component = typedi_1.Container.get("sso");
            (0, globalVars_1.setErrorContext)({ component: "sso", method: "add" });
            res = await component.add(context, inputs);
        }
        return res;
    }
    /**
     * v3 only none lifecycle command
     */
    async buildAadManifest(inputs) {
        const manifestTemplatePath = inputs.AAD_MANIFEST_FILE
            ? inputs.AAD_MANIFEST_FILE
            : path.join(inputs.projectPath, constants_2.AadConstants.DefaultTemplateFileName);
        if (!(await fs_extra_1.default.pathExists(manifestTemplatePath))) {
            return (0, teamsfx_api_1.err)(new common_2.FileNotFoundError("buildAadManifest", manifestTemplatePath));
        }
        await fs_extra_1.default.ensureDir(path.join(inputs.projectPath, "build"));
        const manifestOutputPath = path.join(inputs.projectPath, "build", 
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        `aad.${inputs.env}.json`);
        const Context = (0, utils_2.createDriverContext)(inputs);
        await (0, buildAadManifest_1.buildAadManifest)(Context, manifestTemplatePath, manifestOutputPath);
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /**
     * v3 only none lifecycle command
     */
    async deployTeamsManifest(inputs, ctx) {
        inputs.manifestTemplatePath = inputs[constants_3.QuestionNames.TeamsAppManifestFilePath];
        const context = (0, globalVars_1.createContext)();
        const res = await (0, appStudio_1.updateManifestV3)(context, inputs);
        if (res.isOk()) {
            ctx.envVars = envUtil_1.envUtil.map2object(res.value);
            return (0, teamsfx_api_1.ok)(undefined);
        }
        return (0, teamsfx_api_1.err)(res.error);
    }
    /******
     * CLI v3 commands
     */
    async updateTeamsAppCLIV3(inputs) {
        const res = await teamsappMgr_1.teamsappMgr.updateTeamsApp(inputs);
        return res;
    }
    /******
     * CLI v3 commands
     */
    async validateTeamsAppCLIV3(inputs) {
        const res = await teamsappMgr_1.teamsappMgr.validateTeamsApp(inputs);
        return res;
    }
    /******
     * CLI v3 commands
     */
    async packageTeamsAppCLIV3(inputs) {
        const res = await teamsappMgr_1.teamsappMgr.packageTeamsApp(inputs);
        if (res.isErr()) {
            return (0, teamsfx_api_1.err)(res.error);
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /******
     * CLI v3 commands
     */
    async publishTeamsAppCLIV3(inputs) {
        const res = await teamsappMgr_1.teamsappMgr.publishTeamsApp(inputs);
        return res;
    }
    /**
     * v3 only none lifecycle command
     */
    async validateApplication(inputs) {
        if (inputs["manifest-path"]) {
            return await this.validateManifest(inputs);
        }
        else if (inputs[constants_3.QuestionNames.ValidateMethod] === constants_3.TeamsAppValidationOptions.testCases().id) {
            return await this.validateWithTestCases(inputs);
        }
        else {
            return await this.validateAppPackage(inputs);
        }
    }
    /**
     * v3 only none lifecycle command
     */
    async validateManifest(inputs) {
        inputs.stage = teamsfx_api_1.Stage.validateApplication;
        const context = (0, utils_2.createDriverContext)(inputs);
        const teamsAppManifestFilePath = inputs["manifest-path"];
        const args = {
            manifestPath: teamsAppManifestFilePath,
            showMessage: (inputs === null || inputs === void 0 ? void 0 : inputs.showMessage) != undefined ? inputs.showMessage : true,
        };
        const driver = typedi_1.Container.get("teamsApp/validateManifest");
        const result = await driver.execute(args, context);
        return result.result;
    }
    /**
     * v3 only none lifecycle command
     */
    async validateAppPackage(inputs) {
        inputs.stage = teamsfx_api_1.Stage.validateApplication;
        const context = (0, utils_2.createDriverContext)(inputs);
        const teamsAppPackageFilePath = inputs["app-package-file-path"];
        const args = {
            appPackagePath: teamsAppPackageFilePath,
            showMessage: true,
        };
        const driver = typedi_1.Container.get("teamsApp/validateAppPackage");
        return (await driver.execute(args, context)).result;
    }
    async validateWithTestCases(inputs) {
        const context = (0, utils_2.createDriverContext)(inputs);
        const args = {
            appPackagePath: inputs["app-package-file-path"],
            showMessage: true,
            showProgressBar: true,
        };
        const driver = typedi_1.Container.get("teamsApp/validateWithTestCases");
        return (await driver.execute(args, context)).result;
    }
    /**
     * v3 only none lifecycle command
     */
    async syncManifest(inputs) {
        const context = (0, utils_2.createDriverContext)(inputs);
        const projectPath = inputs[constants_3.QuestionNames.ProjectPath];
        const env = inputs[constants_3.QuestionNames.Env];
        const teamsAppId = inputs[constants_3.QuestionNames.TeamsAppId];
        const args = {
            projectPath: projectPath,
            env: env,
            teamsAppId: teamsAppId,
        };
        const driver = typedi_1.Container.get("teamsApp/syncManifest");
        return (await driver.execute(args, context)).result;
    }
    /**
     * v3 only none lifecycle command
     */
    async createAppPackage(inputs) {
        var _a, _b, _c;
        inputs.stage = teamsfx_api_1.Stage.createAppPackage;
        const context = (0, utils_2.createDriverContext)(inputs);
        const teamsAppManifestFilePath = inputs === null || inputs === void 0 ? void 0 : inputs[constants_3.QuestionNames.TeamsAppManifestFilePath];
        const driver = typedi_1.Container.get("teamsApp/zipAppPackage");
        const args = {
            manifestPath: teamsAppManifestFilePath,
            outputZipPath: (_a = inputs[constants_3.QuestionNames.OutputZipPathParamName]) !== null && _a !== void 0 ? _a : 
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${inputs.projectPath}/${teamsfx_api_1.AppPackageFolderName}/${teamsfx_api_1.BuildFolderName}/appPackage.${process.env
                .TEAMSFX_ENV}.zip`,
            outputFolder: (_b = inputs[constants_3.QuestionNames.OutputManifestParamName]) !== null && _b !== void 0 ? _b : 
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            `${inputs.projectPath}/${teamsfx_api_1.AppPackageFolderName}/${teamsfx_api_1.BuildFolderName}`,
        };
        const result = (await driver.execute(args, context)).result;
        if (context.platform === teamsfx_api_1.Platform.VSCode) {
            if (result.isOk()) {
                const isWindows = process.platform === "win32";
                let zipFileName = args.outputZipPath;
                if (!path.isAbsolute(zipFileName)) {
                    zipFileName = path.join(context.projectPath, zipFileName);
                }
                let builtSuccess = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.buildSucceedNotice.fallback", zipFileName);
                if (isWindows) {
                    const folderLink = (0, url_1.pathToFileURL)(path.dirname(zipFileName));
                    const appPackageLink = `${constants_1.VSCodeExtensionCommand.openFolder}?%5B%22${folderLink.toString()}%22%5D`;
                    builtSuccess = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.buildSucceedNotice", appPackageLink);
                }
                (_c = context.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", builtSuccess, false);
            }
        }
        return result;
    }
    /**
     * get url to preview the app, may prompt to select env, hub and Teams manifest
     * v3 only none lifecycle command
     * @param {Inputs} inputs
     * @returns the url to preview the app
     */
    async previewWithManifest(inputs) {
        inputs.stage = teamsfx_api_1.Stage.previewWithManifest;
        const hub = inputs[constants_3.QuestionNames.M365Host];
        const manifestFilePath = inputs[constants_3.QuestionNames.TeamsAppManifestFilePath];
        const context = (0, globalVars_1.createContext)();
        const manifestRes = await ManifestUtils_1.manifestUtils.getManifestV3(manifestFilePath, (0, utils_3.generateDriverContext)(context, inputs), false);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const teamsAppId = manifestRes.value.id;
        const properties = teamsfx_api_1.ManifestUtil.parseCommonProperties(manifestRes.value);
        const launchHelper = new launchHelper_1.LaunchHelper(globalVars_1.TOOLS.tokenProvider.m365TokenProvider, globalVars_1.TOOLS.logProvider);
        const result = await launchHelper.getLaunchUrl(hub, teamsAppId, properties, true);
        return result;
    }
    /**
     * Warning: this API only works for CLI_HELP, it has no business with interactive run for CLI!
     */
    getQuestions(stage, inputs) {
        if (stage === teamsfx_api_1.Stage.create) {
            return (0, teamsfx_api_1.ok)((0, create_1.createProjectCliHelpNode)());
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /**
     * get all dot envs
     */
    async getDotEnvs(inputs) {
        const envListRes = await envUtil_1.envUtil.listEnv(inputs.projectPath);
        if (envListRes.isErr()) {
            return (0, teamsfx_api_1.err)(envListRes.error);
        }
        const res = {};
        for (const env of envListRes.value) {
            const envRes = await envUtil_1.envUtil.readEnv(inputs.projectPath, env, false, false);
            if (envRes.isErr()) {
                return (0, teamsfx_api_1.err)(envRes.error);
            }
            res[env] = envRes.value;
        }
        return (0, teamsfx_api_1.ok)(res);
    }
    /**
     * given projectPath and filePath, return whether the filePath is a env file
     */
    async isEnvFile(projectPath, inputFile) {
        const inputFileName = path.basename(inputFile);
        const envName = envUtil_1.envUtil.extractEnvNameFromFileName(inputFileName);
        if (!envName)
            return (0, teamsfx_api_1.ok)(false);
        const folderRes = await pathUtils_1.pathUtils.getEnvFolderPath(projectPath);
        if (folderRes.isErr())
            return (0, teamsfx_api_1.err)(folderRes.error);
        const envFolderPath = folderRes.value;
        if (!envFolderPath)
            return (0, teamsfx_api_1.ok)(false);
        const inputFileDir = path.dirname(inputFile);
        if (path.resolve(inputFileDir) !== path.resolve(envFolderPath))
            return (0, teamsfx_api_1.ok)(false);
        return (0, teamsfx_api_1.ok)(true);
    }
    /**
     * get projectId
     */
    async getProjectId(projectPath) {
        const res = await this.getProjectMetadata(projectPath);
        if (res.isErr()) {
            return (0, teamsfx_api_1.err)(res.error);
        }
        return (0, teamsfx_api_1.ok)(res.value.projectId || "");
    }
    /**
     * @description get projectId and version from yml
     */
    async getProjectMetadata(projectPath) {
        const res = (0, projectSettingsHelper_1.getProjectMetadata)(projectPath);
        if (!res)
            return (0, teamsfx_api_1.ok)({});
        return Promise.resolve((0, teamsfx_api_1.ok)(res));
    }
    /**
     * get Teams App Name from yml
     */
    async getTeamsAppName(projectPath) {
        var _a;
        const ymlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath, "dev");
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(ymlPath, "dev");
        if (maybeProjectModel.isErr()) {
            return (0, teamsfx_api_1.err)(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        if (projectModel.provision) {
            const teamsAppCreate = (_a = projectModel.provision) === null || _a === void 0 ? void 0 : _a.driverDefs.find((d) => d.uses === "teamsApp/create");
            if (teamsAppCreate) {
                let name = teamsAppCreate.with.name;
                if (name) {
                    name = (0, common_1.expandEnvironmentVariable)(name, { APP_NAME_SUFFIX: "", TEAMSFX_ENV: " " }).trim();
                    return (0, teamsfx_api_1.ok)(name);
                }
            }
        }
        return (0, teamsfx_api_1.ok)("");
    }
    /**
     * get project info
     */
    async getProjectInfo(projectPath, env) {
        var _a;
        const ymlPath = pathUtils_1.pathUtils.getYmlFilePath(projectPath, env);
        const maybeProjectModel = await metadataUtil_1.metadataUtil.parse(ymlPath, env);
        if (maybeProjectModel.isErr()) {
            return (0, teamsfx_api_1.err)(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const readEnvRes = await envUtil_1.envUtil.readEnv(projectPath, env, false, true);
        if (readEnvRes.isErr()) {
            return (0, teamsfx_api_1.err)(readEnvRes.error);
        }
        const envObject = readEnvRes.value;
        const res = {
            projectId: projectModel.projectId || "",
            teamsAppId: "",
            teamsAppName: "",
            m365TenantId: envObject.TEAMS_APP_TENANT_ID || "",
        };
        if (projectModel.provision) {
            const teamsAppCreate = projectModel.provision.driverDefs.find((d) => d.uses === "teamsApp/create");
            if (teamsAppCreate) {
                const teamsAppIdEnvName = (_a = teamsAppCreate.writeToEnvironmentFile) === null || _a === void 0 ? void 0 : _a.teamsAppId;
                if (teamsAppIdEnvName) {
                    const teamsAppId = envObject[teamsAppIdEnvName];
                    res.teamsAppId = teamsAppId;
                }
                const name = teamsAppCreate.with.name;
                if (name) {
                    res.teamsAppName = name.replace("-${{TEAMSFX_ENV}}", "") || "";
                }
            }
        }
        return (0, teamsfx_api_1.ok)(res);
    }
    async grantPermission(inputs) {
        inputs.stage = teamsfx_api_1.Stage.grantPermission;
        const context = (0, globalVars_1.createContext)();
        (0, globalVars_1.setErrorContext)({ component: "collaborator" });
        const res = await (0, collaborator_1.grantPermission)(context, inputs, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    /**
     * none lifecycle command
     */
    async checkPermission(inputs) {
        inputs.stage = teamsfx_api_1.Stage.checkPermission;
        const context = (0, globalVars_1.createContext)();
        const res = await (0, collaborator_1.checkPermission)(context, inputs, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    /**
     * none lifecycle command
     */
    async listCollaborator(inputs) {
        inputs.stage = teamsfx_api_1.Stage.listCollaborator;
        const context = (0, globalVars_1.createContext)();
        const res = await (0, collaborator_1.listCollaborator)(context, inputs, globalVars_1.TOOLS.tokenProvider);
        return res;
    }
    getSelectedEnv(inputs) {
        return Promise.resolve((0, teamsfx_api_1.ok)(inputs.env)); //work for both v2 and v3
    }
    async createLocalCrypto(projectPath) {
        const settingsRes = await settingsUtil_1.settingsUtil.readSettings(projectPath);
        if (settingsRes.isErr()) {
            return (0, teamsfx_api_1.err)(settingsRes.error);
        }
        const projectId = settingsRes.value.trackingId;
        const cryptoProvider = new crypto_1.LocalCrypto(projectId);
        return (0, teamsfx_api_1.ok)(cryptoProvider);
    }
    /**
     * only for vs code extension
     */
    async encrypt(plaintext, inputs) {
        const res = await this.createLocalCrypto(inputs.projectPath);
        if (res.isErr()) {
            return (0, teamsfx_api_1.err)(res.error);
        }
        return res.value.encrypt(plaintext);
    }
    /**
     * only for vs code extension
     */
    async decrypt(ciphertext, inputs) {
        const res = await this.createLocalCrypto(inputs.projectPath);
        if (res.isErr()) {
            return (0, teamsfx_api_1.err)(res.error);
        }
        return res.value.decrypt(ciphertext);
    }
    async createEnv(inputs) {
        return this.createEnvCopyV3(inputs[constants_3.QuestionNames.NewTargetEnvName], inputs[constants_3.QuestionNames.SourceEnvName], inputs.projectPath);
    }
    async createEnvCopyV3(targetEnvName, sourceEnvName, projectPath) {
        let res = await pathUtils_1.pathUtils.getEnvFilePath(projectPath, sourceEnvName);
        if (res.isErr())
            return (0, teamsfx_api_1.err)(res.error);
        const sourceDotEnvFile = res.value;
        res = await pathUtils_1.pathUtils.getEnvFilePath(projectPath, targetEnvName);
        if (res.isErr())
            return (0, teamsfx_api_1.err)(res.error);
        const targetDotEnvFile = res.value;
        if (!sourceDotEnvFile || !targetDotEnvFile)
            return (0, teamsfx_api_1.err)(new yml_1.YamlFieldMissingError("environmentFolderPath"));
        if (!(await fs_extra_1.default.pathExists(sourceDotEnvFile)))
            return (0, teamsfx_api_1.err)(new common_2.FileNotFoundError("createEnvCopyV3", sourceDotEnvFile));
        const source = await fs_extra_1.default.readFile(sourceDotEnvFile);
        const writeStream = fs_extra_1.default.createWriteStream(targetDotEnvFile);
        source
            .toString()
            .split(/\r?\n/)
            .forEach((line) => {
            const reg = /^([a-zA-Z_][a-zA-Z0-9_]*=)/g;
            const match = reg.exec(line);
            if (match) {
                if (match[1].startsWith("TEAMSFX_ENV=")) {
                    writeStream.write(`TEAMSFX_ENV=${targetEnvName}${os.EOL}`);
                }
                else if (match[1].startsWith("APP_NAME_SUFFIX=")) {
                    writeStream.write(`APP_NAME_SUFFIX=${targetEnvName}${os.EOL}`);
                }
                else {
                    writeStream.write(`${match[1]}${os.EOL}`);
                }
            }
            else {
                writeStream.write(`${line.trim()}${os.EOL}`);
            }
        });
        writeStream.end();
        globalVars_1.TOOLS.logProvider.info(`env file created: ${targetDotEnvFile}`);
        return (0, teamsfx_api_1.ok)(undefined);
    }
    // a phantom migration method for V3
    async phantomMigrationV3(inputs) {
        // If the project is invalid or upgraded, the ProjectMigratorMWV3 will not take action.
        // Check invaliad/upgraded project here before call ProjectMigratorMWV3
        const projectPath = inputs.projectPath || "";
        const version = await (0, v3MigrationUtils_1.getProjectVersionFromPath)(projectPath);
        if (version.source === versionMetadata_1.VersionSource.teamsapp) {
            return (0, teamsfx_api_1.err)(new upgrade_1.NoNeedUpgradeError());
        }
        else if (version.source === versionMetadata_1.VersionSource.projectSettings) {
            const isValid = await (0, projectMigratorV3_1.checkActiveResourcePlugins)(projectPath);
            if (!isValid) {
                return (0, teamsfx_api_1.err)(new common_2.InvalidProjectError(projectPath));
            }
        }
        if (version.source === versionMetadata_1.VersionSource.unknown) {
            return (0, teamsfx_api_1.err)(new common_2.InvalidProjectError(projectPath));
        }
        return this.innerMigrationV3(inputs);
    }
    innerMigrationV3(inputs) {
        return (0, teamsfx_api_1.ok)(undefined);
    }
    // a project version check
    async projectVersionCheck(inputs) {
        const projectPath = inputs.projectPath || "";
        if ((0, projectSettingsHelper_1.isValidProjectV3)(projectPath) || (0, projectSettingsHelper_1.isValidProjectV2)(projectPath)) {
            const versionInfo = await (0, v3MigrationUtils_1.getProjectVersionFromPath)(projectPath);
            if (!versionInfo.version) {
                return (0, teamsfx_api_1.err)(new common_2.InvalidProjectError(projectPath));
            }
            const trackingId = await (0, v3MigrationUtils_1.getTrackingIdFromPath)(projectPath);
            const isSupport = (0, v3MigrationUtils_1.getVersionState)(versionInfo);
            // if the project is upgradeable, check whether the project is valid and invalid project should not show upgrade option.
            if (isSupport === versionMetadata_1.VersionState.upgradeable) {
                if (!(await (0, projectMigratorV3_1.checkActiveResourcePlugins)(projectPath))) {
                    return (0, teamsfx_api_1.err)(new common_2.InvalidProjectError(projectPath));
                }
            }
            return (0, teamsfx_api_1.ok)({
                currentVersion: versionInfo.version,
                trackingId,
                isSupport,
                versionSource: versionMetadata_1.VersionSource[versionInfo.source],
            });
        }
        else {
            return (0, teamsfx_api_1.err)(new common_2.InvalidProjectError(projectPath));
        }
    }
    // apply the given yaml template to current project.
    async apply(inputs, templatePath, lifecycleName) {
        if (!inputs.projectPath) {
            return (0, teamsfx_api_1.err)(new common_2.InputValidationError("projectPath", "empty", "Core"));
        }
        const projectPath = inputs.projectPath;
        if (!inputs.env) {
            return (0, teamsfx_api_1.err)(new common_2.InputValidationError("env", "empty", "Core"));
        }
        const env = inputs.env;
        const lifecycleName_ = lifecycleName;
        const result = await envUtil_1.envUtil.readEnv(projectPath, env);
        if (result.isErr()) {
            return (0, teamsfx_api_1.err)(result.error);
        }
        const parser = new parser_1.YamlParser();
        const maybeProjectModel = await parser.parse(templatePath);
        if (maybeProjectModel.isErr()) {
            return (0, teamsfx_api_1.err)(maybeProjectModel.error);
        }
        const projectModel = maybeProjectModel.value;
        const driverContext = {
            azureAccountProvider: globalVars_1.TOOLS.tokenProvider.azureAccountProvider,
            m365TokenProvider: globalVars_1.TOOLS.tokenProvider.m365TokenProvider,
            ui: globalVars_1.TOOLS.ui,
            progressBar: undefined,
            logProvider: globalVars_1.TOOLS.logProvider,
            telemetryReporter: globalVars_1.TOOLS.telemetryReporter,
            projectPath: projectPath,
            platform: inputs.platform,
        };
        const lifecycle = projectModel[lifecycleName_];
        if (lifecycle) {
            return this.runLifecycle(lifecycle, driverContext, env);
        }
        else {
            driverContext.logProvider.warning(`No definition found for ${lifecycleName}`);
            return (0, teamsfx_api_1.ok)(undefined);
        }
    }
    async runLifecycle(lifecycle, driverContext, env) {
        const r = await lifecycle.execute(driverContext);
        const runResult = r.result;
        if (runResult.isOk()) {
            driverContext.logProvider.info(`Lifecycle ${lifecycle.name} succeeded`);
            const writeResult = await envUtil_1.envUtil.writeEnv(driverContext.projectPath, env, envUtil_1.envUtil.map2object(runResult.value));
            return writeResult.map(() => undefined);
        }
        else {
            const error = runResult.error;
            if (error.kind === "Failure") {
                driverContext.logProvider.error(`Failed to run ${lifecycle.name} due to ${error.error.name}: ${error.error.message}`);
                return (0, teamsfx_api_1.err)(error.error);
            }
            else {
                try {
                    const failedDriver = error.reason.failedDriver;
                    if (error.reason.kind === "UnresolvedPlaceholders") {
                        const unresolved = error.reason.unresolvedPlaceHolders;
                        driverContext.logProvider.warning(`Unresolved placeholders: ${unresolved.join(",")} for driver ${failedDriver.uses}`);
                        return (0, teamsfx_api_1.ok)(undefined);
                    }
                    else {
                        driverContext.logProvider.error(`Failed to run ${lifecycle.name} due to ${error.reason.error.name}: ${error.reason.error.message}. Failed driver: ${failedDriver.uses}`);
                        return (0, teamsfx_api_1.err)(error.reason.error);
                    }
                }
                finally {
                    await envUtil_1.envUtil.writeEnv(driverContext.projectPath, env, envUtil_1.envUtil.map2object(error.env));
                }
            }
        }
    }
    async preProvisionForVS(inputs) {
        const context = (0, utils_2.createDriverContext)(inputs);
        return coordinator_1.coordinator.preProvisionForVS(context, inputs);
    }
    async preCheckYmlAndEnvForVS(inputs) {
        const context = (0, utils_2.createDriverContext)(inputs);
        const result = await coordinator_1.coordinator.preCheckYmlAndEnvForVS(context, inputs);
        return result;
    }
    async publishInDeveloperPortal(inputs) {
        inputs.stage = teamsfx_api_1.Stage.publishInDeveloperPortal;
        const context = (0, globalVars_1.createContext)();
        return await coordinator_1.coordinator.publishInDeveloperPortal(context, inputs);
    }
    async copilotPluginAddAPI(inputs) {
        const newOperations = inputs[constants_3.QuestionNames.ApiOperation];
        const url = inputs[constants_3.QuestionNames.ApiSpecLocation];
        const manifestPath = inputs[constants_3.QuestionNames.ManifestPath];
        const isPlugin = inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.apiPluginApiSpecOptionId;
        const context = (0, globalVars_1.createContext)();
        // Get API spec file path from manifest
        const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const confirmRes = await context.userInteraction.showMessage("warn", (0, localizeUtils_1.getLocalizedString)("core.addApi.confirm", teamsfx_api_1.AppPackageFolderName), true, (0, localizeUtils_1.getLocalizedString)("core.addApi.continue"));
        if (confirmRes.isErr()) {
            return (0, teamsfx_api_1.err)(confirmRes.error);
        }
        else if (confirmRes.value !== (0, localizeUtils_1.getLocalizedString)("core.addApi.continue")) {
            return (0, teamsfx_api_1.err)(new common_2.UserCancelError());
        }
        // Merge existing operations in manifest.json
        const specParser = new m365_spec_parser_1.SpecParser(url, (0, helper_1.getParserOptions)(isPlugin ? m365_spec_parser_1.ProjectType.Copilot : m365_spec_parser_1.ProjectType.SME));
        try {
            const listResult = await specParser.list();
            const apiResultList = listResult.APIs.filter((value) => value.isValid);
            let existingOperations;
            let outputApiSpecPath;
            if (isPlugin) {
                if (!inputs[constants_3.QuestionNames.DestinationApiSpecFilePath]) {
                    return (0, teamsfx_api_1.err)(new common_2.MissingRequiredInputError(constants_3.QuestionNames.DestinationApiSpecFilePath));
                }
                outputApiSpecPath = inputs[constants_3.QuestionNames.DestinationApiSpecFilePath];
                existingOperations = await (0, helper_1.listPluginExistingOperations)(manifestRes.value, manifestPath, inputs[constants_3.QuestionNames.DestinationApiSpecFilePath]);
            }
            else {
                const existingOperationIds = ManifestUtils_1.manifestUtils.getOperationIds(manifestRes.value);
                existingOperations = apiResultList
                    .filter((operation) => existingOperationIds.includes(operation.operationId))
                    .map((operation) => operation.api);
                const apiSpecificationFile = manifestRes.value.composeExtensions[0].apiSpecificationFile;
                outputApiSpecPath = path.join(path.dirname(manifestPath), apiSpecificationFile);
            }
            const operations = [...existingOperations, ...newOperations];
            const adaptiveCardFolder = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ResponseTemplatesFolderName);
            const authNames = new Set();
            const serverUrls = new Set();
            let authScheme = undefined;
            for (const api of operations) {
                const operation = apiResultList.find((op) => op.api === api);
                if (operation &&
                    operation.auth &&
                    (m365_spec_parser_1.Utils.isBearerTokenAuth(operation.auth.authScheme) ||
                        m365_spec_parser_1.Utils.isOAuthWithAuthCodeFlow(operation.auth.authScheme))) {
                    authNames.add(operation.auth.name);
                    serverUrls.add(operation.server);
                    authScheme = operation.auth.authScheme;
                }
            }
            if (authNames.size > 1) {
                throw new common_2.MultipleAuthError(authNames);
            }
            if (serverUrls.size > 1) {
                throw new common_2.MultipleServerError(serverUrls);
            }
            if (authNames.size === 1 && authScheme) {
                await (0, helper_1.injectAuthAction)(inputs.projectPath, [...authNames][0], authScheme, outputApiSpecPath, false);
            }
            let pluginPath;
            if (isPlugin) {
                const pluginPathRes = await ManifestUtils_1.manifestUtils.getPluginFilePath(manifestRes.value, manifestPath);
                if (pluginPathRes.isErr()) {
                    return (0, teamsfx_api_1.err)(pluginPathRes.error);
                }
                pluginPath = pluginPathRes.value;
            }
            const generateResult = await (0, helper_1.generateFromApiSpec)(specParser, manifestPath, inputs, context, "copilotPluginAddAPI", isPlugin ? m365_spec_parser_1.ProjectType.Copilot : m365_spec_parser_1.ProjectType.SME, {
                destinationApiSpecFilePath: outputApiSpecPath,
                responseTemplateFolder: adaptiveCardFolder,
                pluginManifestFilePath: pluginPath,
            });
            if (generateResult.isErr()) {
                return (0, teamsfx_api_1.err)(generateResult.error);
            }
            if (generateResult.value.warnings && generateResult.value.warnings.length > 0) {
                const warnSummary = await (0, helper_1.generateScaffoldingSummary)(generateResult.value.warnings, manifestRes.value, path.relative(inputs.projectPath, outputApiSpecPath), pluginPath === undefined ? undefined : path.relative(inputs.projectPath, pluginPath), inputs.projectPath);
                if (warnSummary) {
                    context.logProvider.info(warnSummary);
                }
            }
        }
        catch (e) {
            let error;
            if (e instanceof m365_spec_parser_1.SpecParserError) {
                error = (0, helper_1.convertSpecParserErrorToFxError)(e);
            }
            else {
                error = (0, common_2.assembleError)(e);
            }
            return (0, teamsfx_api_1.err)(error);
        }
        const message = (0, localizeUtils_1.getLocalizedString)("core.copilot.addAPI.success", newOperations, inputs.projectPath);
        if (inputs.platform !== teamsfx_api_1.Platform.VS) {
            void context.userInteraction.showMessage("info", message, false);
        }
        return (0, teamsfx_api_1.ok)(message);
    }
    async listPluginApiSpecs(inputs) {
        try {
            const manifestPath = inputs[constants_3.QuestionNames.ManifestPath];
            const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
            if (manifestRes.isErr()) {
                return (0, teamsfx_api_1.err)(manifestRes.error);
            }
            const res = await PluginManifestUtils_1.pluginManifestUtils.getApiSpecFilePathFromTeamsManifest(manifestRes.value, manifestPath);
            if (res.isOk()) {
                return (0, teamsfx_api_1.ok)(res.value);
            }
            else {
                return (0, teamsfx_api_1.err)(res.error);
            }
        }
        catch (error) {
            return (0, teamsfx_api_1.err)(error);
        }
    }
    async copilotPluginListOperations(inputs) {
        const res = await (0, helper_1.listOperations)((0, globalVars_1.createContext)(), inputs.apiSpecUrl, inputs, inputs.includeExistingAPIs, inputs.shouldLogWarning);
        if (res.isErr()) {
            const msg = res.error.map((e) => e.content).join("\n");
            return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError("FxCore", "ListOpenAPISpecOperationsError", msg, msg));
        }
        else {
            return (0, teamsfx_api_1.ok)(res.value);
        }
    }
    /**
     * check project type info
     */
    async checkProjectType(projectPath) {
        var _a;
        const projectTypeRes = await projectTypeChecker_1.projectTypeChecker.checkProjectType(projectPath);
        const props = {};
        telemetry_1.telemetryUtils.fillinProjectTypeProperties(props, projectTypeRes);
        (_a = globalVars_1.TOOLS.telemetryReporter) === null || _a === void 0 ? void 0 : _a.sendTelemetryEvent(telemetry_1.TelemetryEvent.ProjectType, props);
        return (0, teamsfx_api_1.ok)(projectTypeRes);
    }
    /**
     * Add plugin
     */
    async addPlugin(inputs) {
        var _a, _b, _c, _d;
        if (!inputs.projectPath) {
            throw new Error("projectPath is undefined"); // should never happen
        }
        // Call Kiota to select the OpenAPI spec file
        if (inputs.platform === teamsfx_api_1.Platform.VSCode &&
            featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
            inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id &&
            !!!inputs[constants_3.QuestionNames.ApiPluginManifestPath]) {
            return (0, teamsfx_api_1.ok)({
                lastCommand: constants_2.KiotaLastCommands.addPlugin,
                manifestPath: inputs[constants_3.QuestionNames.ManifestPath],
            });
        }
        const context = (0, globalVars_1.createContext)();
        const teamsManifestPath = inputs[constants_3.QuestionNames.ManifestPath];
        const appPackageFolder = path.dirname(teamsManifestPath);
        const isGenerateFromApiSpec = inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id;
        const isKiotaIntegration = featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
            !!inputs[constants_3.QuestionNames.ApiPluginManifestPath];
        // validate the project is valid for adding plugin
        const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(teamsManifestPath);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const teamsManifest = manifestRes.value;
        const declarativeGpt = teamsManifest.copilotExtensions
            ? (_a = teamsManifest.copilotExtensions.declarativeCopilots) === null || _a === void 0 ? void 0 : _a[0]
            : (_c = (_b = teamsManifest.copilotAgents) === null || _b === void 0 ? void 0 : _b.declarativeAgents) === null || _c === void 0 ? void 0 : _c[0];
        if (!(declarativeGpt === null || declarativeGpt === void 0 ? void 0 : declarativeGpt.file)) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.TeamsAppRequiredPropertyMissingError.name, errors_1.AppStudioError.TeamsAppRequiredPropertyMissingError.message("declarativeCopilots", teamsManifestPath)));
        }
        const gptManifestFilePathRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.getManifestPath(teamsManifestPath);
        if (gptManifestFilePathRes.isErr()) {
            return (0, teamsfx_api_1.err)(gptManifestFilePathRes.error);
        }
        const declarativeCopilotManifestPath = gptManifestFilePathRes.value;
        const declarativeCopilotManifesRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.readCopilotGptManifestFile(declarativeCopilotManifestPath);
        if (declarativeCopilotManifesRes.isErr()) {
            return (0, teamsfx_api_1.err)(declarativeCopilotManifesRes.error);
        }
        const declarativeCopilotManifest = declarativeCopilotManifesRes.value;
        let confirmMessage = (0, localizeUtils_1.getLocalizedString)("core.addApi.confirm", path.relative(inputs.projectPath, appPackageFolder));
        // Will be used if generating from API spec
        let specParser = undefined;
        let authName = undefined;
        let authScheme = undefined;
        if (isGenerateFromApiSpec) {
            specParser = new m365_spec_parser_1.SpecParser(inputs[constants_3.QuestionNames.ApiSpecLocation].trim(), (0, helper_1.getParserOptions)(m365_spec_parser_1.ProjectType.Copilot, true));
            const listResult = await specParser.list();
            const authApis = listResult.APIs.filter((value) => value.isValid && !!value.auth);
            if (inputs.platform === teamsfx_api_1.Platform.VSCode &&
                featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
                inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id &&
                !!inputs[constants_3.QuestionNames.ApiPluginManifestPath]) {
                inputs[constants_3.QuestionNames.ApiOperation] = listResult.APIs.filter((value) => value.isValid).map((value) => value.api);
            }
            for (const api of inputs[constants_3.QuestionNames.ApiOperation]) {
                const operation = authApis.find((op) => op.api === api);
                if (operation &&
                    operation.auth &&
                    (m365_spec_parser_1.Utils.isBearerTokenAuth(operation.auth.authScheme) ||
                        m365_spec_parser_1.Utils.isOAuthWithAuthCodeFlow(operation.auth.authScheme))) {
                    authName = operation.auth.name;
                    authScheme = operation.auth.authScheme;
                    break; // Only one auth is supported for one plugin for now.
                }
            }
            if (authName && authScheme) {
                const doesLocalYamlPathExists = await fs_extra_1.default.pathExists(path.join(inputs.projectPath, versionMetadata_1.MetadataV3.localConfigFile));
                confirmMessage = doesLocalYamlPathExists
                    ? (0, localizeUtils_1.getLocalizedString)("core.addApi.confirm.localTeamsYaml", path.relative(inputs.projectPath, appPackageFolder), versionMetadata_1.MetadataV3.localConfigFile, versionMetadata_1.MetadataV3.configFile)
                    : (0, localizeUtils_1.getLocalizedString)("core.addApi.confirm.teamsYaml", path.relative(inputs.projectPath, appPackageFolder), versionMetadata_1.MetadataV3.configFile);
            }
        }
        // confirm
        const confirmRes = await context.userInteraction.showMessage("warn", confirmMessage, true, (0, localizeUtils_1.getLocalizedString)("core.addApi.continue"));
        if (confirmRes.isErr()) {
            return (0, teamsfx_api_1.err)(confirmRes.error);
        }
        else if (confirmRes.value !== (0, localizeUtils_1.getLocalizedString)("core.addApi.continue")) {
            return (0, teamsfx_api_1.err)(new common_2.UserCancelError());
        }
        // find the next available action id
        let actionId = "";
        let suffix = 1;
        actionId = `action_${suffix}`;
        const existingActionIds = (_d = declarativeCopilotManifest.actions) === null || _d === void 0 ? void 0 : _d.map((action) => action.id);
        while (existingActionIds === null || existingActionIds === void 0 ? void 0 : existingActionIds.includes(actionId)) {
            suffix += 1;
            actionId = `action_${suffix}`;
        }
        let destinationPluginManifestPath;
        // generate files
        if (isGenerateFromApiSpec && specParser) {
            destinationPluginManifestPath =
                await CopilotGptManifestUtils_1.copilotGptManifestUtils.getDefaultNextAvailablePluginManifestPath(appPackageFolder, isKiotaIntegration
                    ? path.basename(inputs[constants_3.QuestionNames.ApiPluginManifestPath])
                    : undefined, isKiotaIntegration);
            const destinationApiSpecPath = await PluginManifestUtils_1.pluginManifestUtils.getDefaultNextAvailableApiSpecPath(inputs[constants_3.QuestionNames.ApiSpecLocation].trim(), path.join(appPackageFolder, isKiotaIntegration ? "" : teamsfx_api_1.DefaultApiSpecFolderName), isKiotaIntegration ? path.basename(inputs[constants_3.QuestionNames.ApiSpecLocation]) : undefined, isKiotaIntegration);
            const generateRes = await (0, helper_1.generateFromApiSpec)(specParser, teamsManifestPath, inputs, context, teamsfx_api_1.Stage.addPlugin, m365_spec_parser_1.ProjectType.Copilot, {
                destinationApiSpecFilePath: destinationApiSpecPath,
                pluginManifestFilePath: destinationPluginManifestPath,
            });
            if (generateRes.isErr()) {
                return (0, teamsfx_api_1.err)(generateRes.error);
            }
            const warnings = generateRes.value.warnings;
            if (warnings && warnings.length > 0) {
                const warnSummary = await (0, helper_1.generateScaffoldingSummary)(warnings, manifestRes.value, path.relative(inputs.projectPath, destinationApiSpecPath), path.relative(inputs.projectPath, destinationPluginManifestPath), inputs.projectPath);
                context.logProvider.info(warnSummary + "\n");
            }
            const addActionRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.addAction(declarativeCopilotManifestPath, actionId, (0, utils_1.normalizePath)(path.relative(appPackageFolder, destinationPluginManifestPath), true));
            if (addActionRes.isErr()) {
                return (0, teamsfx_api_1.err)(addActionRes.error);
            }
            // update teamspp.local.yaml and teamsapp.yaml if auth action is needed
            if (authName && authScheme) {
                const authInjectRes = await (0, helper_1.injectAuthAction)(inputs.projectPath, authName, authScheme, destinationApiSpecPath, true);
                if ((authInjectRes === null || authInjectRes === void 0 ? void 0 : authInjectRes.defaultRegistrationIdEnvName) &&
                    (authInjectRes === null || authInjectRes === void 0 ? void 0 : authInjectRes.registrationIdEnvName) &&
                    authInjectRes.defaultRegistrationIdEnvName !== authInjectRes.registrationIdEnvName) {
                    const pluginManifestContent = await fs_extra_1.default.readFile(destinationPluginManifestPath, "utf-8");
                    const updatedPluginManifestContext = pluginManifestContent.replace(authInjectRes.defaultRegistrationIdEnvName, authInjectRes.registrationIdEnvName);
                    await fs_extra_1.default.writeFile(destinationPluginManifestPath, updatedPluginManifestContext);
                }
            }
        }
        else {
            const addPluginRes = await (0, helper_2.addExistingPlugin)(declarativeCopilotManifestPath, inputs[constants_3.QuestionNames.PluginManifestFilePath].trim(), inputs[constants_3.QuestionNames.PluginOpenApiSpecFilePath].trim(), actionId, context, teamsfx_api_1.Stage.addPlugin);
            if (addPluginRes.isErr()) {
                return (0, teamsfx_api_1.err)(addPluginRes.error);
            }
            destinationPluginManifestPath = addPluginRes.value.destinationPluginManifestPath;
            const warningMessage = (0, common_1.outputScaffoldingWarningMessage)(addPluginRes.value.warnings);
            context.logProvider.info(warningMessage);
        }
        if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
            const successMessage = (0, localizeUtils_1.getLocalizedString)("core.addPlugin.success.vsc", actionId);
            const viewPluginManifest = (0, localizeUtils_1.getLocalizedString)("core.addPlugin.success.viewPluginManifest");
            void context.userInteraction
                .showMessage("info", successMessage, false, viewPluginManifest)
                .then((userRes) => {
                var _a, _b;
                if (userRes.isOk() && userRes.value === viewPluginManifest) {
                    context.telemetryReporter.sendTelemetryEvent(telemetry_1.TelemetryEvent.ViewPluginManifestAfterAdded);
                    void ((_b = (_a = globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.ui) === null || _a === void 0 ? void 0 : _a.openFile) === null || _b === void 0 ? void 0 : _b.call(_a, destinationPluginManifestPath));
                }
            });
        }
        else {
            const successMessage = (0, localizeUtils_1.getLocalizedString)("core.addPlugin.success", actionId, destinationPluginManifestPath);
            void context.userInteraction.showMessage("info", successMessage, false);
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
}
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "createProject", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        (0, questionMW_1.QuestionMW)("createProject"),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createProject", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({
            component: "FxCore",
            stage: "createProjectByCustomizedGenerator",
            reset: true,
        }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createProjectByCustomizedGenerator", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "createSampleProject", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        (0, questionMW_1.QuestionMW)("createSampleProject"),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createSampleProject", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "provision", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, envMW_1.EnvLoaderMW)(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "provisionResources", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "uninstall", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, questionMW_1.QuestionMW)("uninstall"),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "uninstall", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "uninstallByManifestId", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "uninstallByManifestId", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "uninstallByEnv", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        (0, envMW_1.EnvLoaderMW)(true, true),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "uninstallByEnv", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "uninstallByTitleId", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "uninstallByTitleId", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "uninstallM365App", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "uninstallM365App", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "uninstallAppRegistration", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "uninstallAppRegistration", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "uninstallBotFrameworRegistration", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "uninstallBotFrameworRegistration", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "deploy", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, envMW_1.EnvLoaderMW)(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "deployArtifacts", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "localDebug", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "localDebug", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "deployAadManifest", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, questionMW_1.QuestionMW)("deployAadManifest"),
        (0, envMW_1.EnvLoaderMW)(true, true),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "deployAadManifest", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "addWebpart", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        (0, questionMW_1.QuestionMW)("addWebpart"),
        projectMigratorV3_1.ProjectMigratorMWV3,
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "addWebpart", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "publish", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, envMW_1.EnvLoaderMW)(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "publishApplication", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "executeUserTask", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, envMW_1.EnvLoaderMW)(false),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "executeUserTask", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "buildAadManifest", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, envMW_1.EnvLoaderMW)(false),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "buildAadManifest", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "deployTeamsManifest", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, questionMW_1.QuestionMW)("selectTeamsAppManifest"),
        (0, envMW_1.EnvLoaderMW)(true),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "deployTeamsManifest", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "updateTeamsAppCLIV3", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "updateTeamsAppCLIV3", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "validateTeamsAppCLIV3", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "validateTeamsAppCLIV3", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "packageTeamsAppCLIV3", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "packageTeamsAppCLIV3", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "publishTeamsAppCLIV3", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "publishTeamsAppCLIV3", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "validateApplication", reset: true }),
        (0, questionMW_1.QuestionMW)("validateTeamsApp"),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "validateApplication", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "validateManifest", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        (0, envMW_1.EnvLoaderMW)(true),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "validateManifest", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "validateAppPackage", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "validateAppPackage", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "validateWithTestCases", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "validateWithTestCases", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "syncManifest", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        (0, questionMW_1.QuestionMW)("syncManifest"),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "syncManifest", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "createAppPackage", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        (0, questionMW_1.QuestionMW)("selectTeamsAppManifest"),
        (0, envMW_1.EnvLoaderMW)(true),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createAppPackage", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "preview", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        (0, questionMW_1.QuestionMW)("previewWithTeamsAppManifest"),
        (0, envMW_1.EnvLoaderMW)(false),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "previewWithManifest", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "getDotEnvs", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getDotEnvs", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "isEnvFile", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "isEnvFile", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "getProjectId", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getProjectId", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "getProjectMetadata", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getProjectMetadata", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "getTeamsAppName", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getTeamsAppName", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "getProjectInfo", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getProjectInfo", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "grantPermission", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, questionMW_1.QuestionMW)("grantPermission"),
        (0, envMW_1.EnvLoaderMW)(false, true),
        concurrentLocker_1.ConcurrentLockerMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "grantPermission", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "checkPermission", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, questionMW_1.QuestionMW)("listCollaborator"),
        (0, envMW_1.EnvLoaderMW)(false, true),
        concurrentLocker_1.ConcurrentLockerMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "checkPermission", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "listCollaborator", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, questionMW_1.QuestionMW)("listCollaborator"),
        (0, envMW_1.EnvLoaderMW)(false, true),
        concurrentLocker_1.ConcurrentLockerMW,
        envMW_1.EnvWriterMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "listCollaborator", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "getSelectedEnv", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        (0, envMW_1.EnvLoaderMW)(false),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "getSelectedEnv", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "createLocalCrypto" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createLocalCrypto", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "encrypt", reset: true }), errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "encrypt", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "decrypt", reset: true }), errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "decrypt", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "createEnv", reset: true }),
        errorHandler_1.ErrorHandlerMW,
        (0, questionMW_1.QuestionMW)("createNewEnv"),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "createEnv", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "phantomMigrationV3", reset: true })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "phantomMigrationV3", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([errorHandler_1.ErrorHandlerMW, projectMigratorV3_1.ProjectMigratorMWV3]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Object)
], FxCore.prototype, "innerMigrationV3", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "projectVersionCheck", reset: true }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "projectVersionCheck", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "preProvisionForVS" }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, envMW_1.EnvLoaderMW)(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "preProvisionForVS", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "preCheckYmlAndEnvForVS" }),
        errorHandler_1.ErrorHandlerMW,
        projectMigratorV3_1.ProjectMigratorMWV3,
        (0, envMW_1.EnvLoaderMW)(false),
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "preCheckYmlAndEnvForVS", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "publishInDeveloperPortal" }),
        errorHandler_1.ErrorHandlerMW,
        concurrentLocker_1.ConcurrentLockerMW,
        contextInjector_1.ContextInjectorMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "publishInDeveloperPortal", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "copilotPluginAddAPI" }),
        errorHandler_1.ErrorHandlerMW,
        (0, questionMW_1.QuestionMW)("copilotPluginAddAPI"),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "copilotPluginAddAPI", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "copilotPluginListApiSpecs" }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "listPluginApiSpecs", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "copilotPluginListOperations" }),
        errorHandler_1.ErrorHandlerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "copilotPluginListOperations", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: "checkProjectType" }), errorHandler_1.ErrorHandlerMW]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "checkProjectType", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ component: "FxCore", stage: teamsfx_api_1.Stage.addPlugin }),
        errorHandler_1.ErrorHandlerMW,
        (0, questionMW_1.QuestionMW)("addPlugin"),
        concurrentLocker_1.ConcurrentLockerMW,
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], FxCore.prototype, "addPlugin", null);
exports.FxCore = FxCore;
//# sourceMappingURL=FxCore.js.map
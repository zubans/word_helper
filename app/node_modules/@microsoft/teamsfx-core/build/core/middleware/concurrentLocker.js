// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLockFolder = exports.ConcurrentLockerMW = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const crypto_1 = tslib_1.__importDefault(require("crypto"));
const fs = tslib_1.__importStar(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const proper_lockfile_1 = require("proper-lockfile");
const globalVars_1 = require("../../common/globalVars");
const projectSettingsHelper_1 = require("../../common/projectSettingsHelper");
const telemetry_1 = require("../../common/telemetry");
const utils_1 = require("../../common/utils");
const common_1 = require("../../error/common");
const callback_1 = require("../callback");
const projectSettingsLoader_1 = require("./projectSettingsLoader");
let doingTask = undefined;
const ConcurrentLockerMW = async (ctx, next) => {
    var _a;
    const inputs = ctx.arguments[ctx.arguments.length - 1];
    if ((0, projectSettingsLoader_1.shouldIgnored)(ctx)) {
        await next();
        return;
    }
    if (!inputs.projectPath) {
        ctx.result = (0, teamsfx_api_1.err)(new common_1.NoProjectOpenedError());
        return;
    }
    if (!(await fs.pathExists(inputs.projectPath))) {
        ctx.result = (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("ConcurrentLockerMW", inputs.projectPath));
        return;
    }
    let configFolder = "";
    if ((0, projectSettingsHelper_1.isValidProjectV3)(inputs.projectPath)) {
        configFolder = path.join(inputs.projectPath);
    }
    else if ((0, projectSettingsHelper_1.isValidProjectV2)(inputs.projectPath)) {
        configFolder = path.join(inputs.projectPath, `.${teamsfx_api_1.ConfigFolderName}`);
    }
    else {
        ctx.result = (0, teamsfx_api_1.err)(new common_1.InvalidProjectError(inputs.projectPath));
        return;
    }
    const lockFileDir = getLockFolder(inputs.projectPath);
    const lockfilePath = path.join(lockFileDir, `${teamsfx_api_1.ConfigFolderName}.lock`);
    await fs.ensureDir(lockFileDir);
    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
    const taskName = `${ctx.method}${ctx.method === "executeUserTask" || ctx.method === "executeUserTaskOld"
        ? ` ${ctx.arguments[0].method}`
        : ""}`;
    let acquired = false;
    let retryNum = 0;
    for (let i = 0; i < 10; ++i) {
        try {
            await (0, proper_lockfile_1.lock)(configFolder, { lockfilePath: lockfilePath });
            acquired = true;
            for (const f of callback_1.CallbackRegistry.get(teamsfx_api_1.CoreCallbackEvent.lock)) {
                await f(taskName);
            }
            try {
                doingTask = taskName;
                if (retryNum > 0) {
                    // failed for some try and finally success
                    (0, telemetry_1.sendTelemetryErrorEvent)(common_1.CoreSource, "concurrent-operation", new common_1.ConcurrentError(common_1.CoreSource), 
                    // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
                    { retry: retryNum + "", acquired: "true", doing: doingTask, todo: taskName });
                }
                await next();
            }
            finally {
                await (0, proper_lockfile_1.unlock)(configFolder, { lockfilePath: lockfilePath });
                for (const f of callback_1.CallbackRegistry.get(teamsfx_api_1.CoreCallbackEvent.unlock)) {
                    await f(taskName);
                }
                doingTask = undefined;
            }
            break;
        }
        catch (e) {
            if (e["code"] === "ELOCKED") {
                await (0, utils_1.waitSeconds)(1);
                ++retryNum;
                continue;
            }
            throw e;
        }
    }
    if (!acquired) {
        const log = `Failed to acquire lock for task ${taskName} on: ${configFolder}`;
        (_a = globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.logProvider) === null || _a === void 0 ? void 0 : _a.error(log);
        // failed for 10 times and finally failed
        (0, telemetry_1.sendTelemetryErrorEvent)(common_1.CoreSource, "concurrent-operation", new common_1.ConcurrentError(common_1.CoreSource), {
            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
            retry: retryNum + "",
            acquired: "false",
            doing: doingTask || "",
            todo: taskName,
        });
        ctx.result = (0, teamsfx_api_1.err)(new common_1.ConcurrentError(common_1.CoreSource));
    }
};
exports.ConcurrentLockerMW = ConcurrentLockerMW;
function getLockFolder(projectPath) {
    return path.join(os.tmpdir(), `${teamsfx_api_1.ProductName}-${crypto_1.default.createHash("sha256").update(projectPath).digest("hex")}`);
}
exports.getLockFolder = getLockFolder;
//# sourceMappingURL=concurrentLocker.js.map
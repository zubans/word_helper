"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverse = exports.collect = exports.questionVisitor = exports.loadOptions = exports.getSingleOption = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const error_1 = require("../error");
const validationUtils_1 = require("./validationUtils");
async function isAutoSkipSelect(q, inputs) {
    let skipSingle = false;
    if (q.type === "singleSelect" || q.type === "multiSelect") {
        if (q.skipSingleOption !== undefined) {
            if (typeof q.skipSingleOption === "function") {
                skipSingle = await q.skipSingleOption(inputs);
            }
            else {
                skipSingle = q.skipSingleOption;
            }
        }
    }
    return skipSingle;
}
function getSingleOption(q, option) {
    if (!option)
        option = q.staticOptions;
    const optionIsString = typeof option[0] === "string";
    let returnResult;
    if (optionIsString)
        returnResult = option[0];
    else {
        if (q.returnObject === true)
            returnResult = option[0];
        else
            returnResult = option[0].id;
    }
    if (q.type === "singleSelect")
        return returnResult;
    else
        return [returnResult];
}
exports.getSingleOption = getSingleOption;
async function getCallFuncValue(inputs, raw) {
    if (raw && typeof raw === "function") {
        return await raw(inputs);
    }
    return raw;
}
async function loadOptions(question, inputs) {
    let options = question.staticOptions;
    if (question.dynamicOptions) {
        options = await question.dynamicOptions(inputs);
    }
    return options;
}
exports.loadOptions = loadOptions;
/**
 * ask question when visiting the question tree
 * @param question
 * @param core
 * @param inputs
 */
const questionVisitor = async function (question, ui, inputs, step, totalSteps) {
    // check and validate preset answer
    if (inputs[question.name] !== undefined) {
        // validate existing answer in inputs object
        const res = await validationUtils_1.validationUtils.validateInputs(question, inputs[question.name], inputs);
        if (res)
            return (0, teamsfx_api_1.err)(new error_1.InputValidationError(question.name, res, "questionVisitor"));
        return (0, teamsfx_api_1.ok)({ type: "skip", result: inputs[question.name] });
    }
    const skipSingle = await isAutoSkipSelect(question, inputs);
    // non-interactive mode
    if (inputs.nonInteractive) {
        // first priority: use single option as value
        if (question.type === "singleSelect" || question.type === "multiSelect") {
            if (skipSingle) {
                const options = await loadOptions(question, inputs);
                if (options.length === 0) {
                    return (0, teamsfx_api_1.err)(new error_1.EmptyOptionError(question.name, "questionVisitor"));
                }
                if (options.length === 1) {
                    const value = getSingleOption(question, options);
                    if (value) {
                        return (0, teamsfx_api_1.ok)({ type: "skip", result: value });
                    }
                }
            }
        }
        // second priority: use default as value
        if (question.default) {
            const value = (await getCallFuncValue(inputs, question.default));
            if (value) {
                const validateRes = await validationUtils_1.validationUtils.validateInputs(question, value, inputs);
                if (validateRes) {
                    return (0, teamsfx_api_1.err)(new error_1.InputValidationError(question.name, validateRes, "questionVisitor"));
                }
                else {
                    return (0, teamsfx_api_1.ok)({ type: "skip", result: value });
                }
            }
        }
        if (question.required)
            return (0, teamsfx_api_1.err)(new error_1.MissingRequiredInputError(question.name, "questionVisitor"));
        else
            return (0, teamsfx_api_1.ok)({ type: "skip", result: undefined });
    }
    // interactive mode
    const title = (await getCallFuncValue(inputs, question.title));
    let defaultValue = undefined;
    if (question.forgetLastValue !== true && question.value)
        defaultValue = question.value;
    else {
        if (question.default) {
            if (typeof question.default === "function") {
                defaultValue = async () => {
                    return await question.default(inputs);
                };
            }
            else {
                defaultValue = question.default;
            }
        }
    }
    const placeholder = (await getCallFuncValue(inputs, question.placeholder));
    const prompt = (await getCallFuncValue(inputs, question.prompt));
    if (question.type === "text") {
        const validationFunc = question.validation
            ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
            : undefined;
        const additionalValidationOnAcceptFunc = question.additionalValidationOnAccept
            ? (0, validationUtils_1.getValidationFunction)(question.additionalValidationOnAccept, inputs)
            : undefined;
        return await ui.inputText({
            name: question.name,
            title: title,
            password: question.password,
            default: defaultValue,
            placeholder: placeholder,
            prompt: prompt,
            validation: validationFunc,
            step: step,
            totalSteps: totalSteps,
            additionalValidationOnAccept: additionalValidationOnAcceptFunc,
        });
    }
    else if (question.type === "singleSelect" || question.type === "multiSelect") {
        let options = undefined;
        if (question.dynamicOptions) {
            options = async () => {
                return question.dynamicOptions(inputs);
            };
        }
        else {
            if (!question.staticOptions || question.staticOptions.length === 0) {
                return (0, teamsfx_api_1.err)(new error_1.EmptyOptionError(question.name, "questionVisitor"));
            }
            if (skipSingle && question.staticOptions.length === 1) {
                const returnResult = getSingleOption(question, question.staticOptions);
                return (0, teamsfx_api_1.ok)({ type: "skip", result: returnResult });
            }
            options = question.staticOptions;
        }
        if (question.type === "singleSelect") {
            const validationFunc = question.validation
                ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
                : undefined;
            return await ui.selectOption({
                name: question.name,
                title: title,
                options: options,
                returnObject: question.returnObject,
                default: defaultValue,
                placeholder: placeholder,
                prompt: prompt,
                step: step,
                totalSteps: totalSteps,
                buttons: question.buttons,
                validation: validationFunc,
                skipSingleOption: skipSingle,
            });
        }
        else {
            const validationFunc = question.validation
                ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
                : undefined;
            return await ui.selectOptions({
                name: question.name,
                title: title,
                options: options,
                returnObject: question.returnObject,
                default: defaultValue,
                placeholder: placeholder,
                prompt: prompt,
                onDidChangeSelection: question.onDidChangeSelection,
                step: step,
                totalSteps: totalSteps,
                validation: validationFunc,
                skipSingleOption: skipSingle,
            });
        }
    }
    else if (question.type === "multiFile") {
        const validationFunc = question.validation
            ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
            : undefined;
        return await ui.selectFiles({
            name: question.name,
            title: title,
            placeholder: placeholder,
            prompt: prompt,
            default: defaultValue,
            step: step,
            totalSteps: totalSteps,
            validation: validationFunc,
        });
    }
    else if (question.type === "singleFile") {
        const validationFunc = question.validation
            ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
            : undefined;
        let defaultFolder;
        if (question.defaultFolder) {
            if (typeof question.defaultFolder === "function") {
                defaultFolder = async () => {
                    return await question.defaultFolder(inputs);
                };
            }
            else {
                defaultFolder = question.defaultFolder;
            }
        }
        return await ui.selectFile({
            name: question.name,
            title: title,
            placeholder: placeholder,
            prompt: prompt,
            default: defaultValue,
            step: step,
            totalSteps: totalSteps,
            validation: validationFunc,
            filters: question.filters,
            innerStep: question.innerStep,
            innerTotalStep: question.innerTotalStep,
            defaultFolder,
        });
    }
    else if (question.type === "folder") {
        const validationFunc = question.validation
            ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
            : undefined;
        return await ui.selectFolder({
            name: question.name,
            title: title,
            placeholder: placeholder,
            prompt: prompt,
            default: defaultValue,
            step: step,
            totalSteps: totalSteps,
            validation: validationFunc,
        });
    }
    else if (question.type === "singleFileOrText" && !!ui.selectFileOrInput) {
        const validationFunc = question.validation
            ? (0, validationUtils_1.getValidationFunction)(question.validation, inputs)
            : undefined;
        const inputValidationFunc = question.inputBoxConfig.validation
            ? (0, validationUtils_1.getValidationFunction)(question.inputBoxConfig.validation, inputs)
            : undefined;
        const innerTitle = (await getCallFuncValue(inputs, question.inputBoxConfig.title));
        const innerPlaceholder = (await getCallFuncValue(inputs, question.inputBoxConfig.placeholder));
        const innerPrompt = (await getCallFuncValue(inputs, question.inputBoxConfig.prompt));
        const res = await ui.selectFileOrInput({
            name: question.name,
            title: title,
            placeholder: placeholder,
            prompt: prompt,
            inputOptionItem: question.inputOptionItem,
            inputBoxConfig: {
                name: question.inputBoxConfig.name,
                title: innerTitle,
                placeholder: innerPlaceholder,
                prompt: innerPrompt,
                validation: inputValidationFunc,
                step: question.inputBoxConfig.step,
            },
            filters: question.filters,
            step: step,
            totalSteps: totalSteps,
            validation: validationFunc,
        });
        return res;
    }
    else if (question.type === "confirm" && ui.confirm) {
        const res = await ui.confirm({
            name: question.name,
            title: title,
            default: defaultValue,
            step: step,
            totalSteps: totalSteps,
        });
        return res;
    }
    return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError("API", "UnsupportedNodeType", `Unsupported question node type:${JSON.stringify(question)}`, `Unsupported question node type:${JSON.stringify(question)}`));
};
exports.questionVisitor = questionVisitor;
/**
 * serialize the tree node into array in DFS order
 */
function collect(node, list, parentMap) {
    list.push(node);
    if (node.children) {
        for (const child of node.children) {
            if (child) {
                parentMap.set(child, node);
                collect(child, list, parentMap);
            }
        }
    }
}
exports.collect = collect;
async function traverse(root, inputs, ui, telemetryReporter, visitor = exports.questionVisitor) {
    // The reason to clone is that we don't want to change the original inputs if user cancel the process
    const clonedInputs = (0, lodash_1.cloneDeep)(inputs);
    // 1. collect all nodes into array
    const parentMap = new Map();
    const nodeList = [];
    collect(root, nodeList, parentMap);
    const visitedNodeSet = new Set();
    const visitedInputNodeArray = [];
    let i = 0;
    for (; i < nodeList.length; ++i) {
        const node = nodeList[i];
        // if parent node is not visited, current node should not be visited
        const parent = parentMap.get(node);
        if (parent) {
            if (!visitedNodeSet.has(parent)) {
                continue;
            }
        }
        // 1. check condition
        if (node.condition) {
            let parentValue = undefined;
            // const parent = parentMap.get(node);
            if (parent) {
                parentValue = findValue(parent, parentMap);
            }
            const validRes = await (0, validationUtils_1.validate)(node.condition, parentValue, clonedInputs);
            if (validRes !== undefined) {
                continue;
            }
        }
        // 2. visit node if not group
        if (node.data.type !== "group") {
            const question = node.data;
            let res;
            try {
                res = await visitor(question, ui, clonedInputs, visitedInputNodeArray.length + 1, undefined);
                sendTelemetryEvent(telemetryReporter, res, question, clonedInputs);
            }
            catch (e) {
                return (0, teamsfx_api_1.err)((0, error_1.assembleError)(e));
            }
            if (res.isErr()) {
                // Cancel or Error
                return (0, teamsfx_api_1.err)(res.error);
            }
            const inputResult = res.value;
            if (inputResult.type === "back") {
                const prevNode = visitedInputNodeArray.pop();
                if (!prevNode) {
                    return (0, teamsfx_api_1.err)(new error_1.UserCancelError());
                }
                for (--i; i >= 0; --i) {
                    const tmpNode = nodeList[i];
                    visitedNodeSet.delete(tmpNode);
                    // clear prevNode data
                    if (tmpNode.data.type !== "group") {
                        delete tmpNode.data.value;
                        delete tmpNode.data.valueType;
                        delete clonedInputs[tmpNode.data.name];
                    }
                    if (tmpNode === prevNode) {
                        break;
                    }
                }
                --i;
                continue;
            }
            else {
                //success or skip: set value
                question.value = inputResult.result;
                question.valueType = inputResult.type;
                clonedInputs[question.name] = question.value;
                visitedNodeSet.add(node);
                if (question.valueType === "success") {
                    visitedInputNodeArray.push(node);
                }
            }
        }
        else {
            visitedNodeSet.add(node);
        }
    }
    (0, lodash_1.assign)(inputs, clonedInputs);
    return (0, teamsfx_api_1.ok)(teamsfx_api_1.Void);
}
exports.traverse = traverse;
function findValue(curr, parentMap) {
    if (curr.data.type !== "group") {
        // need to convert OptionItem value into id for validation
        if (curr.data.type === "singleSelect") {
            const sq = curr.data;
            if (sq.value && typeof sq.value !== "string" && sq.value.id) {
                return sq.value.id;
            }
        }
        else if (curr.data.type === "multiSelect") {
            const mq = curr.data;
            if (mq.value && typeof mq.value[0] !== "string") {
                return mq.value.map((i) => i.id);
            }
        }
        return curr.data.value;
    }
    const parent = parentMap.get(curr);
    if (parent) {
        return findValue(parent, parentMap);
    }
    return undefined;
}
function sendTelemetryEvent(telemetryReporter, qvres, question, inputs) {
    var _a;
    if (qvres.isErr()) {
        telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(teamsfx_api_1.TelemetryEvent.askQuestion, {
            [teamsfx_api_1.TelemetryProperty.answerType]: qvres.error.name,
            [teamsfx_api_1.TelemetryProperty.question]: question.name,
            [teamsfx_api_1.TelemetryProperty.platform]: inputs.platform,
            [teamsfx_api_1.TelemetryProperty.stage]: inputs.stage ? inputs.stage : "",
        });
    }
    else {
        telemetryReporter === null || telemetryReporter === void 0 ? void 0 : telemetryReporter.sendTelemetryEvent(teamsfx_api_1.TelemetryEvent.askQuestion, {
            [teamsfx_api_1.TelemetryProperty.answerType]: qvres.value.type,
            [teamsfx_api_1.TelemetryProperty.question]: question.name,
            [teamsfx_api_1.TelemetryProperty.answer]: question.type == "singleSelect" || question.type == "multiSelect"
                ? (_a = qvres.value.result) === null || _a === void 0 ? void 0 : _a.toString()
                : "",
            [teamsfx_api_1.TelemetryProperty.platform]: inputs.platform,
            [teamsfx_api_1.TelemetryProperty.stage]: inputs.stage ? inputs.stage : "",
        });
    }
}
//# sourceMappingURL=visitor.js.map
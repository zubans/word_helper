"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CoreSource = exports.FileNotSupportError = exports.NpmInstallError = exports.FailedToParseResourceIdError = exports.AbandonedProjectError = exports.IncompatibleProjectError = exports.UpgradeV3CanceledError = exports.VideoFilterAppRemoteNotSupportedError = exports.FailedToLoadManifestId = exports.NotAllowedMigrationError = exports.MigrationError = exports.NoProjectOpenedError = exports.isUserCancelError = exports.assembleError = exports.InternalError = exports.ConcurrentError = exports.NotImplementedError = exports.EmptyOptionError = exports.UserCancelError = exports.AccessGithubError = exports.HttpServerError = exports.HttpClientError = exports.matchDnsError = exports.NetworkError = exports.MissingRequiredFileError = exports.NoEnvFilesError = exports.InputValidationError = exports.MissingRequiredInputError = exports.InstallSoftwareError = exports.UnhandledUserError = exports.UnhandledError = exports.FilePermissionError = exports.WriteFileError = exports.ReadFileError = exports.JSONSyntaxError = exports.InjectOAuthActionFailedError = exports.InjectAPIKeyActionFailedError = exports.MultipleServerError = exports.MultipleAuthError = exports.InvalidProjectError = exports.InvalidActionInputError = exports.MissingEnvironmentVariablesError = exports.FileNotFoundError = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const localizeUtils_1 = require("../common/localizeUtils");
const globalVars_1 = require("../common/globalVars");
const types_1 = require("./types");
const path_1 = tslib_1.__importDefault(require("path"));
const versionMetadata_1 = require("../common/versionMetadata");
class FileNotFoundError extends teamsfx_api_1.UserError {
    constructor(source, filePath, helpLink) {
        const key = "error.common.FileNotFoundError";
        const errorOptions = {
            source: (0, lodash_1.camelCase)(source),
            name: "FileNotFoundError",
            message: (0, localizeUtils_1.getDefaultString)(key, filePath),
            displayMessage: (0, localizeUtils_1.getLocalizedString)(key, filePath),
            helpLink: helpLink,
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.FileNotFoundError = FileNotFoundError;
class MissingEnvironmentVariablesError extends teamsfx_api_1.UserError {
    constructor(source, variableNames, filePath, helpLink) {
        const templateFilePath = filePath || globalVars_1.globalVars.ymlFilePath || "";
        const envFilePath = globalVars_1.globalVars.envFilePath || "";
        const secretEnvFilePath = globalVars_1.globalVars.envFilePath ? `${globalVars_1.globalVars.envFilePath}.user` : "";
        const key = "error.common.MissingEnvironmentVariablesError";
        const errorOptions = {
            source: (0, lodash_1.camelCase)(source),
            name: "MissingEnvironmentVariablesError",
            message: (0, localizeUtils_1.getDefaultString)(key, variableNames, templateFilePath, envFilePath, secretEnvFilePath),
            displayMessage: (0, localizeUtils_1.getLocalizedString)(key, variableNames, templateFilePath, envFilePath, secretEnvFilePath),
            helpLink: helpLink || "https://aka.ms/teamsfx-v5.0-guide#environments",
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.MissingEnvironmentVariablesError = MissingEnvironmentVariablesError;
class InvalidActionInputError extends teamsfx_api_1.UserError {
    constructor(actionName, parameters, helpLink) {
        const key = "error.yaml.InvalidActionInputError";
        const errorOptions = {
            source: (0, lodash_1.camelCase)(actionName),
            name: "InvalidActionInputError",
            message: (0, localizeUtils_1.getDefaultString)(key, actionName, parameters.join(","), globalVars_1.globalVars.ymlFilePath),
            displayMessage: (0, localizeUtils_1.getLocalizedString)(key, actionName, parameters.join(","), globalVars_1.globalVars.ymlFilePath),
            helpLink: helpLink || "https://aka.ms/teamsfx-actions",
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.InvalidActionInputError = InvalidActionInputError;
class InvalidProjectError extends teamsfx_api_1.UserError {
    constructor(projectPath) {
        const ymlFilePath = path_1.default.join(projectPath, versionMetadata_1.MetadataV3.configFile);
        const localYmlPath = path_1.default.join(projectPath, versionMetadata_1.MetadataV3.localConfigFile);
        super({
            message: (0, localizeUtils_1.getDefaultString)("error.common.InvalidProjectError"),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("error.common.InvalidProjectError.display", `'${ymlFilePath}' or '${localYmlPath}'`),
            source: "coordinator",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.InvalidProjectError = InvalidProjectError;
class MultipleAuthError extends teamsfx_api_1.UserError {
    constructor(authNames) {
        super({
            message: (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.apiSpec.operation.multipleAuth", Array.from(authNames).join(", ")),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.multipleAuth", Array.from(authNames).join(", ")),
            source: "coordinator",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.MultipleAuthError = MultipleAuthError;
class MultipleServerError extends teamsfx_api_1.UserError {
    constructor(serverUrls) {
        super({
            message: (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.apiSpec.operation.multipleServer", Array.from(serverUrls).join(", ")),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.multipleServer", Array.from(serverUrls).join(", ")),
            source: "coordinator",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.MultipleServerError = MultipleServerError;
class InjectAPIKeyActionFailedError extends teamsfx_api_1.UserError {
    constructor() {
        super({
            message: (0, localizeUtils_1.getDefaultString)("core.copilot.addAPI.InjectAPIKeyActionFailed"),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("core.copilot.addAPI.InjectAPIKeyActionFailed"),
            source: "coordinator",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.InjectAPIKeyActionFailedError = InjectAPIKeyActionFailedError;
class InjectOAuthActionFailedError extends teamsfx_api_1.UserError {
    constructor() {
        super({
            message: (0, localizeUtils_1.getDefaultString)("core.copilot.addAPI.InjectOAuthActionFailed"),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("core.copilot.addAPI.InjectOAuthActionFailed"),
            source: "coordinator",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.InjectOAuthActionFailedError = InjectOAuthActionFailedError;
class JSONSyntaxError extends teamsfx_api_1.UserError {
    constructor(filePathOrContent, error, source) {
        super({
            message: (0, localizeUtils_1.getDefaultString)("error.common.JSONSyntaxError", filePathOrContent, error.message),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("error.common.JSONSyntaxError", filePathOrContent, error.message),
            source: source || "coordinator",
            error: error,
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.JSONSyntaxError = JSONSyntaxError;
class ReadFileError extends teamsfx_api_1.SystemError {
    constructor(e, source) {
        super({
            source: source || "unknown",
            message: e.message || (0, localizeUtils_1.getDefaultString)("error.common.ReadFileError", e.message),
            displayMessage: e.message || (0, localizeUtils_1.getLocalizedString)("error.common.ReadFileError", e.message),
            categories: [types_1.ErrorCategory.Internal],
            error: e,
        });
    }
}
exports.ReadFileError = ReadFileError;
class WriteFileError extends teamsfx_api_1.SystemError {
    constructor(e, source) {
        super({
            source: source || "unknown",
            message: e.message || (0, localizeUtils_1.getDefaultString)("error.common.WriteFileError", e.message),
            displayMessage: e.message || (0, localizeUtils_1.getLocalizedString)("error.common.WriteFileError", e.message),
            categories: [types_1.ErrorCategory.Internal],
            error: e,
        });
    }
}
exports.WriteFileError = WriteFileError;
class FilePermissionError extends teamsfx_api_1.UserError {
    constructor(e, source) {
        const msg = (0, localizeUtils_1.getDefaultString)("error.common.FilePermissionError", e.message);
        super({
            source: source || "unknown",
            message: msg,
            displayMessage: msg,
            error: e,
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.FilePermissionError = FilePermissionError;
class UnhandledError extends teamsfx_api_1.SystemError {
    constructor(e, source) {
        const errJson = JSON.stringify(e, Object.getOwnPropertyNames(e));
        const option = {
            source: (0, lodash_1.camelCase)(source) || "unknown",
            error: e,
            message: (0, localizeUtils_1.getDefaultString)("error.common.UnhandledError", source, errJson),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("error.common.UnhandledError", source, e.message || errJson),
            categories: [types_1.ErrorCategory.Unhandled],
        };
        super(option);
    }
}
exports.UnhandledError = UnhandledError;
class UnhandledUserError extends teamsfx_api_1.UserError {
    constructor(e, source, helpLink) {
        source = source || "unknown";
        super({
            source: (0, lodash_1.camelCase)(source),
            message: (0, localizeUtils_1.getDefaultString)("error.common.UnhandledError", source, JSON.stringify(e, Object.getOwnPropertyNames(e))),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("error.common.UnhandledError", source, e.message || JSON.stringify(e, Object.getOwnPropertyNames(e))),
            helpLink: helpLink,
            error: e,
            categories: [types_1.ErrorCategory.Unhandled],
        });
    }
}
exports.UnhandledUserError = UnhandledUserError;
class InstallSoftwareError extends teamsfx_api_1.UserError {
    constructor(source, nameAndVersion, helpLink) {
        super({
            source: (0, lodash_1.camelCase)(source || "common"),
            message: (0, localizeUtils_1.getDefaultString)("error.common.InstallSoftwareError", nameAndVersion),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("error.common.InstallSoftwareError", nameAndVersion),
            categories: [types_1.ErrorCategory.External],
        });
        if (helpLink)
            this.helpLink = helpLink;
    }
}
exports.InstallSoftwareError = InstallSoftwareError;
class MissingRequiredInputError extends teamsfx_api_1.UserError {
    constructor(name, source) {
        super({
            source: source || "coordinator",
            message: (0, localizeUtils_1.getDefaultString)("error.common.MissingRequiredInputError", name),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("error.common.MissingRequiredInputError", name),
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.MissingRequiredInputError = MissingRequiredInputError;
class InputValidationError extends teamsfx_api_1.UserError {
    constructor(name, reason, source) {
        super({
            source: source || "coordinator",
            message: (0, localizeUtils_1.getDefaultString)("error.common.InputValidationError", name, reason),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("error.common.InputValidationError", name, reason),
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.InputValidationError = InputValidationError;
class NoEnvFilesError extends teamsfx_api_1.UserError {
    constructor(source) {
        const key = "error.common.NoEnvFilesError";
        const errorOptions = {
            source: (0, lodash_1.camelCase)(source),
            name: "NoEnvFilesError",
            message: (0, localizeUtils_1.getDefaultString)(key),
            displayMessage: (0, localizeUtils_1.getLocalizedString)(key),
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.NoEnvFilesError = NoEnvFilesError;
class MissingRequiredFileError extends teamsfx_api_1.UserError {
    constructor(source, task, file) {
        const key = "error.common.MissingRequiredFileError";
        const errorOptions = {
            source: (0, lodash_1.camelCase)(source),
            name: "MissingRequiredFileError",
            message: (0, localizeUtils_1.getDefaultString)(key, task, file),
            displayMessage: (0, localizeUtils_1.getLocalizedString)(key, task, file),
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.MissingRequiredFileError = MissingRequiredFileError;
class NetworkError extends teamsfx_api_1.UserError {
    constructor(source, reason) {
        const key = "error.common.NetworkError";
        const errorOptions = {
            source: (0, lodash_1.camelCase)(source),
            name: "NetworkError",
            message: (0, localizeUtils_1.getDefaultString)(key, reason),
            displayMessage: (0, localizeUtils_1.getLocalizedString)(key, reason),
            categories: [types_1.ErrorCategory.Internal],
        };
        super(errorOptions);
    }
}
exports.NetworkError = NetworkError;
function matchDnsError(message) {
    if (!message)
        return undefined;
    const domainPattern = /(?:getaddrinfo\s(?:EAI_AGAIN)\s)([^\s,]+)/;
    // Use the regular expression to extract the domain from the error message
    const match = message.match(domainPattern);
    let res;
    // Check if a match is found
    if (match && match.length > 1) {
        const domain = match[1];
        res = (0, localizeUtils_1.getLocalizedString)("error.common.NetworkError.EAI_AGAIN", domain);
    }
    return res;
}
exports.matchDnsError = matchDnsError;
class HttpClientError extends teamsfx_api_1.UserError {
    constructor(error, actionName, responseBody, helpLink) {
        const messageKey = "error.common.HttpClientError";
        super({
            source: (0, lodash_1.camelCase)(actionName),
            name: "HttpClientError",
            message: (0, localizeUtils_1.getDefaultString)(messageKey, actionName, responseBody),
            displayMessage: (0, localizeUtils_1.getLocalizedString)(messageKey, actionName, responseBody),
            helpLink: helpLink,
            error: error,
            categories: [types_1.ErrorCategory.External],
        });
    }
}
exports.HttpClientError = HttpClientError;
class HttpServerError extends teamsfx_api_1.SystemError {
    constructor(error, actionName, responseBody) {
        const messageKey = "error.common.HttpServerError";
        super({
            source: (0, lodash_1.camelCase)(actionName),
            name: "HttpServerError",
            message: (0, localizeUtils_1.getDefaultString)(messageKey, actionName, responseBody),
            displayMessage: (0, localizeUtils_1.getLocalizedString)(messageKey, actionName, responseBody),
            error: error,
            categories: [types_1.ErrorCategory.External],
        });
    }
}
exports.HttpServerError = HttpServerError;
class AccessGithubError extends teamsfx_api_1.UserError {
    constructor(url, source, error) {
        const messageKey = "error.common.AccessGithubError";
        super({
            source: source,
            name: "AccessGithubError",
            message: (0, localizeUtils_1.getDefaultString)(messageKey, url, error.message || JSON.stringify(error, Object.getOwnPropertyNames(error))),
            displayMessage: (0, localizeUtils_1.getLocalizedString)(messageKey, url, error.message),
            error: error,
            categories: [types_1.ErrorCategory.External],
        });
    }
}
exports.AccessGithubError = AccessGithubError;
class UserCancelError extends teamsfx_api_1.UserError {
    constructor(actionName) {
        super({
            source: actionName ? (0, lodash_1.camelCase)(actionName) : "ui",
            name: "UserCancel",
            message: "User canceled",
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.UserCancelError = UserCancelError;
class EmptyOptionError extends teamsfx_api_1.SystemError {
    constructor(name, source) {
        super({
            source: source ? (0, lodash_1.camelCase)(source) : "UI",
            message: `Select option is empty list for question name: ${name}`,
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.EmptyOptionError = EmptyOptionError;
class NotImplementedError extends teamsfx_api_1.SystemError {
    constructor(source, method) {
        super({
            source: source,
            message: `Method not implemented:${method}`,
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.NotImplementedError = NotImplementedError;
class ConcurrentError extends teamsfx_api_1.UserError {
    constructor(source) {
        super({
            source: source,
            message: (0, localizeUtils_1.getLocalizedString)("error.common.ConcurrentError"),
            categories: [types_1.ErrorCategory.Internal],
        });
    }
}
exports.ConcurrentError = ConcurrentError;
class InternalError extends teamsfx_api_1.UserError {
    constructor(error, source) {
        super({
            source: source,
            error: error,
            categories: ["internal", error.code],
        });
    }
}
exports.InternalError = InternalError;
function assembleError(e, source) {
    if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError)
        return e;
    if (!source)
        source = "unknown";
    source = (0, lodash_1.camelCase)(source);
    const msg = matchDnsError(e.message);
    if (msg) {
        return new NetworkError(source, msg);
    }
    const type = typeof e;
    if (type === "string") {
        return new UnhandledError(new Error(e), source);
    }
    else {
        const code = e.code;
        if (code && typeof code === "string" && (errnoCodes[code] || code.startsWith("ERR_"))) {
            // convert to internal error
            return new InternalError(e, source);
        }
        return new UnhandledError(e, source);
    }
}
exports.assembleError = assembleError;
const errnoCodes = {
    E2BIG: "Argument list too long",
    EACCES: "Permission denied",
    EADDRINUSE: "Address already in use",
    EADDRNOTAVAIL: "Address not available",
    EAFNOSUPPORT: "Address family not supported",
    EAGAIN: "Resource temporarily unavailable",
    EALREADY: "Operation already in progress",
    EBADF: "Bad file descriptor",
    EBADMSG: "Bad message",
    EBUSY: "Device or resource busy",
    ECANCELED: "Operation canceled",
    ECHILD: "No child processes",
    ECONNABORTED: "Connection aborted",
    ECONNREFUSED: "Connection refused",
    ECONNRESET: "Connection reset by peer",
    EDEADLK: "Resource deadlock would occur",
    EDESTADDRREQ: "Destination address required",
    EDOM: "Mathematics argument out of domain of function",
    EDQUOT: "Disk quota exceeded",
    EEXIST: "File exists",
    EFAULT: "Bad address",
    EFBIG: "File too large",
    EHOSTUNREACH: "Host is unreachable",
    EIDRM: "Identifier removed",
    EILSEQ: "Illegal byte sequence",
    EINPROGRESS: "Operation in progress",
    EINTR: "Interrupted system call",
    EINVAL: "Invalid argument",
    EIO: "I/O error",
    EISCONN: "Socket is already connected",
    EISDIR: "Is a directory",
    ELOOP: "Too many symbolic links encountered",
    EMFILE: "Too many open files",
    EMLINK: "Too many links",
    EMSGSIZE: "Message too long",
    EMULTIHOP: "Multihop attempted",
    ENAMETOOLONG: "File name too long",
    ENETDOWN: "Network is down",
    ENETRESET: "Network dropped connection because of reset",
    ENETUNREACH: "Network is unreachable",
    ENFILE: "Too many open files in system",
    ENOBUFS: "No buffer space available",
    ENODATA: "No message is available on the STREAM head read queue",
    ENODEV: "No such device",
    ENOENT: "No such file or directory",
    ENOEXEC: "Exec format error",
    ENOLCK: "No locks available",
    ENOLINK: "Link has been severed",
    ENOMEM: "Out of memory",
    ENOMSG: "No message of the desired type",
    ENOPROTOOPT: "Protocol not available",
    ENOSPC: "No space left on device",
    ENOSR: "No STREAM resources",
    ENOSTR: "Not a STREAM",
    ENOSYS: "Function not implemented",
    ENOTCONN: "Socket is not connected",
    ENOTDIR: "Not a directory",
    ENOTEMPTY: "Directory not empty",
    ENOTSOCK: "Socket operation on non-socket",
    ENOTSUP: "Operation not supported",
    ENOTTY: "Inappropriate ioctl for device",
    ENXIO: "No such device or address",
    EOPNOTSUPP: "Operation not supported on socket",
    EOVERFLOW: "Value too large to be stored in data type",
    EPERM: "Operation not permitted",
    EPIPE: "Broken pipe",
    EPROTO: "Protocol error",
    EPROTONOSUPPORT: "Protocol not supported",
    EPROTOTYPE: "Protocol wrong type for socket",
    ERANGE: "Result too large",
    EROFS: "Read-only file system",
    ESPIPE: "Invalid seek",
    ESRCH: "No such process",
    ESTALE: "Stale file handle",
    ETIME: "Timer expired",
    ETIMEDOUT: "Connection timed out",
    ETXTBSY: "Text file busy",
    EWOULDBLOCK: "Operation would block",
    EXDEV: "Cross-device link",
};
function isUserCancelError(error) {
    const errorName = "name" in error ? error["name"] : "";
    return (errorName === "User Cancel" ||
        errorName === "CancelProvision" ||
        errorName === "UserCancel" ||
        errorName === "UserCancelError");
}
exports.isUserCancelError = isUserCancelError;
class NoProjectOpenedError extends teamsfx_api_1.UserError {
    constructor() {
        super({
            message: (0, localizeUtils_1.getDefaultString)("error.NoProjectOpenedError"),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("error.NoProjectOpenedError"),
            source: "Core",
        });
    }
}
exports.NoProjectOpenedError = NoProjectOpenedError;
class MigrationError extends teamsfx_api_1.UserError {
    constructor(e, name, helpLink) {
        super({
            name: name,
            source: "Upgrade",
            error: e,
            // the link show to user will be helpLink+ # + source + name
            helpLink: helpLink,
        });
    }
}
exports.MigrationError = MigrationError;
class NotAllowedMigrationError extends teamsfx_api_1.UserError {
    constructor() {
        super({
            source: "Core",
            name: NotAllowedMigrationError.name,
            message: (0, localizeUtils_1.getLocalizedString)("core.migrationV3.notAllowedMigration"),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("core.migrationV3.notAllowedMigration"),
        });
    }
}
exports.NotAllowedMigrationError = NotAllowedMigrationError;
class FailedToLoadManifestId extends teamsfx_api_1.UserError {
    constructor(manifestPath) {
        super({
            source: "Core",
            name: FailedToLoadManifestId.name,
            message: (0, localizeUtils_1.getDefaultString)("error.core.failedToLoadManifestId", manifestPath),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("error.core.failedToLoadManifestId", manifestPath),
        });
    }
}
exports.FailedToLoadManifestId = FailedToLoadManifestId;
class VideoFilterAppRemoteNotSupportedError extends teamsfx_api_1.UserError {
    constructor() {
        super({
            source: "Core",
            name: VideoFilterAppRemoteNotSupportedError.name,
            message: (0, localizeUtils_1.getLocalizedString)("error.VideoFilterAppNotRemoteSupported"),
            displayMessage: (0, localizeUtils_1.getLocalizedString)("error.VideoFilterAppNotRemoteSupported"),
        });
    }
}
exports.VideoFilterAppRemoteNotSupportedError = VideoFilterAppRemoteNotSupportedError;
class UpgradeV3CanceledError extends teamsfx_api_1.UserError {
    constructor() {
        super("Core", "UserCancel", // @see tools.isUserCancelError()
        (0, localizeUtils_1.getDefaultString)("error.UpgradeV3CanceledError"), (0, localizeUtils_1.getLocalizedString)("error.UpgradeV3CanceledError"));
    }
}
exports.UpgradeV3CanceledError = UpgradeV3CanceledError;
class IncompatibleProjectError extends teamsfx_api_1.UserError {
    constructor(messageKey) {
        super("Core", "IncompatibleProject", (0, localizeUtils_1.getDefaultString)(messageKey), (0, localizeUtils_1.getLocalizedString)(messageKey));
    }
}
exports.IncompatibleProjectError = IncompatibleProjectError;
class AbandonedProjectError extends teamsfx_api_1.UserError {
    constructor() {
        super("Core", "AbandonedProject", (0, localizeUtils_1.getDefaultString)("core.migrationV3.abandonedProject"), (0, localizeUtils_1.getLocalizedString)("core.migrationV3.abandonedProject"));
    }
}
exports.AbandonedProjectError = AbandonedProjectError;
class FailedToParseResourceIdError extends teamsfx_api_1.UserError {
    constructor(name, resourceId) {
        super("Core", "FailedToParseResourceIdError", (0, localizeUtils_1.getDefaultString)("error.FailedToParseResourceIdError", name, resourceId), (0, localizeUtils_1.getLocalizedString)("error.FailedToParseResourceIdError", name, resourceId));
    }
}
exports.FailedToParseResourceIdError = FailedToParseResourceIdError;
class NpmInstallError extends teamsfx_api_1.SystemError {
    constructor(e, source) {
        super({
            source: source || "Core",
            error: e,
            message: e.message,
        });
    }
}
exports.NpmInstallError = NpmInstallError;
class FileNotSupportError extends teamsfx_api_1.UserError {
    constructor(source, validFormat) {
        super("Core", "FailedToParseResourceIdError", (0, localizeUtils_1.getDefaultString)("error.UnsupportedFileFormat", validFormat), (0, localizeUtils_1.getLocalizedString)("error.UnsupportedFileFormat", validFormat));
    }
}
exports.FileNotSupportError = FileNotSupportError;
exports.CoreSource = "Core";
//# sourceMappingURL=common.js.map
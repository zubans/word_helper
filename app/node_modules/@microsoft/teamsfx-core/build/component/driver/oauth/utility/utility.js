"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSecret = exports.getandValidateOauthInfoFromSpec = void 0;
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const common_1 = require("../../../utils/common");
const lodash_1 = require("lodash");
const constants_1 = require("./constants");
const oauthDomainInvalid_1 = require("../error/oauthDomainInvalid");
const oauthFailedToGetDomain_1 = require("../error/oauthFailedToGetDomain");
const oauthAuthInfoInvalid_1 = require("../error/oauthAuthInfoInvalid");
const oauthAuthMissingInSpec_1 = require("../error/oauthAuthMissingInSpec");
async function getandValidateOauthInfoFromSpec(args, context, actionName) {
    const absolutePath = (0, common_1.getAbsolutePath)(args.apiSpecPath, context.projectPath);
    const parser = new m365_spec_parser_1.SpecParser(absolutePath, {
        allowAPIKeyAuth: false,
        allowBearerTokenAuth: true,
        allowMultipleParameters: true,
        allowOauth2: true,
        projectType: m365_spec_parser_1.ProjectType.Copilot,
        allowMissingId: true,
        allowSwagger: true,
        allowMethods: ["get", "post", "put", "delete", "patch", "head", "connect", "options", "trace"],
    });
    const listResult = await parser.list();
    const operations = listResult.APIs.filter((value) => {
        const auth = value.auth;
        return auth && auth.authScheme.type === "oauth2" && auth.name === args.name;
    });
    if (operations.length === 0) {
        throw new oauthAuthMissingInSpec_1.OauthAuthMissingInSpec(actionName, args.name);
    }
    const domains = operations
        .map((value) => {
        return value.server;
    })
        .filter((value, index, self) => {
        return self.indexOf(value) === index;
    });
    validateDomain(domains, actionName);
    // Need to separate the logic for different flows
    const flow = "flow" in args ? args.flow : "authorizationCode";
    const authInfoArray = operations
        .map((value) => {
        var _a;
        let authInfo;
        switch (flow) {
            case "authorizationCode":
            default:
                authInfo = ((_a = value.auth) === null || _a === void 0 ? void 0 : _a.authScheme).flows
                    .authorizationCode;
        }
        return {
            authorizationUrl: authInfo.authorizationUrl,
            tokenUrl: authInfo.tokenUrl,
            refreshUrl: authInfo.refreshUrl,
            scopes: Object.keys(authInfo.scopes),
        };
    })
        .reduce((accumulator, currentValue) => {
        if (!accumulator.find((item) => (0, lodash_1.isEqual)(item, currentValue))) {
            accumulator.push(currentValue);
        }
        return accumulator;
    }, []);
    if (authInfoArray.length !== 1) {
        throw new oauthAuthInfoInvalid_1.OauthAuthInfoInvalid(actionName);
    }
    const authInfo = authInfoArray[0];
    return {
        domain: domains,
        authorizationEndpoint: authInfo.authorizationUrl,
        tokenExchangeEndpoint: authInfo.tokenUrl,
        tokenRefreshEndpoint: authInfo.refreshUrl,
        scopes: authInfo.scopes,
    };
}
exports.getandValidateOauthInfoFromSpec = getandValidateOauthInfoFromSpec;
function validateSecret(clientSecret) {
    if (typeof clientSecret !== "string") {
        return false;
    }
    if (clientSecret.length > constants_1.maxSecretLength || clientSecret.length < constants_1.minSecretLength) {
        return false;
    }
    return true;
}
exports.validateSecret = validateSecret;
function validateDomain(domain, actionName) {
    if (domain.length > constants_1.maxDomainPerOauth) {
        throw new oauthDomainInvalid_1.OauthDomainInvalidError(actionName);
    }
    if (domain.length === 0 || domain.includes("")) {
        throw new oauthFailedToGetDomain_1.OauthFailedToGetDomainError(actionName);
    }
}
//# sourceMappingURL=utility.js.map
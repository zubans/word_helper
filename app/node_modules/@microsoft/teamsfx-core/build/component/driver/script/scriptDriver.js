"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.capitalizeFirstLetter = exports.parseSetOutputCommand = exports.convertScriptErrorToFxError = exports.bufferToString = exports.getStderrHandler = exports.executeCommand = exports.scriptDriver = exports.ScriptDriver = exports.defaultShell = void 0;
const tslib_1 = require("tslib");
/**
 * @author huajiezhang <huajiezhang@microsoft.com>
 */
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const child_process_1 = tslib_1.__importDefault(require("child_process"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const iconv_lite_1 = tslib_1.__importDefault(require("iconv-lite"));
const os_1 = tslib_1.__importDefault(require("os"));
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const script_1 = require("../../../error/script");
const commonConstant_1 = require("../../constant/commonConstant");
const charsetUtils_1 = require("../../utils/charsetUtils");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const stringUtils_1 = require("../../../common/stringUtils");
const ACTION_NAME = "script";
/**
 * Get the default shell for the current platform:
 * - If `SHELL` environment variable is set, return its value. otherwise:
 * - On macOS, return `/bin/zsh` if it exists, otherwise return `/bin/bash`.
 * - On Windows, return the value of the `ComSpec` environment variable if it exists, otherwise return `cmd.exe`.
 * - On Linux, return `/bin/sh`.
 */
async function defaultShell() {
    if (process.env.SHELL) {
        return process.env.SHELL;
    }
    if (process.platform === "darwin") {
        if (await fs_extra_1.default.pathExists("/bin/zsh"))
            return "/bin/zsh";
        else if (await fs_extra_1.default.pathExists("/bin/bash"))
            return "/bin/bash";
        return undefined;
    }
    if (process.platform === "win32") {
        return process.env.ComSpec || "cmd.exe";
    }
    if (await fs_extra_1.default.pathExists("/bin/sh")) {
        return "/bin/sh";
    }
    return undefined;
}
exports.defaultShell = defaultShell;
let ScriptDriver = class ScriptDriver {
    async _run(typedArgs, context) {
        var _a;
        await ((_a = context.progressBar) === null || _a === void 0 ? void 0 : _a.next("Running script"));
        const res = await executeCommand(typedArgs.run, context.projectPath, context.logProvider, context.ui, typedArgs.workingDirectory, undefined, typedArgs.shell, typedArgs.timeout, typedArgs.redirectTo);
        if (res.isErr())
            return (0, teamsfx_api_1.err)(res.error);
        const outputs = res.value[1];
        const kvArray = Object.keys(outputs).map((k) => [k, outputs[k]]);
        return (0, teamsfx_api_1.ok)(new Map(kvArray));
    }
    async execute(args, ctx) {
        const typedArgs = args;
        const res = await this._run(typedArgs, ctx);
        const summaries = res.isOk() ? [`Successfully executed command`] : [];
        return { result: res, summaries: summaries };
    }
};
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(ACTION_NAME, commonConstant_1.TelemetryConstant.SCRIPT_COMPONENT)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], ScriptDriver.prototype, "execute", null);
ScriptDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(ACTION_NAME)
], ScriptDriver);
exports.ScriptDriver = ScriptDriver;
exports.scriptDriver = new ScriptDriver();
async function executeCommand(command, projectPath, logProvider, ui, workingDirectory, env, shell, timeout, redirectTo) {
    let systemEncoding = await (0, charsetUtils_1.getSystemEncoding)(command);
    if (command.startsWith("dotnet ")) {
        systemEncoding = "utf-8";
    }
    const dshell = await defaultShell();
    return new Promise((resolve) => {
        var _a, _b;
        const finalShell = shell || dshell;
        const finalCmd = command;
        const platform = os_1.default.platform();
        let workingDir = workingDirectory || ".";
        workingDir = path.isAbsolute(workingDir) ? workingDir : path.join(projectPath, workingDir);
        if (platform === "win32") {
            workingDir = capitalizeFirstLetter(path.resolve(workingDir !== null && workingDir !== void 0 ? workingDir : ""));
        }
        let appendFile = undefined;
        if (redirectTo) {
            appendFile = path.isAbsolute(redirectTo) ? redirectTo : path.join(projectPath, redirectTo);
        }
        logProvider.verbose(`Start to run command: "${(0, stringUtils_1.maskSecret)(finalCmd, {
            replace: "***",
        })}" with args: ${JSON.stringify({
            shell: finalShell,
            cwd: workingDir,
            encoding: systemEncoding,
            env: Object.assign(Object.assign({}, process.env), env),
            timeout: timeout,
        })}.`);
        const allOutputStrings = [];
        const stderrStrings = [];
        process.env.VSLANG = undefined; // Workaroud to disable VS environment variable to void charset encoding issue for non-English characters
        const cp = child_process_1.default.exec(finalCmd, {
            shell: finalShell,
            cwd: workingDir,
            encoding: "buffer",
            env: Object.assign(Object.assign({}, process.env), env),
            timeout: timeout,
        }, (error) => {
            if (error) {
                error.message = stderrStrings.join("").trim() || error.message;
                resolve((0, teamsfx_api_1.err)(convertScriptErrorToFxError(error, finalCmd)));
            }
            else {
                // handle '::set-output' or '::set-teamsfx-env' pattern
                const outputString = allOutputStrings.join("");
                const outputObject = parseSetOutputCommand(outputString);
                if (Object.keys(outputObject).length > 0)
                    logProvider.verbose(`script output env variables: ${(0, stringUtils_1.maskSecret)(JSON.stringify(outputObject), {
                        replace: "***",
                    })}`);
                resolve((0, teamsfx_api_1.ok)([outputString, outputObject]));
            }
        });
        const dataHandler = (data) => {
            allOutputStrings.push(data);
            if (appendFile) {
                fs_extra_1.default.appendFileSync(appendFile, data);
            }
        };
        (_a = cp.stdout) === null || _a === void 0 ? void 0 : _a.on("data", (data) => {
            const str = bufferToString(data, systemEncoding);
            logProvider.info(` [script stdout] ${(0, stringUtils_1.maskSecret)(str, { replace: "***" })}`);
            dataHandler(str);
        });
        const handler = getStderrHandler(logProvider, systemEncoding, stderrStrings, dataHandler);
        (_b = cp.stderr) === null || _b === void 0 ? void 0 : _b.on("data", handler);
    });
}
exports.executeCommand = executeCommand;
function getStderrHandler(logProvider, systemEncoding, stderrStrings, dataHandler) {
    return (data) => {
        const str = bufferToString(data, systemEncoding);
        logProvider.warning(` [script stderr] ${(0, stringUtils_1.maskSecret)(str, { replace: "***" })}`);
        dataHandler(str);
        stderrStrings.push(str);
    };
}
exports.getStderrHandler = getStderrHandler;
function bufferToString(data, systemEncoding) {
    const str = systemEncoding === "utf8" || systemEncoding === "utf-8"
        ? data.toString()
        : iconv_lite_1.default.decode(data, systemEncoding);
    return str;
}
exports.bufferToString = bufferToString;
function convertScriptErrorToFxError(error, run) {
    if (error.killed) {
        return new script_1.ScriptTimeoutError(error, run);
    }
    else {
        return new script_1.ScriptExecutionError(error, run);
    }
}
exports.convertScriptErrorToFxError = convertScriptErrorToFxError;
function parseSetOutputCommand(stdout) {
    const regex = /::(set-teamsfx-env|set-output)\s+(\w+)=((["'])(.*?)\4|[^"'\s]+)/g;
    const output = {};
    let match;
    while ((match = regex.exec(stdout))) {
        const key = match[2];
        const value = match[5] !== undefined ? match[5] : match[3];
        output[key] = value;
    }
    return output;
}
exports.parseSetOutputCommand = parseSetOutputCommand;
function capitalizeFirstLetter(raw) {
    return raw.charAt(0).toUpperCase() + raw.slice(1);
}
exports.capitalizeFirstLetter = capitalizeFirstLetter;
//# sourceMappingURL=scriptDriver.js.map
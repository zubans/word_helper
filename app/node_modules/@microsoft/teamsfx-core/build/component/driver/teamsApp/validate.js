"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidateManifestDriver = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lib_1 = require("@feathersjs/hooks/lib");
const typedi_1 = require("typedi");
const os_1 = require("os");
const lodash_1 = require("lodash");
const wrapUtil_1 = require("../util/wrapUtil");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const telemetry_1 = require("./utils/telemetry");
const results_1 = require("./results");
const errors_1 = require("./errors");
const ManifestUtils_1 = require("./utils/ManifestUtils");
const localizeUtils_1 = require("../../../common/localizeUtils");
const constants_1 = require("../../../common/constants");
const common_1 = require("../../utils/common");
const constant_1 = require("../../configManager/constant");
const common_2 = require("../../../error/common");
const path_1 = tslib_1.__importDefault(require("path"));
const CopilotGptManifestUtils_1 = require("./utils/CopilotGptManifestUtils");
const PluginManifestUtils_1 = require("./utils/PluginManifestUtils");
const actionName = "teamsApp/validateManifest";
let ValidateManifestDriver = class ValidateManifestDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.description.validateDriver");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.validateManifest.progressBar.message");
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.validate(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async validate(args, context) {
        var _a, _b, _c, _d, _e, _f, _g;
        const result = this.validateArgs(args);
        if (result.isErr()) {
            return (0, teamsfx_api_1.err)(result.error);
        }
        const manifestPath = (0, common_1.getAbsolutePath)(args.manifestPath, context.projectPath);
        const manifestRes = await ManifestUtils_1.manifestUtils.getManifestV3(manifestPath, context);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const manifest = manifestRes.value;
        let manifestValidationResult;
        const telemetryProperties = {};
        if (manifest.$schema) {
            try {
                manifestValidationResult = await teamsfx_api_1.ManifestUtil.validateManifest(manifest);
                telemetryProperties[telemetry_1.TelemetryPropertyKey.validationErrors] = manifestValidationResult
                    .map((r) => r.replace(/\//g, ""))
                    .join(";");
            }
            catch (e) {
                return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                    (0, localizeUtils_1.getLocalizedString)("error.appstudio.validateFetchSchemaFailed", manifest.$schema, e.message),
                ]), constants_1.HelpLinks.WhyNeedProvision));
            }
        }
        else {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                (0, localizeUtils_1.getLocalizedString)("error.appstudio.validateSchemaNotDefined"),
            ]), constants_1.HelpLinks.WhyNeedProvision));
        }
        // validate localization files
        const localizationFilesValidationRes = await this.validateLocalizatoinFiles(args, context, manifest);
        if (localizationFilesValidationRes.isErr()) {
            return (0, teamsfx_api_1.err)(localizationFilesValidationRes.error);
        }
        telemetryProperties[telemetry_1.TelemetryPropertyKey.localizationValidationErrors] =
            localizationFilesValidationRes.value.error.map((r) => r.replace(/\//g, "")).join(";");
        let declarativeCopilotValidationResult;
        let pluginValidationResult;
        let pluginPath = "";
        if (manifest.copilotExtensions || manifest.copilotAgents) {
            // plugin
            const plugins = manifest.copilotExtensions
                ? manifest.copilotExtensions.plugins
                : manifest.copilotAgents.plugins;
            if ((plugins === null || plugins === void 0 ? void 0 : plugins.length) && plugins[0].file) {
                pluginPath = path_1.default.join(path_1.default.dirname(manifestPath), plugins[0].file);
                const pluginValidationRes = await PluginManifestUtils_1.pluginManifestUtils.validateAgainstSchema(plugins[0], pluginPath, context);
                if (pluginValidationRes.isErr()) {
                    return (0, teamsfx_api_1.err)(pluginValidationRes.error);
                }
                else {
                    pluginValidationResult = pluginValidationRes.value;
                    telemetryProperties[telemetry_1.TelemetryPropertyKey.pluginValidationErrors] =
                        pluginValidationResult === null || pluginValidationResult === void 0 ? void 0 : pluginValidationResult.validationResult.map((r) => r.replace(/\//g, "")).join(";");
                }
            }
            // Declarative Copilot
            const declarativeCopilots = manifest.copilotExtensions
                ? manifest.copilotExtensions.declarativeCopilots
                : manifest.copilotAgents.declarativeAgents;
            if ((declarativeCopilots === null || declarativeCopilots === void 0 ? void 0 : declarativeCopilots.length) && declarativeCopilots[0].file) {
                const declarativeCopilotPath = path_1.default.join(path_1.default.dirname(manifestPath), declarativeCopilots[0].file);
                const declarativeCopilotValidationRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.validateAgainstSchema(declarativeCopilots[0], declarativeCopilotPath, context);
                if (declarativeCopilotValidationRes.isErr()) {
                    return (0, teamsfx_api_1.err)(declarativeCopilotValidationRes.error);
                }
                else {
                    declarativeCopilotValidationResult = declarativeCopilotValidationRes.value;
                    telemetryProperties[telemetry_1.TelemetryPropertyKey.gptValidationErrors] =
                        declarativeCopilotValidationResult === null || declarativeCopilotValidationResult === void 0 ? void 0 : declarativeCopilotValidationResult.validationResult.map((r) => r.replace(/\//g, "")).join(";");
                    if (declarativeCopilotValidationResult.actionValidationResult.length > 0) {
                        let errors = [];
                        for (let index = 0; index < declarativeCopilotValidationResult.actionValidationResult.length; index++) {
                            errors = errors.concat(declarativeCopilotValidationResult.actionValidationResult[index].validationResult.map((r) => index.toString() + ":" + r.replace(/\//g, "")));
                        }
                        telemetryProperties[`${telemetry_1.TelemetryPropertyKey.gptActionValidationErrors}`] =
                            errors.join(";");
                    }
                }
            }
        }
        const actionErrorCount = (_a = declarativeCopilotValidationResult === null || declarativeCopilotValidationResult === void 0 ? void 0 : declarativeCopilotValidationResult.actionValidationResult.filter((o) => o.filePath !== pluginPath).reduce((acc, { validationResult }) => acc + validationResult.length, 0)) !== null && _a !== void 0 ? _a : 0;
        const allErrorCount = manifestValidationResult.length +
            localizationFilesValidationRes.value.error.length +
            ((_b = declarativeCopilotValidationResult === null || declarativeCopilotValidationResult === void 0 ? void 0 : declarativeCopilotValidationResult.validationResult.length) !== null && _b !== void 0 ? _b : 0) +
            ((_c = pluginValidationResult === null || pluginValidationResult === void 0 ? void 0 : pluginValidationResult.validationResult.length) !== null && _c !== void 0 ? _c : 0) +
            actionErrorCount;
        if (allErrorCount > 0) {
            const summaryStr = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.failed", allErrorCount);
            if (context.platform === teamsfx_api_1.Platform.CLI) {
                const outputMessage = [
                    {
                        content: "Teams Toolkit has checked manifest(s) with corresponding schema:\n\nSummary: \n",
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    },
                    {
                        content: `${allErrorCount} failed.\n`,
                        color: teamsfx_api_1.Colors.BRIGHT_RED,
                    },
                ];
                if (manifestValidationResult.length > 0) {
                    outputMessage.push({
                        content: (0, localizeUtils_1.getDefaultString)("driver.teamsApp.summary.validateTeamsManifest.checkPath", args.manifestPath) + "\n",
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    });
                    manifestValidationResult.map((error) => {
                        outputMessage.push({ content: `${constant_1.SummaryConstant.Failed} `, color: teamsfx_api_1.Colors.BRIGHT_RED });
                        outputMessage.push({
                            content: `${error}\n`,
                            color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                        });
                    });
                }
                if (localizationFilesValidationRes.value.error.length > 0) {
                    outputMessage.push({
                        content: (0, localizeUtils_1.getDefaultString)("driver.teamsApp.summary.validateTeamsManifest.checkPath", localizationFilesValidationRes.value.filePath) + "\n",
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    });
                    localizationFilesValidationRes.value.error.map((error) => {
                        outputMessage.push({ content: `${constant_1.SummaryConstant.Failed} `, color: teamsfx_api_1.Colors.BRIGHT_RED });
                        outputMessage.push({
                            content: `${error}\n`,
                            color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                        });
                    });
                }
                if (declarativeCopilotValidationResult) {
                    const validationMessage = CopilotGptManifestUtils_1.copilotGptManifestUtils.logValidationErrors(declarativeCopilotValidationResult, context.platform, pluginPath);
                    if (validationMessage) {
                        outputMessage.push(...validationMessage);
                    }
                }
                if (pluginValidationResult) {
                    const validationMessage = PluginManifestUtils_1.pluginManifestUtils.logValidationErrors(pluginValidationResult, context.platform);
                    if (validationMessage) {
                        outputMessage.push(...validationMessage);
                    }
                }
                (_d = context.ui) === null || _d === void 0 ? void 0 : _d.showMessage("info", outputMessage, false);
            }
            else {
                // logs in output window
                const teamsManifestErrors = manifestValidationResult
                    .map((error) => {
                    return `${constant_1.SummaryConstant.Failed} ${error}`;
                })
                    .join(os_1.EOL);
                let outputMessage = os_1.EOL + (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateManifest", summaryStr);
                if (teamsManifestErrors.length > 0) {
                    outputMessage +=
                        os_1.EOL +
                            (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateTeamsManifest.checkPath", args.manifestPath) +
                            os_1.EOL +
                            teamsManifestErrors;
                }
                if (localizationFilesValidationRes.value.error.length > 0) {
                    const localizationErrors = localizationFilesValidationRes.value.error
                        .map((error) => {
                        return `${constant_1.SummaryConstant.Failed} ${error}`;
                    })
                        .join(os_1.EOL);
                    outputMessage +=
                        os_1.EOL +
                            (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateTeamsManifest.checkPath", localizationFilesValidationRes.value.filePath) +
                            os_1.EOL +
                            localizationErrors;
                }
                if (declarativeCopilotValidationResult) {
                    const validationMessage = CopilotGptManifestUtils_1.copilotGptManifestUtils.logValidationErrors(declarativeCopilotValidationResult, context.platform, pluginPath);
                    if (validationMessage) {
                        outputMessage += os_1.EOL + validationMessage;
                    }
                }
                if (pluginValidationResult) {
                    const validationMessage = PluginManifestUtils_1.pluginManifestUtils.logValidationErrors(pluginValidationResult, context.platform);
                    if (validationMessage) {
                        outputMessage += os_1.EOL + validationMessage;
                    }
                }
                outputMessage += os_1.EOL;
                (_e = context.logProvider) === null || _e === void 0 ? void 0 : _e.info(outputMessage);
            }
            (0, lodash_1.merge)(context.telemetryProperties, telemetryProperties);
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, [
                (0, localizeUtils_1.getDefaultString)("driver.teamsApp.validate.result", summaryStr),
                (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.validate.result.display", summaryStr),
            ]));
        }
        else {
            // logs in output window
            const summaryStr = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.succeed", (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.all"));
            const outputMessage = os_1.EOL + (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateManifest", summaryStr, "", "");
            (_f = context.logProvider) === null || _f === void 0 ? void 0 : _f.info(outputMessage);
            const validationSuccess = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.validate.result.display", summaryStr);
            if (context.platform === teamsfx_api_1.Platform.VS) {
                context.logProvider.info(validationSuccess);
            }
            if (args.showMessage) {
                if (context.platform === teamsfx_api_1.Platform.CLI) {
                    const outputMessage = [
                        {
                            content: "Teams Toolkit has completed checking your app package against validation rules. " +
                                summaryStr +
                                ".",
                            color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                        },
                    ];
                    context.logProvider.info(outputMessage);
                }
                else {
                    (_g = context.ui) === null || _g === void 0 ? void 0 : _g.showMessage("info", validationSuccess, false);
                }
            }
            return (0, teamsfx_api_1.ok)(new Map());
        }
    }
    validateArgs(args) {
        if (!args || !args.manifestPath) {
            return (0, teamsfx_api_1.err)(new common_2.InvalidActionInputError(actionName, ["manifestPath"], "https://aka.ms/teamsfx-actions/teamsapp-validate"));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    async validateLocalizatoinFiles(args, context, manifest) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (((_b = (_a = manifest.localizationInfo) === null || _a === void 0 ? void 0 : _a.additionalLanguages) === null || _b === void 0 ? void 0 : _b.length) == 0 &&
            !((_c = manifest.localizationInfo) === null || _c === void 0 ? void 0 : _c.defaultLanguageFile)) {
            return (0, teamsfx_api_1.ok)({ error: [] });
        }
        const languageList = ((_d = manifest.localizationInfo) === null || _d === void 0 ? void 0 : _d.additionalLanguages) || [];
        if ((_e = manifest.localizationInfo) === null || _e === void 0 ? void 0 : _e.defaultLanguageFile) {
            languageList.push({
                languageTag: manifest.localizationInfo.defaultLanguageTag,
                file: manifest.localizationInfo.defaultLanguageFile,
            });
        }
        for (const language of languageList) {
            const filePath = language === null || language === void 0 ? void 0 : language.file;
            if (!filePath) {
                return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                    (0, localizeUtils_1.getLocalizedString)("error.appstudio.localizationFile.pathNotDefined", filePath),
                ])));
            }
            const localizationFileDir = path_1.default.dirname((0, common_1.getAbsolutePath)(args.manifestPath, context.projectPath));
            const localizationFilePath = (0, common_1.getAbsolutePath)(filePath, localizationFileDir);
            const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(localizationFilePath);
            if (manifestRes.isErr()) {
                return (0, teamsfx_api_1.err)(manifestRes.error);
            }
            const localizationFile = manifestRes.value;
            try {
                const schema = await teamsfx_api_1.ManifestUtil.fetchSchema(localizationFile);
                // the current localization schema has invalid regex sytax, we need to manually fix the properties temporarily
                const activityDespString = "^activities.activityTypes\\[\\b([0-9]|[1-8][0-9]|9[0-9]|1[01][0-9]|12[0-7])\\b]\\.description$";
                const fixedActivityDespString = "^activities.activityTypes\\[\\b([0-9]|[1-8][0-9]|9[0-9]|1[01][0-9]|12[0-7])\\b\\]\\.description$";
                if ((_f = schema.patternProperties) === null || _f === void 0 ? void 0 : _f[activityDespString]) {
                    schema.patternProperties[fixedActivityDespString] =
                        schema.patternProperties[activityDespString];
                    delete schema.patternProperties[activityDespString];
                }
                const activityTemplateString = "^activities.activityTypes\\[\\b([0-9]|[1-8][0-9]|9[0-9]|1[01][0-9]|12[0-7])\\b]\\.templateText$";
                const fixedActivityTemplateString = "^activities.activityTypes\\[\\b([0-9]|[1-8][0-9]|9[0-9]|1[01][0-9]|12[0-7])\\b\\]\\.templateText$";
                if ((_g = schema.patternProperties) === null || _g === void 0 ? void 0 : _g[activityTemplateString]) {
                    schema.patternProperties[fixedActivityTemplateString] =
                        schema.patternProperties[activityTemplateString];
                    delete schema.patternProperties[activityTemplateString];
                }
                const validationRes = await teamsfx_api_1.ManifestUtil.validateManifestAgainstSchema(localizationFile, schema);
                if (validationRes.length > 0) {
                    return (0, teamsfx_api_1.ok)({ error: validationRes, filePath: localizationFilePath });
                }
            }
            catch (e) {
                return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                    (0, localizeUtils_1.getLocalizedString)("error.appstudio.localizationFile.validationException", filePath, e.message),
                ])));
            }
        }
        return (0, teamsfx_api_1.ok)({ error: [] });
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext]),
    tslib_1.__metadata("design:returntype", Promise)
], ValidateManifestDriver.prototype, "validate", null);
ValidateManifestDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(actionName)
], ValidateManifestDriver);
exports.ValidateManifestDriver = ValidateManifestDriver;
//# sourceMappingURL=validate.js.map
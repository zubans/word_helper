"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
var CreateAppPackageDriver_1;
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateAppPackageDriver = exports.actionName = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const localizeUtils_1 = require("../../../common/localizeUtils");
const globalVars_1 = require("../../../common/globalVars");
const common_1 = require("../../../error/common");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const wrapUtil_1 = require("../util/wrapUtil");
const constants_1 = require("./constants");
const ManifestUtils_1 = require("./utils/ManifestUtils");
const teamsApp_1 = require("../../../error/teamsApp");
const utils_1 = require("./utils/utils");
const CopilotGptManifestUtils_1 = require("./utils/CopilotGptManifestUtils");
const envFunctionUtils_1 = require("../../utils/envFunctionUtils");
const common_2 = require("../../utils/common");
exports.actionName = "teamsApp/zipAppPackage";
let CreateAppPackageDriver = CreateAppPackageDriver_1 = class CreateAppPackageDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.description.createAppPackageDriver");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.createPackage.progressBar.message");
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, exports.actionName, exports.actionName);
        const res = await this.build(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async build(args, context) {
        var _a, _b;
        const result = this.validateArgs(args);
        if (result.isErr()) {
            return (0, teamsfx_api_1.err)(result.error);
        }
        let manifestPath = args.manifestPath;
        if (!path.isAbsolute(manifestPath)) {
            manifestPath = path.join(context.projectPath, manifestPath);
        }
        const manifestRes = await ManifestUtils_1.manifestUtils.getManifestV3(manifestPath, context);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const manifest = manifestRes.value;
        // Deal with relative path
        // Environment variables should have been replaced by value
        // ./build/appPackage/appPackage.dev.zip instead of ./build/appPackage/appPackage.${{TEAMSFX_ENV}}.zip
        const zipFileName = (0, common_2.getAbsolutePath)(args.outputZipPath, context.projectPath);
        const zipFileDir = path.dirname(zipFileName);
        await fs_extra_1.default.mkdir(zipFileDir, { recursive: true });
        let jsonFileDir;
        let teamsManifestJsonFileName;
        const shouldwriteAllManifest = !!args.outputFolder;
        if (args.outputJsonPath) {
            teamsManifestJsonFileName = (0, common_2.getAbsolutePath)(args.outputJsonPath, context.projectPath);
            jsonFileDir = path.dirname(teamsManifestJsonFileName);
        }
        else {
            jsonFileDir = (0, common_2.getAbsolutePath)(args.outputFolder, context.projectPath);
            teamsManifestJsonFileName = path.join(jsonFileDir, `manifest.${process.env.TEAMSFX_ENV}.json`);
        }
        await fs_extra_1.default.mkdir(jsonFileDir, { recursive: true });
        const appDirectory = path.dirname(manifestPath);
        const colorFile = path.resolve(appDirectory, manifest.icons.color);
        if (!(await fs_extra_1.default.pathExists(colorFile))) {
            const error = new common_1.FileNotFoundError(exports.actionName, colorFile, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage");
            return (0, teamsfx_api_1.err)(error);
        }
        const colorFileRelativePath = path.relative(appDirectory, colorFile);
        if (colorFileRelativePath.startsWith("..")) {
            return (0, teamsfx_api_1.err)(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(colorFile));
        }
        const outlineFile = path.resolve(appDirectory, manifest.icons.outline);
        if (!(await fs_extra_1.default.pathExists(outlineFile))) {
            const error = new common_1.FileNotFoundError(exports.actionName, outlineFile, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage");
            return (0, teamsfx_api_1.err)(error);
        }
        const outlineFileRelativePath = path.relative(appDirectory, outlineFile);
        if (outlineFileRelativePath.startsWith("..")) {
            return (0, teamsfx_api_1.err)(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(outlineFile));
        }
        // pre-check existence
        if (manifest.localizationInfo &&
            manifest.localizationInfo.additionalLanguages &&
            manifest.localizationInfo.additionalLanguages.length > 0) {
            for (const language of manifest.localizationInfo.additionalLanguages) {
                const file = language.file;
                const fileName = `${appDirectory}/${file}`;
                if (!(await fs_extra_1.default.pathExists(fileName))) {
                    return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(exports.actionName, fileName, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
                }
            }
        }
        if (manifest.localizationInfo && manifest.localizationInfo.defaultLanguageFile) {
            const file = manifest.localizationInfo.defaultLanguageFile;
            const fileName = `${appDirectory}/${file}`;
            if (!(await fs_extra_1.default.pathExists(fileName))) {
                return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(exports.actionName, fileName, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
            }
        }
        const zip = new adm_zip_1.default();
        zip.addFile(constants_1.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest, null, 4)));
        // outline.png & color.png, relative path
        let dir = path.dirname(manifest.icons.color);
        zip.addLocalFile(colorFile, dir === "." ? "" : dir);
        dir = path.dirname(manifest.icons.outline);
        zip.addLocalFile(outlineFile, dir === "." ? "" : dir);
        // localization file
        if (manifest.localizationInfo &&
            manifest.localizationInfo.additionalLanguages &&
            manifest.localizationInfo.additionalLanguages.length > 0) {
            for (const language of manifest.localizationInfo.additionalLanguages) {
                const file = language.file;
                const fileName = path.resolve(appDirectory, file);
                const relativePath = path.relative(appDirectory, fileName);
                if (relativePath.startsWith("..")) {
                    return (0, teamsfx_api_1.err)(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(fileName));
                }
                const dir = path.dirname(file);
                zip.addLocalFile(fileName, dir === "." ? "" : dir);
            }
        }
        if (manifest.localizationInfo && manifest.localizationInfo.defaultLanguageFile) {
            const file = manifest.localizationInfo.defaultLanguageFile;
            const fileName = path.resolve(appDirectory, file);
            const relativePath = path.relative(appDirectory, fileName);
            if (relativePath.startsWith("..")) {
                return (0, teamsfx_api_1.err)(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(fileName));
            }
            const dir = path.dirname(file);
            zip.addLocalFile(fileName, dir === "." ? "" : dir);
        }
        // API ME, API specification and Adaptive card templates
        if (manifest.composeExtensions &&
            manifest.composeExtensions.length > 0 &&
            manifest.composeExtensions[0].composeExtensionType == "apiBased" &&
            manifest.composeExtensions[0].apiSpecificationFile) {
            const apiSpecificationFile = path.resolve(appDirectory, manifest.composeExtensions[0].apiSpecificationFile);
            const checkExistenceRes = await this.validateReferencedFile(apiSpecificationFile, appDirectory);
            if (checkExistenceRes.isErr()) {
                return (0, teamsfx_api_1.err)(checkExistenceRes.error);
            }
            const addFileWithVariableRes = await this.addFileWithVariable(zip, manifest.composeExtensions[0].apiSpecificationFile, apiSpecificationFile, envFunctionUtils_1.ManifestType.ApiSpec, context);
            if (addFileWithVariableRes.isErr()) {
                return (0, teamsfx_api_1.err)(addFileWithVariableRes.error);
            }
            if (manifest.composeExtensions[0].commands.length > 0) {
                for (const command of manifest.composeExtensions[0].commands) {
                    if (command.apiResponseRenderingTemplateFile) {
                        const adaptiveCardFile = path.resolve(appDirectory, command.apiResponseRenderingTemplateFile);
                        const checkExistenceRes = await this.validateReferencedFile(adaptiveCardFile, appDirectory);
                        if (checkExistenceRes.isErr()) {
                            return (0, teamsfx_api_1.err)(checkExistenceRes.error);
                        }
                        const dir = path.dirname(command.apiResponseRenderingTemplateFile);
                        this.addFileInZip(zip, dir, adaptiveCardFile);
                    }
                }
            }
        }
        const plugins = manifest.copilotExtensions
            ? manifest.copilotExtensions.plugins
            : (_a = manifest.copilotAgents) === null || _a === void 0 ? void 0 : _a.plugins;
        if ((plugins === null || plugins === void 0 ? void 0 : plugins.length) && plugins[0].file) {
            // API plugin
            const addFilesRes = await this.addPlugin(zip, plugins[0].file, appDirectory, context, !shouldwriteAllManifest ? undefined : jsonFileDir);
            if (addFilesRes.isErr()) {
                return (0, teamsfx_api_1.err)(addFilesRes.error);
            }
        }
        const declarativeCopilots = manifest.copilotExtensions
            ? manifest.copilotExtensions.declarativeCopilots
            : (_b = manifest.copilotAgents) === null || _b === void 0 ? void 0 : _b.declarativeAgents;
        // Copilot GPT
        if ((declarativeCopilots === null || declarativeCopilots === void 0 ? void 0 : declarativeCopilots.length) && declarativeCopilots[0].file) {
            const copilotGptManifestFile = path.resolve(appDirectory, declarativeCopilots[0].file);
            const checkExistenceRes = await this.validateReferencedFile(copilotGptManifestFile, appDirectory);
            if (checkExistenceRes.isErr()) {
                return (0, teamsfx_api_1.err)(checkExistenceRes.error);
            }
            const addFileWithVariableRes = await this.addFileWithVariable(zip, declarativeCopilots[0].file, copilotGptManifestFile, envFunctionUtils_1.ManifestType.DeclarativeCopilotManifest, context, shouldwriteAllManifest
                ? path.join(jsonFileDir, path.relative(appDirectory, copilotGptManifestFile))
                : undefined);
            if (addFileWithVariableRes.isErr()) {
                return (0, teamsfx_api_1.err)(addFileWithVariableRes.error);
            }
            const getCopilotGptRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.getManifest(copilotGptManifestFile, context);
            if (getCopilotGptRes.isOk()) {
                if (getCopilotGptRes.value.actions) {
                    const pluginFiles = getCopilotGptRes.value.actions.map((action) => action.file);
                    for (const pluginFile of pluginFiles) {
                        const pluginFileAbsolutePath = path.resolve(path.dirname(copilotGptManifestFile), pluginFile);
                        const pluginFileRelativePath = path.relative(appDirectory, pluginFileAbsolutePath);
                        const useForwardSlash = declarativeCopilots[0].file.concat(pluginFile).includes("/");
                        const addPluginRes = await this.addPlugin(zip, (0, utils_1.normalizePath)(pluginFileRelativePath, useForwardSlash), appDirectory, context, !shouldwriteAllManifest ? undefined : jsonFileDir);
                        if (addPluginRes.isErr()) {
                            return (0, teamsfx_api_1.err)(addPluginRes.error);
                        }
                    }
                }
            }
            else {
                return (0, teamsfx_api_1.err)(getCopilotGptRes.error);
            }
        }
        zip.writeZip(zipFileName);
        await this.writeJsonFile(teamsManifestJsonFileName, JSON.stringify(manifest, null, 4));
        const builtSuccess = [
            { content: "(âˆš)Done: ", color: teamsfx_api_1.Colors.BRIGHT_GREEN },
            { content: "Teams Package ", color: teamsfx_api_1.Colors.BRIGHT_WHITE },
            { content: zipFileName, color: teamsfx_api_1.Colors.BRIGHT_MAGENTA },
            { content: " built successfully!", color: teamsfx_api_1.Colors.BRIGHT_WHITE },
        ];
        context.logProvider.info(builtSuccess);
        return (0, teamsfx_api_1.ok)(new Map());
    }
    static async expandEnvVars(filePath, ctx, manifestType) {
        const content = await fs_extra_1.default.readFile(filePath, "utf8");
        return (0, utils_1.getResolvedManifest)(content, filePath, manifestType, ctx);
    }
    validateArgs(args) {
        const invalidParams = [];
        if (!args || !args.manifestPath) {
            invalidParams.push("manifestPath");
        }
        if (!args || (!args.outputJsonPath && !args.outputFolder)) {
            invalidParams.push("outputJsonPath or outputFolder");
        }
        if (!args || !args.outputZipPath) {
            invalidParams.push("outputZipPath");
        }
        if (invalidParams.length > 0) {
            return (0, teamsfx_api_1.err)(new common_1.InvalidActionInputError(exports.actionName, invalidParams, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
        }
        else {
            return (0, teamsfx_api_1.ok)(undefined);
        }
    }
    async validateReferencedFile(file, directory) {
        if (!(await fs_extra_1.default.pathExists(file))) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(exports.actionName, file, "https://aka.ms/teamsfx-actions/teamsapp-zipAppPackage"));
        }
        const relativePath = path.relative(directory, file);
        if (relativePath.startsWith("..")) {
            return (0, teamsfx_api_1.err)(new teamsApp_1.InvalidFileOutsideOfTheDirectotryError(file));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    /**
     * Add plugin file and plugin related files to zip.
     * @param zip zip
     * @param pluginRelativePath plugin file path relative to app package folder
     * @param appDirectory app package path containing manifest template.
     * @param context context
     * @param outputDirectory optional. Folder where we should put the resolved manifest in.
     * @returns result of adding plugin file and plugin related files
     */
    async addPlugin(zip, pluginRelativePath, appDirectory, context, outputDirectory) {
        const pluginFile = path.resolve(appDirectory, pluginRelativePath);
        const checkExistenceRes = await this.validateReferencedFile(pluginFile, appDirectory);
        if (checkExistenceRes.isErr()) {
            return (0, teamsfx_api_1.err)(checkExistenceRes.error);
        }
        const addFileWithVariableRes = await this.addFileWithVariable(zip, pluginRelativePath, pluginFile, envFunctionUtils_1.ManifestType.PluginManifest, context, !outputDirectory
            ? undefined
            : path.join(outputDirectory, path.relative(appDirectory, pluginFile)));
        if (addFileWithVariableRes.isErr()) {
            return (0, teamsfx_api_1.err)(addFileWithVariableRes.error);
        }
        const addFilesRes = await this.addPluginRelatedFiles(zip, pluginRelativePath, appDirectory, context);
        if (addFilesRes.isErr()) {
            return (0, teamsfx_api_1.err)(addFilesRes.error);
        }
        else {
            return (0, teamsfx_api_1.ok)(undefined);
        }
    }
    /**
     * Add plugin related files (OpenAPI spec) to zip.
     * @param zip zip.
     * @param pluginFile plugin file path relative to app package folder.
     * @param appDirectory app package folder.
     * @param context context.
     * @returns results whether add files related to plugin is successful.
     */
    async addPluginRelatedFiles(zip, pluginFile, appDirectory, context) {
        var _a;
        const pluginFilePath = path.join(appDirectory, pluginFile);
        let pluginContent;
        try {
            pluginContent = (await fs_extra_1.default.readJSON(pluginFilePath));
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.JSONSyntaxError(pluginFilePath, e, exports.actionName));
        }
        const runtimes = pluginContent.runtimes;
        if (runtimes && runtimes.length > 0) {
            for (const runtime of runtimes) {
                if (runtime.type === "OpenApi" && ((_a = runtime.spec) === null || _a === void 0 ? void 0 : _a.url)) {
                    const specFile = path.resolve(path.dirname(pluginFilePath), runtime.spec.url);
                    // add openapi spec
                    const checkExistenceRes = await this.validateReferencedFile(specFile, appDirectory);
                    if (checkExistenceRes.isErr()) {
                        return (0, teamsfx_api_1.err)(checkExistenceRes.error);
                    }
                    const entryName = path.relative(appDirectory, specFile);
                    const useForwardSlash = pluginFile.concat(runtime.spec.url).includes("/");
                    const addFileWithVariableRes = await this.addFileWithVariable(zip, (0, utils_1.normalizePath)(entryName, useForwardSlash), specFile, envFunctionUtils_1.ManifestType.ApiSpec, context);
                    if (addFileWithVariableRes.isErr()) {
                        return (0, teamsfx_api_1.err)(addFileWithVariableRes.error);
                    }
                }
            }
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    async addFileWithVariable(zip, entryName, filePath, manifestType, context, outputPath // If outputPath exists, we will write down the file after replacing placeholders.
    ) {
        const expandedEnvVarResult = await CreateAppPackageDriver_1.expandEnvVars(filePath, context, manifestType);
        if (expandedEnvVarResult.isErr()) {
            return (0, teamsfx_api_1.err)(expandedEnvVarResult.error);
        }
        const content = expandedEnvVarResult.value;
        const attr = await fs_extra_1.default.stat(filePath);
        zip.addFile(entryName, Buffer.from(content), "", attr.mode);
        if (outputPath && path.extname(outputPath).toLowerCase() === ".json") {
            await this.writeJsonFile(`${outputPath.substring(0, outputPath.length - 5)}.${process.env.TEAMSFX_ENV}.json`, content);
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    addFileInZip(zip, zipPath, filePath) {
        zip.addLocalFile(filePath, zipPath === "." ? "" : zipPath);
    }
    async writeJsonFile(jsonFileName, content) {
        if (await fs_extra_1.default.pathExists(jsonFileName)) {
            await fs_extra_1.default.chmod(jsonFileName, 0o777);
        }
        await fs_extra_1.default.writeFile(jsonFileName, content);
        await fs_extra_1.default.chmod(jsonFileName, 0o444);
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "CreateAppPackageDriver" }),
        (0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(exports.actionName, exports.actionName),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext]),
    tslib_1.__metadata("design:returntype", Promise)
], CreateAppPackageDriver.prototype, "build", null);
CreateAppPackageDriver = CreateAppPackageDriver_1 = tslib_1.__decorate([
    (0, typedi_1.Service)(exports.actionName)
], CreateAppPackageDriver);
exports.CreateAppPackageDriver = CreateAppPackageDriver;
//# sourceMappingURL=createAppPackage.js.map
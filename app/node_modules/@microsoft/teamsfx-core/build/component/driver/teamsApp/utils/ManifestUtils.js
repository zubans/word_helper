"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.manifestUtils = exports.ManifestUtils = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const path = tslib_1.__importStar(require("path"));
require("reflect-metadata");
const strip_bom_1 = tslib_1.__importDefault(require("strip-bom"));
const uuid_1 = require("uuid");
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const globalVars_1 = require("../../../../common/globalVars");
const projectTypeChecker_1 = require("../../../../common/projectTypeChecker");
const common_1 = require("../../../../error/common");
const constants_1 = require("../../../../question/constants");
const constants_2 = require("../../../constants");
const migrate_1 = require("../../../migrate");
const common_2 = require("../../../utils/common");
const envFunctionUtils_1 = require("../../../utils/envFunctionUtils");
const constants_3 = require("../constants");
const errors_1 = require("../errors");
const results_1 = require("../results");
const utils_1 = require("./utils");
class ManifestUtils {
    async readAppManifest(projectPath) {
        const filePath = this.getTeamsAppManifestPath(projectPath);
        return await this._readAppManifest(filePath);
    }
    readAppManifestSync(projectPath) {
        const filePath = this.getTeamsAppManifestPath(projectPath);
        if (!fs_extra_1.default.existsSync(filePath)) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("teamsApp", filePath));
        }
        // Be compatible with UTF8-BOM encoding
        // Avoid Unexpected token error at JSON.parse()
        let content;
        try {
            content = fs_extra_1.default.readFileSync(filePath, { encoding: "utf-8" });
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.ReadFileError(e, "ManifestUtils"));
        }
        content = (0, strip_bom_1.default)(content);
        const contentV3 = (0, migrate_1.convertManifestTemplateToV3)(content);
        try {
            const manifest = JSON.parse(contentV3);
            return (0, teamsfx_api_1.ok)(manifest);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.JSONSyntaxError(filePath, e, "ManifestUtils"));
        }
    }
    async _readAppManifest(manifestTemplatePath) {
        if (!(await fs_extra_1.default.pathExists(manifestTemplatePath))) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("teamsApp", manifestTemplatePath));
        }
        // Be compatible with UTF8-BOM encoding
        // Avoid Unexpected token error at JSON.parse()
        let content = await fs_extra_1.default.readFile(manifestTemplatePath, { encoding: "utf-8" });
        content = (0, strip_bom_1.default)(content);
        const contentV3 = (0, migrate_1.convertManifestTemplateToV3)(content);
        try {
            const manifest = JSON.parse(contentV3);
            return (0, teamsfx_api_1.ok)(manifest);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.JSONSyntaxError(manifestTemplatePath, e, "ManifestUtils"));
        }
    }
    async _writeAppManifest(appManifest, manifestTemplatePath) {
        const content = JSON.stringify(appManifest, undefined, 4);
        const contentV2 = (0, migrate_1.convertManifestTemplateToV2)(content);
        await fs_extra_1.default.writeFile(manifestTemplatePath, contentV2);
        return (0, teamsfx_api_1.ok)(undefined);
    }
    getTeamsAppManifestPath(projectPath) {
        // Samples from https://github.com/OfficeDev/Microsoft-Teams-Samples have the manifest in appManifest folder
        const filePath = path.join(projectPath, "appManifest", "manifest.json");
        if (fs_extra_1.default.existsSync(filePath)) {
            return filePath;
        }
        // Samples from https://github.com/OfficeDev/Office-Add-in-samples/tree/main/Samples/outlook-set-signature have the manifest in root folder
        const officeAddinManifestPath = path.join(projectPath, "manifest.json");
        if (fs_extra_1.default.existsSync(officeAddinManifestPath)) {
            return officeAddinManifestPath;
        }
        return path.join(projectPath, "appPackage", "manifest.json");
    }
    async addCapabilities(inputs, capabilities, isM365 = false) {
        var _a, _b, _c, _d;
        const appManifestRes = await this._readAppManifest(inputs["addManifestPath"]);
        if (appManifestRes.isErr())
            return (0, teamsfx_api_1.err)(appManifestRes.error);
        const appManifest = appManifestRes.value;
        const manifestVersion = appManifest.manifestVersion;
        for (const capability of capabilities) {
            const exceedLimit = this._capabilityExceedLimit(appManifest, capability.name);
            if (exceedLimit) {
                return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.CapabilityExceedLimitError.name, errors_1.AppStudioError.CapabilityExceedLimitError.message(capability.name)));
            }
            let staticTabIndex = (_b = (_a = appManifest.staticTabs) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
            switch (capability.name) {
                case "staticTab":
                    appManifest.staticTabs = appManifest.staticTabs || [];
                    if (capability.snippet) {
                        appManifest.staticTabs.push(capability.snippet);
                    }
                    else {
                        if (capability.existingApp) {
                            const template = (0, lodash_1.cloneDeep)(constants_3.STATIC_TABS_TPL_EXISTING_APP[0]);
                            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
                            template.entityId = "index" + staticTabIndex;
                            appManifest.staticTabs.push(template);
                        }
                        else {
                            const tabManifest = inputs.features === constants_1.CapabilityOptions.dashboardTab().id
                                ? constants_3.STATIC_TABS_TPL_V3[1]
                                : constants_3.STATIC_TABS_TPL_V3[0];
                            const template = (0, lodash_1.cloneDeep)(tabManifest);
                            // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
                            template.entityId = "index" + staticTabIndex;
                            appManifest.staticTabs.push(template);
                        }
                        staticTabIndex++;
                    }
                    break;
                case "configurableTab":
                    appManifest.configurableTabs = appManifest.configurableTabs || [];
                    if (capability.snippet) {
                        appManifest.configurableTabs.push(capability.snippet);
                    }
                    else {
                        if (capability.existingApp) {
                            appManifest.configurableTabs = appManifest.configurableTabs.concat((0, constants_3.getConfigurableTabsTplExistingAppBasedOnVersion)(manifestVersion));
                        }
                        else {
                            appManifest.configurableTabs = appManifest.configurableTabs.concat((0, constants_3.getConfigurableTabsTplBasedOnVersion)(manifestVersion));
                        }
                    }
                    break;
                case "Bot":
                    appManifest.bots = appManifest.bots || [];
                    if (capability.snippet) {
                        appManifest.bots.push(capability.snippet);
                    }
                    else {
                        if (capability.existingApp) {
                            appManifest.bots = appManifest.bots.concat((0, constants_3.getBotsTplExistingAppBasedOnVersion)(manifestVersion));
                        }
                        else {
                            // import QuestionNames introduces dependency cycle and breaks the whole program
                            // inputs[QuestionNames.Features]
                            if (inputs.features) {
                                const feature = inputs.features;
                                if (feature === constants_1.CapabilityOptions.commandBot().id ||
                                    feature == constants_1.CapabilityOptions.workflowBot().id) {
                                    // command and response bot or workflow bot
                                    appManifest.bots = appManifest.bots.concat((0, constants_3.getBotsTplForCommandAndResponseBasedOnVersion)(manifestVersion));
                                }
                                else if (feature === constants_1.CapabilityOptions.notificationBot().id) {
                                    // notification
                                    appManifest.bots = appManifest.bots.concat((0, constants_3.getBotsTplForNotificationBasedOnVersion)(manifestVersion));
                                }
                                else {
                                    // legacy bot
                                    appManifest.bots = appManifest.bots.concat((0, constants_3.getBotsTplBasedOnVersion)(manifestVersion));
                                }
                            }
                            else if (inputs.scenarios) {
                                const scenariosRaw = inputs.scenarios;
                                const scenarios = Array.isArray(scenariosRaw) ? scenariosRaw : [];
                                if (scenarios.includes(constants_2.BotScenario.CommandAndResponseBot) ||
                                    scenarios.includes(constants_2.BotScenario.WorkflowBot)) {
                                    // command and response bot or workflow bot
                                    appManifest.bots = appManifest.bots.concat((0, constants_3.getBotsTplForCommandAndResponseBasedOnVersion)(manifestVersion));
                                }
                                else if (scenarios.includes(constants_2.BotScenario.NotificationBot)) {
                                    // notification
                                    appManifest.bots = appManifest.bots.concat((0, constants_3.getBotsTplForNotificationBasedOnVersion)(manifestVersion));
                                }
                                else {
                                    // legacy bot
                                    appManifest.bots = appManifest.bots.concat((0, constants_3.getBotsTplBasedOnVersion)(manifestVersion));
                                }
                            }
                            else {
                                appManifest.bots = appManifest.bots.concat((0, constants_3.getBotsTplBasedOnVersion)(manifestVersion));
                            }
                        }
                    }
                    break;
                case "MessageExtension":
                    appManifest.composeExtensions = appManifest.composeExtensions || [];
                    if (capability.snippet) {
                        appManifest.composeExtensions.push(capability.snippet);
                    }
                    else {
                        if (capability.existingApp) {
                            appManifest.composeExtensions = appManifest.composeExtensions.concat(constants_3.COMPOSE_EXTENSIONS_TPL_EXISTING_APP);
                        }
                        else {
                            appManifest.composeExtensions = appManifest.composeExtensions.concat(isM365 ? constants_3.COMPOSE_EXTENSIONS_TPL_M365_V3 : constants_3.COMPOSE_EXTENSIONS_TPL_V3);
                        }
                    }
                    break;
                case "WebApplicationInfo":
                    if (capability.snippet) {
                        appManifest.webApplicationInfo = capability.snippet;
                    }
                    else {
                        appManifest.webApplicationInfo = constants_3.WEB_APPLICATION_INFO_V3;
                    }
                    break;
            }
        }
        if (inputs.validDomain && !((_c = appManifest.validDomains) === null || _c === void 0 ? void 0 : _c.includes(inputs.validDomain))) {
            (_d = appManifest.validDomains) === null || _d === void 0 ? void 0 : _d.push(inputs.validDomain);
        }
        const content = JSON.stringify(appManifest, undefined, 4);
        const contentV2 = (0, migrate_1.convertManifestTemplateToV2)(content);
        await fs_extra_1.default.writeFile(inputs["addManifestPath"], contentV2);
        return (0, teamsfx_api_1.ok)(undefined);
    }
    _capabilityExceedLimit(manifest, capability) {
        switch (capability) {
            case "staticTab":
                return (manifest.staticTabs !== undefined && manifest.staticTabs.length >= constants_3.STATIC_TABS_MAX_ITEMS);
            case "configurableTab":
                return manifest.configurableTabs !== undefined && manifest.configurableTabs.length >= 1;
            case "Bot":
                return manifest.bots !== undefined && manifest.bots.length >= 1;
            case "MessageExtension":
                return manifest.composeExtensions !== undefined && manifest.composeExtensions.length >= 1;
            case "WebApplicationInfo":
                return false;
            default:
                return false;
        }
    }
    getCapabilities(template) {
        return (0, projectTypeChecker_1.getCapabilities)(template);
    }
    /**
     * Get command id from composeExtensions
     * @param manifest
     */
    getOperationIds(manifest) {
        var _a;
        const ids = [];
        (_a = manifest.composeExtensions) === null || _a === void 0 ? void 0 : _a.map((extension) => {
            var _a;
            (_a = extension.commands) === null || _a === void 0 ? void 0 : _a.map((command) => {
                ids.push(command.id);
            });
        });
        return ids;
    }
    async getPluginFilePath(manifest, manifestPath) {
        var _a, _b, _c, _d, _e;
        const pluginFile = manifest.copilotExtensions
            ? (_b = (_a = manifest.copilotExtensions.plugins) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.file
            : (_e = (_d = (_c = manifest.copilotAgents) === null || _c === void 0 ? void 0 : _c.plugins) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.file;
        if (pluginFile) {
            const plugin = path.resolve(path.dirname(manifestPath), pluginFile);
            const doesFileExist = await fs_extra_1.default.pathExists(plugin);
            if (doesFileExist) {
                return (0, teamsfx_api_1.ok)(plugin);
            }
            else {
                return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("ManifestUtils", pluginFile));
            }
        }
        else {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.TeamsAppRequiredPropertyMissingError.name, errors_1.AppStudioError.TeamsAppRequiredPropertyMissingError.message("plugins", manifestPath)));
        }
    }
    async getManifestV3(manifestTemplatePath, context, generateIdIfNotResolved = true) {
        const manifestRes = await exports.manifestUtils._readAppManifest(manifestTemplatePath);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        let manifest = manifestRes.value;
        let teamsAppId = "";
        if (generateIdIfNotResolved) {
            // Corner Case: Avoid MissingEnvironmentVariablesError for manifest.id
            teamsAppId = (0, common_2.expandEnvironmentVariable)(manifest.id);
            manifest.id = "";
        }
        const manifestTemplateString = JSON.stringify(manifest);
        // Add environment variable keys to telemetry
        const resolvedManifestRes = await (0, utils_1.getResolvedManifest)(manifestTemplateString, manifestTemplatePath, envFunctionUtils_1.ManifestType.TeamsManifest, context);
        if (resolvedManifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(resolvedManifestRes.error);
        }
        const resolvedManifestString = resolvedManifestRes.value;
        manifest = JSON.parse(resolvedManifestString);
        if (generateIdIfNotResolved) {
            if (!(0, isUUID_1.default)(teamsAppId)) {
                manifest.id = (0, uuid_1.v4)();
            }
            else {
                manifest.id = teamsAppId;
            }
        }
        return (0, teamsfx_api_1.ok)(manifest);
    }
    extractManifestFromArchivedFile(archivedFile) {
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_3.Constants.MANIFEST_FILE);
        if (!manifestFile) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.FileNotFoundError.name, errors_1.AppStudioError.FileNotFoundError.message(constants_3.Constants.MANIFEST_FILE)));
        }
        const manifestString = manifestFile.getData().toString();
        const manifest = JSON.parse(manifestString);
        return (0, teamsfx_api_1.ok)(manifest);
    }
    /**
     * trim the short name in manifest to make sure it is no more than 25 length
     */
    async trimManifestShortName(projectPath, maxLength = 25) {
        const manifestPath = this.getTeamsAppManifestPath(projectPath);
        if (fs_extra_1.default.pathExistsSync(manifestPath)) {
            const manifest = (await fs_extra_1.default.readJson(manifestPath));
            const shortName = manifest.name.short;
            let hasSuffix = false;
            let trimmedName = shortName;
            if (shortName.includes("${{APP_NAME_SUFFIX}}")) {
                hasSuffix = true;
                trimmedName = shortName.replace("${{APP_NAME_SUFFIX}}", "");
            }
            if (trimmedName.length <= maxLength)
                return (0, teamsfx_api_1.ok)(undefined);
            let newShortName = trimmedName.replace(/\s/g, "").slice(0, maxLength);
            if (hasSuffix) {
                newShortName += "${{APP_NAME_SUFFIX}}";
            }
            manifest.name.short = newShortName;
            await fs_extra_1.default.writeFile(manifestPath, JSON.stringify(manifest, null, 2));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
}
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "ManifestUtils" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], ManifestUtils.prototype, "_readAppManifest", null);
exports.ManifestUtils = ManifestUtils;
exports.manifestUtils = new ManifestUtils();
//# sourceMappingURL=ManifestUtils.js.map
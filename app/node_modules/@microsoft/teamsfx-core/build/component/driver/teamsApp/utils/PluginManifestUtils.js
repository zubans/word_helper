"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.pluginManifestUtils = exports.PluginManifestUtils = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const common_1 = require("../../../../error/common");
const strip_bom_1 = tslib_1.__importDefault(require("strip-bom"));
const path_1 = tslib_1.__importDefault(require("path"));
const ManifestUtils_1 = require("./ManifestUtils");
const utils_1 = require("./utils");
const results_1 = require("../results");
const errors_1 = require("../errors");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const constant_1 = require("../../../configManager/constant");
const os_1 = require("os");
const envFunctionUtils_1 = require("../../../utils/envFunctionUtils");
const utils_2 = require("../../../../common/utils");
class PluginManifestUtils {
    async readPluginManifestFile(path) {
        if (!(await fs_extra_1.default.pathExists(path))) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("PluginManifestUtils", path));
        }
        // Be compatible with UTF8-BOM encoding
        // Avoid Unexpected token error at JSON.parse()
        let content = await fs_extra_1.default.readFile(path, { encoding: "utf-8" });
        content = (0, strip_bom_1.default)(content);
        try {
            const manifest = JSON.parse(content);
            return (0, teamsfx_api_1.ok)(manifest);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.JSONSyntaxError(path, e, "PluginManifestUtils"));
        }
    }
    /**
     * Get plugin manifest with env value filled.
     * @param path path of declaraitve Copilot
     * @returns resolved manifest
     */
    async getManifest(path, context) {
        const manifestRes = await this.readPluginManifestFile(path);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        // Add environment variable keys to telemetry
        const resolvedManifestRes = await (0, utils_1.getResolvedManifest)(JSON.stringify(manifestRes.value), path, envFunctionUtils_1.ManifestType.PluginManifest, context);
        if (resolvedManifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(resolvedManifestRes.error);
        }
        const resolvedManifestString = resolvedManifestRes.value;
        return (0, teamsfx_api_1.ok)(JSON.parse(resolvedManifestString));
    }
    async validateAgainstSchema(plugin, path, context) {
        const manifestRes = await this.getManifest(path, context);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        try {
            const res = await teamsfx_api_1.ManifestUtil.validateManifest(manifestRes.value);
            return (0, teamsfx_api_1.ok)({
                id: plugin.id,
                filePath: path,
                validationResult: res,
            });
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                (0, localizeUtils_1.getLocalizedString)("error.appstudio.validateFetchSchemaFailed", manifestRes.value.$schema, e.message),
            ])));
        }
    }
    async getApiSpecFilePathFromTeamsManifest(manifest, manifestPath) {
        const pluginFilePathRes = await ManifestUtils_1.manifestUtils.getPluginFilePath(manifest, manifestPath);
        if (pluginFilePathRes.isErr()) {
            return (0, teamsfx_api_1.err)(pluginFilePathRes.error);
        }
        const pluginFilePath = pluginFilePathRes.value;
        const pluginContentRes = await this.readPluginManifestFile(pluginFilePath);
        if (pluginContentRes.isErr()) {
            return (0, teamsfx_api_1.err)(pluginContentRes.error);
        }
        const apiSpecFiles = await this.getApiSpecFilePathFromPlugin(pluginContentRes.value, pluginFilePath);
        return (0, teamsfx_api_1.ok)(apiSpecFiles);
    }
    logValidationErrors(validationRes, platform) {
        const validationErrors = validationRes.validationResult;
        const filePath = validationRes.filePath;
        if (validationErrors.length === 0) {
            return "";
        }
        if (platform !== teamsfx_api_1.Platform.CLI) {
            const errors = validationErrors
                .map((error) => {
                return `${constant_1.SummaryConstant.Failed} ${error}`;
            })
                .join(os_1.EOL);
            return ((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validatePluginManifest.checkPath", filePath) +
                os_1.EOL +
                errors);
        }
        else {
            const outputMessage = [];
            outputMessage.push({
                content: (0, localizeUtils_1.getDefaultString)("driver.teamsApp.summary.validatePluginManifest.checkPath", filePath) +
                    "\n",
                color: teamsfx_api_1.Colors.BRIGHT_WHITE,
            });
            validationErrors.map((error) => {
                outputMessage.push({ content: `${constant_1.SummaryConstant.Failed} `, color: teamsfx_api_1.Colors.BRIGHT_RED });
                outputMessage.push({
                    content: `${error}\n`,
                    color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                });
            });
            return outputMessage;
        }
    }
    async getDefaultNextAvailableApiSpecPath(apiSpecPath, apiSpecFolder, apiSpecFileName, isKiotaIntegration = false) {
        let isYaml = false;
        try {
            isYaml = !(await (0, utils_2.isJsonSpecFile)(apiSpecPath));
        }
        catch (e) { }
        let openApiSpecFileName = apiSpecFileName !== null && apiSpecFileName !== void 0 ? apiSpecFileName : (isYaml ? teamsfx_api_1.DefaultApiSpecYamlFileName : teamsfx_api_1.DefaultApiSpecJsonFileName);
        // Check if the default file name already exists
        if (!(await fs_extra_1.default.pathExists(path_1.default.join(apiSpecFolder, openApiSpecFileName)))) {
            return path_1.default.join(apiSpecFolder, openApiSpecFileName);
        }
        const openApiSpecFileNamePrefix = openApiSpecFileName.split(".")[0];
        const openApiSpecFileType = openApiSpecFileName.split(".")[1];
        let apiSpecFileNameSuffix = 1;
        openApiSpecFileName = this.getApiSpecFileName(openApiSpecFileNamePrefix, openApiSpecFileType, apiSpecFileNameSuffix, isKiotaIntegration);
        while (await fs_extra_1.default.pathExists(path_1.default.join(apiSpecFolder, openApiSpecFileName))) {
            apiSpecFileNameSuffix++;
            openApiSpecFileName = this.getApiSpecFileName(openApiSpecFileNamePrefix, openApiSpecFileType, apiSpecFileNameSuffix, isKiotaIntegration);
        }
        const openApiSpecFilePath = path_1.default.join(apiSpecFolder, openApiSpecFileName);
        return openApiSpecFilePath;
    }
    getApiSpecFileName(openApiSpecFileNamePrefix, openApiSpecFileType, apiSpecFileNameSuffix, isKiotaIntegration) {
        let openApiSpecFileName;
        if (isKiotaIntegration) {
            const apiSpecNameSplit = openApiSpecFileNamePrefix.split("-");
            openApiSpecFileName = `${apiSpecNameSplit[0]}_${apiSpecFileNameSuffix}-${apiSpecNameSplit[1]}.${openApiSpecFileType}`;
        }
        else {
            openApiSpecFileName = `${openApiSpecFileNamePrefix}_${apiSpecFileNameSuffix}.${openApiSpecFileType}`;
        }
        return openApiSpecFileName;
    }
    async getApiSpecFilePathFromPlugin(plugin, pluginPath) {
        var _a;
        const runtimes = plugin.runtimes;
        const files = [];
        if (!runtimes) {
            return files;
        }
        for (const runtime of runtimes) {
            if (runtime.type === "OpenApi" && ((_a = runtime.spec) === null || _a === void 0 ? void 0 : _a.url)) {
                const specFile = path_1.default.resolve(path_1.default.dirname(pluginPath), runtime.spec.url);
                if (await fs_extra_1.default.pathExists(specFile)) {
                    files.push(specFile);
                }
            }
        }
        return files;
    }
}
exports.PluginManifestUtils = PluginManifestUtils;
exports.pluginManifestUtils = new PluginManifestUtils();
//# sourceMappingURL=PluginManifestUtils.js.map
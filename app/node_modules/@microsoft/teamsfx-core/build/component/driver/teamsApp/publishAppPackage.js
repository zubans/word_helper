"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublishAppPackageDriver = exports.actionName = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const typedi_1 = require("typedi");
const teamsDevPortalClient_1 = require("../../../client/teamsDevPortalClient");
const constants_1 = require("../../../common/constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../../error/common");
const common_2 = require("../../utils/common");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const wrapUtil_1 = require("../util/wrapUtil");
const constants_2 = require("./constants");
const telemetry_1 = require("./utils/telemetry");
exports.actionName = "teamsApp/publishAppPackage";
const defaultOutputNames = {
    publishedAppId: "TEAMS_APP_PUBLISHED_APP_ID",
};
let PublishAppPackageDriver = class PublishAppPackageDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.description.publishDriver");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.progressBar.publishTeamsAppStep2.2");
    }
    async execute(args, context, outputEnvVarNames) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, exports.actionName, exports.actionName);
        const res = await this.publish(args, wrapContext, outputEnvVarNames);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async publish(args, context, outputEnvVarNames) {
        var _a, _b, _c;
        const argsValidationResult = this.validateArgs(args);
        if (argsValidationResult.isErr()) {
            return (0, teamsfx_api_1.err)(argsValidationResult.error);
        }
        if (!outputEnvVarNames) {
            outputEnvVarNames = new Map(Object.entries(defaultOutputNames));
        }
        const appPackagePath = (0, common_2.getAbsolutePath)(args.appPackagePath, context.projectPath);
        if (!(await fs_extra_1.default.pathExists(appPackagePath))) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(exports.actionName, appPackagePath, "https://aka.ms/teamsfx-actions/teamsapp-publish"));
        }
        const archivedFile = await fs_extra_1.default.readFile(appPackagePath);
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_2.Constants.MANIFEST_FILE);
        if (!manifestFile) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(exports.actionName, constants_2.Constants.MANIFEST_FILE, "https://aka.ms/teamsfx-actions/teamsapp-publish"));
        }
        const manifestString = manifestFile.getData().toString();
        const manifest = JSON.parse(manifestString);
        // manifest.id === externalID
        const appStudioTokenRes = await context.m365TokenProvider.getAccessToken({
            scopes: constants_1.AppStudioScopes,
        });
        if (appStudioTokenRes.isErr()) {
            return (0, teamsfx_api_1.err)(appStudioTokenRes.error);
        }
        let result;
        const message = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.progressBar.publishTeamsAppStep1");
        context.addSummary(message);
        try {
            const existApp = await teamsDevPortalClient_1.teamsDevPortalClient.getStaggedApp(appStudioTokenRes.value, manifest.id);
            if (existApp) {
                context.addSummary((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.publishTeamsAppExists", manifest.id));
                let executePublishUpdate = false;
                let description = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.pubWarn", existApp.displayName, existApp.publishingState);
                if (existApp.lastModifiedDateTime) {
                    description =
                        description +
                            (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.lastModified", (_a = existApp.lastModifiedDateTime) === null || _a === void 0 ? void 0 : _a.toLocaleString());
                }
                description =
                    description + (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.updatePublihsedAppConfirm");
                const confirm = (0, localizeUtils_1.getLocalizedString)("core.option.confirm");
                const res = await ((_b = context.ui) === null || _b === void 0 ? void 0 : _b.showMessage("warn", description, true, confirm));
                if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === confirm)
                    executePublishUpdate = true;
                if (executePublishUpdate) {
                    const message = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.progressBar.publishTeamsAppStep2.1");
                    context.addSummary(message);
                    context.logProvider.debug(message);
                    const appId = await teamsDevPortalClient_1.teamsDevPortalClient.publishTeamsAppUpdate(appStudioTokenRes.value, manifest.id, archivedFile);
                    result = new Map([[outputEnvVarNames.get("publishedAppId"), appId]]);
                    (0, lodash_1.merge)(context.telemetryProperties, {
                        [telemetry_1.TelemetryPropertyKey.updateExistingApp]: "true",
                        [telemetry_1.TelemetryPropertyKey.publishedAppId]: appId,
                    });
                }
                else {
                    return (0, teamsfx_api_1.err)(new common_1.UserCancelError(exports.actionName));
                }
            }
            else {
                context.addSummary((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.publishTeamsAppNotExists", manifest.id));
                const message = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.progressBar.publishTeamsAppStep2.2");
                context.addSummary(message);
                context.logProvider.debug(message);
                const appId = await teamsDevPortalClient_1.teamsDevPortalClient.publishTeamsApp(appStudioTokenRes.value, manifest.id, archivedFile);
                result = new Map([[outputEnvVarNames.get("publishedAppId"), appId]]);
                (0, lodash_1.merge)(context.telemetryProperties, {
                    [telemetry_1.TelemetryPropertyKey.updateExistingApp]: "false",
                });
            }
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(e);
        }
        context.logProvider.info(`Publish success!`);
        context.addSummary((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.publishTeamsAppSuccess", manifest.id));
        if (context.platform === teamsfx_api_1.Platform.CLI) {
            const msg = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.publishSucceedNotice.cli", manifest.name.short, constants_2.Constants.TEAMS_ADMIN_PORTAL, constants_2.Constants.TEAMS_MANAGE_APP_DOC);
            (_c = context.ui) === null || _c === void 0 ? void 0 : _c.showMessage("info", msg, false);
        }
        return (0, teamsfx_api_1.ok)(result);
    }
    validateArgs(args) {
        const invalidParams = [];
        if (!args || !args.appPackagePath) {
            invalidParams.push("appPackagePath");
        }
        if (invalidParams.length > 0) {
            return (0, teamsfx_api_1.err)(new common_1.InvalidActionInputError(exports.actionName, invalidParams, "https://aka.ms/teamsfx-actions/teamsapp-publish"));
        }
        else {
            return (0, teamsfx_api_1.ok)(undefined);
        }
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(exports.actionName, exports.actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext,
        Map]),
    tslib_1.__metadata("design:returntype", Promise)
], PublishAppPackageDriver.prototype, "publish", null);
PublishAppPackageDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(exports.actionName)
], PublishAppPackageDriver);
exports.PublishAppPackageDriver = PublishAppPackageDriver;
//# sourceMappingURL=publishAppPackage.js.map
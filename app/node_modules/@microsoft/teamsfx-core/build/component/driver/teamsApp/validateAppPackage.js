"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidateAppPackageDriver = void 0;
const tslib_1 = require("tslib");
/**
 * @author Ning Liu <nliu@microsoft.com>
 */
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const os_1 = require("os");
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const teamsDevPortalClient_1 = require("../../../client/teamsDevPortalClient");
const constants_1 = require("../../../common/constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../../error/common");
const constant_1 = require("../../configManager/constant");
const metadataUtil_1 = require("../../utils/metadataUtil");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const wrapUtil_1 = require("../util/wrapUtil");
const constants_2 = require("./constants");
const errors_1 = require("./errors");
const results_1 = require("./results");
const telemetry_1 = require("./utils/telemetry");
const actionName = "teamsApp/validateAppPackage";
let ValidateAppPackageDriver = class ValidateAppPackageDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.description.validateDriver");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.validateAppPackage.progressBar.message");
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.validate(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async validate(args, context) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        const result = this.validateArgs(args);
        if (result.isErr()) {
            return (0, teamsfx_api_1.err)(result.error);
        }
        let appPackagePath = args.appPackagePath;
        if (!path.isAbsolute(appPackagePath)) {
            appPackagePath = path.join(context.projectPath, appPackagePath);
        }
        if (!(await fs_extra_1.default.pathExists(appPackagePath))) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(actionName, appPackagePath));
        }
        const archivedFile = await fs_extra_1.default.readFile(appPackagePath);
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_2.Constants.MANIFEST_FILE);
        if (manifestFile) {
            const manifestContent = manifestFile.getData().toString();
            const manifest = JSON.parse(manifestContent);
            metadataUtil_1.metadataUtil.parseManifest(manifest);
            // Add common properties like isCopilotPlugin: boolean
            const manifestTelemetries = teamsfx_api_1.ManifestUtil.parseCommonTelemetryProperties(manifest);
            (0, lodash_1.merge)(context.telemetryProperties, manifestTelemetries);
        }
        const appStudioTokenRes = await context.m365TokenProvider.getAccessToken({
            scopes: constants_1.AppStudioScopes,
        });
        if (appStudioTokenRes.isErr()) {
            return (0, teamsfx_api_1.err)(appStudioTokenRes.error);
        }
        const appStudioToken = appStudioTokenRes.value;
        try {
            const validationResult = await teamsDevPortalClient_1.teamsDevPortalClient.partnerCenterAppPackageValidation(appStudioToken, archivedFile);
            if (context.platform === teamsfx_api_1.Platform.CLI) {
                const outputMessage = [
                    {
                        content: "Teams Toolkit has checked against all validation rules:\n\nSummary: \n",
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    },
                ];
                if (validationResult.errors.length > 0) {
                    outputMessage.push({
                        content: `${validationResult.errors.length} failed, `,
                        color: teamsfx_api_1.Colors.BRIGHT_RED,
                    });
                    (0, lodash_1.merge)(context.telemetryProperties, {
                        [telemetry_1.TelemetryPropertyKey.validationErrors]: validationResult.errors
                            .map((x) => x.title)
                            .join(";"),
                    });
                }
                if (validationResult.warnings.length > 0) {
                    outputMessage.push({
                        content: `${validationResult.warnings.length} warning` +
                            (validationResult.warnings.length > 1 ? "s" : "") +
                            ", ",
                        color: teamsfx_api_1.Colors.BRIGHT_YELLOW,
                    });
                    (0, lodash_1.merge)(context.telemetryProperties, {
                        [telemetry_1.TelemetryPropertyKey.validationWarnings]: validationResult.warnings
                            .map((x) => x.title)
                            .join(";"),
                    });
                }
                outputMessage.push({
                    content: `${validationResult.notes.length} passed.\n`,
                    color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                });
                if (validationResult.errors.length > 0 || validationResult.warnings.length > 0) {
                    outputMessage.push({
                        content: (0, localizeUtils_1.getDefaultString)("driver.teamsApp.summary.validate.checkPath", args.appPackagePath),
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    });
                }
                validationResult.errors.map((error) => {
                    outputMessage.push({ content: `${constant_1.SummaryConstant.Failed} `, color: teamsfx_api_1.Colors.BRIGHT_RED });
                    outputMessage.push({
                        content: error.id === constants_2.GeneralValidationErrorId && error.code
                            ? `${this.processErrorCode(error.code)}`
                            : `${error.content} \nFile path: ${error.filePath}, title: ${error.title}`,
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    });
                    if (error.helpUrl) {
                        outputMessage.push({
                            content: `\n${(0, localizeUtils_1.getLocalizedString)("core.option.learnMore")}: `,
                            color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                        });
                        outputMessage.push({ content: `${error.helpUrl}\n`, color: teamsfx_api_1.Colors.BRIGHT_CYAN });
                    }
                });
                validationResult.warnings.map((warning) => {
                    outputMessage.push({
                        content: `${constant_1.SummaryConstant.NotExecuted} `,
                        color: teamsfx_api_1.Colors.BRIGHT_YELLOW,
                    });
                    outputMessage.push({
                        content: `${warning.content}  \nFile path: ${warning.filePath}, title: ${warning.title}`,
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    });
                    if (warning.helpUrl) {
                        outputMessage.push({
                            content: `\n${(0, localizeUtils_1.getLocalizedString)("core.option.learnMore")}: `,
                            color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                        });
                        outputMessage.push({ content: `${warning.helpUrl}\n`, color: teamsfx_api_1.Colors.BRIGHT_CYAN });
                    }
                });
                validationResult.notes.map((note) => {
                    // It might be undefined in some cases
                    if (note.content) {
                        outputMessage.push({
                            content: `${constant_1.SummaryConstant.Succeeded} `,
                            color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                        });
                        outputMessage.push({
                            content: `${note.content}\n`,
                            color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                        });
                    }
                });
                (_a = context.ui) === null || _a === void 0 ? void 0 : _a.showMessage("info", outputMessage, false);
                if (validationResult.errors.length > 0) {
                    const message = `Teams Toolkit has completed checking your app package against validation rules. ${validationResult.errors.length} failed.`;
                    return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, [
                        message,
                        message,
                    ]));
                }
                else {
                    return (0, teamsfx_api_1.ok)(new Map());
                }
            }
            else {
                // logs in output window
                const errors = validationResult.errors
                    .map((error) => {
                    const errorContent = error.id === constants_2.GeneralValidationErrorId && error.code
                        ? this.processErrorCode(error.code)
                        : `${error.content} \n${(0, localizeUtils_1.getLocalizedString)("error.teamsApp.validate.details", error.filePath, error.title)}`;
                    let message = `${constant_1.SummaryConstant.Failed} ${errorContent}\n`;
                    if (error.helpUrl) {
                        message += (0, localizeUtils_1.getLocalizedString)("core.option.learnMore", error.helpUrl);
                    }
                    return message;
                })
                    .join(os_1.EOL);
                const warnings = validationResult.warnings
                    .map((warning) => {
                    let message = `${constant_1.SummaryConstant.NotExecuted} ${warning.content} \n${(0, localizeUtils_1.getLocalizedString)("error.teamsApp.validate.details", warning.filePath, warning.title)} \n`;
                    if (warning.helpUrl) {
                        message += (0, localizeUtils_1.getLocalizedString)("core.option.learnMore", warning.helpUrl);
                    }
                    return message;
                })
                    .join(os_1.EOL);
                const notes = validationResult.notes
                    .filter((note) => {
                    return note.content !== undefined;
                })
                    .map((note) => {
                    return `${constant_1.SummaryConstant.Succeeded} ${note.content}`;
                })
                    .join(os_1.EOL);
                const passed = validationResult.notes.length;
                const failed = validationResult.errors.length;
                const warns = validationResult.warnings.length;
                const summaryStr = [];
                if (failed > 0) {
                    summaryStr.push((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.failed", failed));
                    (0, lodash_1.merge)(context.telemetryProperties, {
                        [telemetry_1.TelemetryPropertyKey.validationErrors]: validationResult.errors
                            .map((x) => x.title)
                            .join(";"),
                    });
                }
                if (warns > 0) {
                    summaryStr.push((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.warning", warns) +
                        (warns > 1 ? "s" : ""));
                    (0, lodash_1.merge)(context.telemetryProperties, {
                        [telemetry_1.TelemetryPropertyKey.validationWarnings]: validationResult.warnings
                            .map((x) => x.title)
                            .join(";"),
                    });
                }
                if (passed > 0) {
                    summaryStr.push((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.succeed", passed));
                }
                const outputMessage = os_1.EOL +
                    (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate", summaryStr.join(", "), errors.length > 0 || warnings.length > 0
                        ? (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.checkPath", args.appPackagePath)
                        : "", errors, warnings, path.resolve((_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.getLogFilePath()));
                (_c = context.logProvider) === null || _c === void 0 ? void 0 : _c.info(outputMessage);
                // logs in log file
                await ((_d = context.logProvider) === null || _d === void 0 ? void 0 : _d.logInFile(teamsfx_api_1.LogLevel.Info, `${outputMessage}\n${errors}\n${warnings}\n${notes}`));
                const defaultMesage = (0, localizeUtils_1.getDefaultString)("driver.teamsApp.validate.result", summaryStr.join(", "));
                const displayMessage = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.validate.result.display", summaryStr.join(", "));
                if (args.showMessage) {
                    // For non-lifecycle commands, just show the message
                    if (validationResult.errors.length > 0) {
                        return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, [
                            defaultMesage,
                            displayMessage,
                        ]));
                    }
                    else if (validationResult.warnings.length > 0) {
                        (_e = context.ui) === null || _e === void 0 ? void 0 : _e.showMessage("warn", displayMessage, false);
                    }
                    else {
                        (_f = context.ui) === null || _f === void 0 ? void 0 : _f.showMessage("info", displayMessage, false);
                    }
                }
                else {
                    // For lifecycle like provision, stop-on-error
                    if (validationResult.errors.length > 0) {
                        return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, [
                            defaultMesage,
                            displayMessage,
                        ]));
                    }
                }
            }
        }
        catch (e) {
            (_g = context.logProvider) === null || _g === void 0 ? void 0 : _g.warning((0, localizeUtils_1.getLocalizedString)("error.teamsApp.validate.apiFailed", e.message));
            (_h = context.ui) === null || _h === void 0 ? void 0 : _h.showMessage("warn", (0, localizeUtils_1.getLocalizedString)("error.teamsApp.validate.apiFailed.display"), false);
        }
        return (0, teamsfx_api_1.ok)(new Map());
    }
    validateArgs(args) {
        if (!args || !args.appPackagePath) {
            return (0, teamsfx_api_1.err)(new common_1.InvalidActionInputError(actionName, ["appPackagePath"], "https://aka.ms/teamsfx-actions/teamsapp-validate"));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    processErrorCode(errorCode) {
        if (errorCode.startsWith("Invalid TypeB ")) {
            // A temporary solution to update the error message.
            return errorCode.substring(0, 8) + "API " + errorCode.substring(14);
        }
        else {
            return errorCode;
        }
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext]),
    tslib_1.__metadata("design:returntype", Promise)
], ValidateAppPackageDriver.prototype, "validate", null);
ValidateAppPackageDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(actionName)
], ValidateAppPackageDriver);
exports.ValidateAppPackageDriver = ValidateAppPackageDriver;
//# sourceMappingURL=validateAppPackage.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAppPackage = exports.updateTeamsAppV3ForPublish = exports.updateManifestV3 = exports.checkIfAppInDifferentAcountSameTenant = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const set_1 = tslib_1.__importDefault(require("lodash/set"));
const path = tslib_1.__importStar(require("path"));
const path_1 = require("path");
const typedi_1 = require("typedi");
const util = tslib_1.__importStar(require("util"));
const isUUID_1 = tslib_1.__importDefault(require("validator/lib/isUUID"));
const teamsDevPortalClient_1 = require("../../../client/teamsDevPortalClient");
const constants_1 = require("../../../common/constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../../error/common");
const constants_2 = require("../../../question/constants");
const envUtil_1 = require("../../utils/envUtil");
const configure_1 = require("./configure");
const constants_3 = require("./constants");
const createAppPackage_1 = require("./createAppPackage");
const errors_1 = require("./errors");
const results_1 = require("./results");
const ManifestUtils_1 = require("./utils/ManifestUtils");
const utils_1 = require("../../../common/utils");
async function checkIfAppInDifferentAcountSameTenant(teamsAppId, tokenProvider, logger) {
    const appStudioTokenRes = await tokenProvider.getAccessToken({
        scopes: constants_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return (0, teamsfx_api_1.err)(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    try {
        await teamsDevPortalClient_1.teamsDevPortalClient.getApp(appStudioToken, teamsAppId);
    }
    catch (error) {
        if (error.message && error.message.includes("404")) {
            const exists = await teamsDevPortalClient_1.teamsDevPortalClient.checkExistsInTenant(appStudioToken, teamsAppId);
            return (0, teamsfx_api_1.ok)(exists);
        }
    }
    return (0, teamsfx_api_1.ok)(false);
}
exports.checkIfAppInDifferentAcountSameTenant = checkIfAppInDifferentAcountSameTenant;
async function updateManifestV3(ctx, inputs) {
    var _a, _b, _c;
    const state = {
        ENV_NAME: process.env.TEAMSFX_ENV,
    };
    const manifestTemplatePath = (_a = inputs.manifestTemplatePath) !== null && _a !== void 0 ? _a : ManifestUtils_1.manifestUtils.getTeamsAppManifestPath(inputs.projectPath);
    const manifestFileName = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.BuildFolderName, `manifest.${state.ENV_NAME}.json`);
    // Prepare for driver
    const buildDriver = typedi_1.Container.get(createAppPackage_1.actionName);
    const createAppPackageArgs = generateCreateAppPackageArgs(inputs.projectPath, manifestTemplatePath, state.ENV_NAME);
    const updateTeamsAppArgs = {
        appPackagePath: createAppPackageArgs.outputZipPath,
    };
    const driverContext = (0, utils_1.generateDriverContext)(ctx, inputs);
    await envUtil_1.envUtil.readEnv(inputs.projectPath, state.ENV_NAME);
    // render manifest
    let manifest;
    const manifestResult = await ManifestUtils_1.manifestUtils.getManifestV3(manifestTemplatePath, driverContext);
    if (manifestResult.isErr()) {
        return (0, teamsfx_api_1.err)(manifestResult.error);
    }
    else {
        manifest = manifestResult.value;
    }
    // read built manifest file
    if (!(await fs_extra_1.default.pathExists(manifestFileName)) ||
        !(await fs_extra_1.default.pathExists(createAppPackageArgs.outputZipPath))) {
        const res = (await buildDriver.execute(createAppPackageArgs, driverContext)).result;
        if (res.isErr()) {
            return (0, teamsfx_api_1.err)(res.error);
        }
    }
    const existingManifest = await fs_extra_1.default.readJSON(manifestFileName);
    const teamsAppId = manifest.id;
    delete manifest.id;
    delete existingManifest.id;
    if (!lodash_1.default.isEqual(manifest, existingManifest)) {
        const previewOnly = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.previewOnly");
        const previewUpdate = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.previewAndUpdate");
        const res = await ctx.userInteraction.showMessage("warn", (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.updateManifestTip"), true, previewUpdate, previewOnly);
        if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === previewOnly) {
            return (await buildDriver.execute(createAppPackageArgs, driverContext)).result;
        }
        else if ((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === previewUpdate) {
            await buildDriver.execute(createAppPackageArgs, driverContext);
        }
        else {
            return (0, teamsfx_api_1.err)(new common_1.UserCancelError("appStudio"));
        }
    }
    const appStudioTokenRes = await ctx.tokenProvider.m365TokenProvider.getAccessToken({
        scopes: constants_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return (0, teamsfx_api_1.err)(appStudioTokenRes.error);
    }
    const appStudioToken = appStudioTokenRes.value;
    try {
        const localUpdateTime = process.env.TEAMS_APP_UPDATE_TIME;
        if (localUpdateTime) {
            const app = await teamsDevPortalClient_1.teamsDevPortalClient.getApp(appStudioToken, teamsAppId);
            const devPortalUpdateTime = (_c = (_b = new Date(app.updatedAt)) === null || _b === void 0 ? void 0 : _b.getTime()) !== null && _c !== void 0 ? _c : -1;
            if (new Date(localUpdateTime).getTime() < devPortalUpdateTime) {
                const option = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.overwriteAndUpdate");
                const res = await ctx.userInteraction.showMessage("warn", (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.updateOverwriteTip"), true, option);
                if (!((res === null || res === void 0 ? void 0 : res.isOk()) && res.value === option)) {
                    return (0, teamsfx_api_1.err)(new common_1.UserCancelError("appStudio"));
                }
            }
        }
        const configureDriver = typedi_1.Container.get(configure_1.actionName);
        const result = (await configureDriver.execute(updateTeamsAppArgs, driverContext)).result;
        if (result.isErr()) {
            return (0, teamsfx_api_1.err)(result.error);
        }
        let loginHint = "";
        const accountRes = await ctx.tokenProvider.m365TokenProvider.getJsonObject({
            scopes: constants_1.AppStudioScopes,
        });
        if (accountRes.isOk()) {
            loginHint = accountRes.value.unique_name;
        }
        const url = util.format(constants_3.Constants.DEVELOPER_PORTAL_APP_PACKAGE_URL, teamsAppId, loginHint);
        if (inputs.platform === teamsfx_api_1.Platform.CLI) {
            const message = [
                {
                    content: (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.teamsAppUpdatedCLINotice"),
                    color: teamsfx_api_1.Colors.BRIGHT_GREEN,
                },
                { content: url, color: teamsfx_api_1.Colors.BRIGHT_CYAN },
            ];
            await ctx.userInteraction.showMessage("info", message, false);
        }
        else {
            void ctx.userInteraction
                .showMessage("info", (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.teamsAppUpdatedNotice"), false, (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.viewDeveloperPortal"))
                .then(async (res) => {
                if ((res === null || res === void 0 ? void 0 : res.isOk()) &&
                    res.value === (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.viewDeveloperPortal")) {
                    await ctx.userInteraction.openUrl(url);
                }
            });
        }
        return result;
    }
    catch (error) {
        if (error.message && error.message.includes("404")) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.UpdateManifestWithInvalidAppError.name, errors_1.AppStudioError.UpdateManifestWithInvalidAppError.message(teamsAppId)));
        }
        else {
            return (0, teamsfx_api_1.err)(error);
        }
    }
}
exports.updateManifestV3 = updateManifestV3;
async function updateTeamsAppV3ForPublish(ctx, inputs) {
    var _a;
    let teamsAppId;
    const driverContext = (0, utils_1.generateDriverContext)(ctx, inputs);
    const updateTeamsAppArgs = {
        appPackagePath: inputs[constants_2.QuestionNames.AppPackagePath],
    };
    const zipEntries = new adm_zip_1.default(updateTeamsAppArgs.appPackagePath).getEntries();
    const manifestFile = zipEntries.find((x) => x.entryName === constants_3.Constants.MANIFEST_FILE);
    let validationError;
    if (manifestFile) {
        try {
            const manifestString = manifestFile.getData().toString();
            const manifest = JSON.parse(manifestString);
            if (!manifest.id || !(0, isUUID_1.default)(manifest.id)) {
                validationError = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                    (0, localizeUtils_1.getLocalizedString)("error.appstudio.noManifestId"),
                ]));
            }
            else {
                teamsAppId = manifest.id;
                const validationResult = await teamsfx_api_1.ManifestUtil.validateManifest(manifest);
                if (validationResult.length > 0) {
                    const errMessage = errors_1.AppStudioError.ValidationFailedError.message(validationResult);
                    validationError = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errMessage);
                }
            }
        }
        catch (e) {
            validationError = results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, 
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            errors_1.AppStudioError.ValidationFailedError.message([e.message]));
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
            validationError.stack = e.stack;
        }
    }
    else {
        // missing manifest file
        validationError = new common_1.FileNotFoundError("appManifest", "manifest.json");
    }
    if (validationError) {
        const suggestionDefaultMessage = (0, localizeUtils_1.getDefaultString)("error.appstudio.publishInDevPortalSuggestionForValidationError");
        const suggestionMessage = (0, localizeUtils_1.getLocalizedString)("error.appstudio.publishInDevPortalSuggestionForValidationError");
        validationError.message += ` ${suggestionDefaultMessage}`;
        validationError.displayMessage += ` ${suggestionMessage}`;
        (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error((0, localizeUtils_1.getLocalizedString)("plugins.appstudio.validationFailedNotice"));
        return (0, teamsfx_api_1.err)(validationError);
    }
    const configureDriver = typedi_1.Container.get(configure_1.actionName);
    const result = (await configureDriver.execute(updateTeamsAppArgs, driverContext)).result;
    if (result.isErr()) {
        return (0, teamsfx_api_1.err)(result.error);
    }
    return (0, teamsfx_api_1.ok)(teamsAppId);
}
exports.updateTeamsAppV3ForPublish = updateTeamsAppV3ForPublish;
async function getAppPackage(teamsAppId, m365TokenProvider, logProvider) {
    const appStudioTokenRes = await m365TokenProvider.getAccessToken({
        scopes: constants_1.AppStudioScopes,
    });
    if (appStudioTokenRes.isErr()) {
        return (0, teamsfx_api_1.err)(appStudioTokenRes.error);
    }
    try {
        const data = await teamsDevPortalClient_1.teamsDevPortalClient.getAppPackage(appStudioTokenRes.value, teamsAppId);
        const appPackage = {};
        const buffer = Buffer.from(data, "base64");
        const zip = new adm_zip_1.default(buffer);
        const zipEntries = zip.getEntries(); // an array of ZipEntry records
        zipEntries === null || zipEntries === void 0 ? void 0 : zipEntries.forEach(function (zipEntry) {
            const data = zipEntry.getData();
            const name = zipEntry.entryName.toLowerCase();
            switch (name) {
                case "manifest.json":
                    appPackage.manifest = data;
                    break;
                case "color.png":
                    appPackage.icons = Object.assign(Object.assign({}, appPackage.icons), { color: data });
                    break;
                case "outline.png":
                    appPackage.icons = Object.assign(Object.assign({}, appPackage.icons), { outline: data });
                    break;
                default:
                    const ext = (0, path_1.extname)(name);
                    const base = (0, path_1.basename)(name, ext);
                    // Since we don't support scene features, the remaining files are json files for language.
                    if (constants_3.supportedLanguageCodes.findIndex((code) => code === base) > -1) {
                        (0, set_1.default)(appPackage, ["languages", base], data);
                    }
                    else {
                        logProvider === null || logProvider === void 0 ? void 0 : logProvider.warning((0, localizeUtils_1.getLocalizedString)("plugins.appstudio.unprocessedFile", name));
                    }
            }
        });
        return (0, teamsfx_api_1.ok)(appPackage);
    }
    catch (e) {
        return (0, teamsfx_api_1.err)(e);
    }
}
exports.getAppPackage = getAppPackage;
function generateCreateAppPackageArgs(projectPath, manifestTemplatePath, envName) {
    const manifestFileName = path.join(projectPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.BuildFolderName, `manifest.${envName}.json`);
    return {
        manifestPath: manifestTemplatePath,
        outputZipPath: path.join(projectPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.BuildFolderName, `appPackage.${envName}.zip`),
        outputJsonPath: manifestFileName,
    };
}
//# sourceMappingURL=appStudio.js.map
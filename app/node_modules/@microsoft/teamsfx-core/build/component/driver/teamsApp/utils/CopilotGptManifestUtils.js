"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.copilotGptManifestUtils = exports.CopilotGptManifestUtils = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const common_1 = require("../../../../error/common");
const strip_bom_1 = tslib_1.__importDefault(require("strip-bom"));
const utils_1 = require("./utils");
const results_1 = require("../results");
const errors_1 = require("../errors");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const path_1 = tslib_1.__importDefault(require("path"));
const PluginManifestUtils_1 = require("./PluginManifestUtils");
const constant_1 = require("../../../configManager/constant");
const os_1 = require("os");
const envFunctionUtils_1 = require("../../../utils/envFunctionUtils");
const ManifestUtils_1 = require("./ManifestUtils");
class CopilotGptManifestUtils {
    async readCopilotGptManifestFile(path) {
        if (!(await fs_extra_1.default.pathExists(path))) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError("CopilotGptManifestUtils", path));
        }
        // Be compatible with UTF8-BOM encoding
        // Avoid Unexpected token error at JSON.parse()
        let content = await fs_extra_1.default.readFile(path, { encoding: "utf-8" });
        content = (0, strip_bom_1.default)(content);
        try {
            const manifest = JSON.parse(content);
            return (0, teamsfx_api_1.ok)(manifest);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.JSONSyntaxError(path, e, "CopilotGptManifestUtils"));
        }
    }
    /**
     * Get Declarative Copilot Manifest with env value filled.
     * @param path path of declaraitve Copilot
     * @returns resolved manifest
     */
    async getManifest(path, context) {
        const manifestRes = await this.readCopilotGptManifestFile(path);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        // Add environment variable keys to telemetry
        const resolvedManifestRes = await (0, utils_1.getResolvedManifest)(JSON.stringify(manifestRes.value), path, envFunctionUtils_1.ManifestType.DeclarativeCopilotManifest, context);
        if (resolvedManifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(resolvedManifestRes.error);
        }
        const resolvedManifestString = resolvedManifestRes.value;
        return (0, teamsfx_api_1.ok)(JSON.parse(resolvedManifestString));
    }
    async writeCopilotGptManifestFile(manifest, path) {
        const content = JSON.stringify(manifest, undefined, 4);
        try {
            await fs_extra_1.default.writeFile(path, content);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.WriteFileError(e, "copilotGptManifestUtils"));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
    async validateAgainstSchema(declaraitveCopilot, manifestPath, context) {
        var _a;
        const manifestRes = await this.getManifest(manifestPath, context);
        if (manifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(manifestRes.error);
        }
        const manifest = manifestRes.value;
        try {
            const manifestValidationRes = await teamsfx_api_1.ManifestUtil.validateManifest(manifestRes.value);
            const res = {
                id: declaraitveCopilot.id,
                filePath: manifestPath,
                validationResult: manifestValidationRes,
                actionValidationResult: [],
            };
            if ((_a = manifest.actions) === null || _a === void 0 ? void 0 : _a.length) {
                // action
                for (const action of manifest.actions) {
                    const actionPath = path_1.default.join(path_1.default.dirname(manifestPath), action.file);
                    const actionValidationRes = await PluginManifestUtils_1.pluginManifestUtils.validateAgainstSchema(action, actionPath, context);
                    if (actionValidationRes.isErr()) {
                        return (0, teamsfx_api_1.err)(actionValidationRes.error);
                    }
                    else {
                        res.actionValidationResult.push(actionValidationRes.value);
                    }
                }
            }
            return (0, teamsfx_api_1.ok)(res);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.ValidationFailedError.name, errors_1.AppStudioError.ValidationFailedError.message([
                (0, localizeUtils_1.getLocalizedString)("error.appstudio.validateFetchSchemaFailed", manifestRes.value.$schema, e.message),
            ])));
        }
    }
    async getManifestPath(teamsManifestPath) {
        var _a, _b, _c;
        const teamsManifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(teamsManifestPath);
        if (teamsManifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(teamsManifestRes.error);
        }
        const filePath = teamsManifestRes.value.copilotExtensions
            ? (_a = teamsManifestRes.value.copilotExtensions.declarativeCopilots) === null || _a === void 0 ? void 0 : _a[0].file
            : (_c = (_b = teamsManifestRes.value.copilotAgents) === null || _b === void 0 ? void 0 : _b.declarativeAgents) === null || _c === void 0 ? void 0 : _c[0].file;
        if (!filePath) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.TeamsAppRequiredPropertyMissingError.name, errors_1.AppStudioError.TeamsAppRequiredPropertyMissingError.message("copilotExtensions.declarativeCopilots.file", teamsManifestPath)));
        }
        else {
            return (0, teamsfx_api_1.ok)(path_1.default.resolve(path_1.default.dirname(teamsManifestPath), filePath));
        }
    }
    async addAction(copilotGptPath, id, pluginFile) {
        var _a, _b;
        const gptManifestRes = await exports.copilotGptManifestUtils.readCopilotGptManifestFile(copilotGptPath);
        if (gptManifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(gptManifestRes.error);
        }
        else {
            const gptManifest = gptManifestRes.value;
            if (!gptManifest.actions) {
                gptManifest.actions = [];
            }
            (_a = gptManifest.actions) === null || _a === void 0 ? void 0 : _a.push({
                id,
                file: pluginFile,
            });
            const actionPath = path_1.default.join(path_1.default.dirname(copilotGptPath), pluginFile);
            const actionManifest = await fs_extra_1.default.readJson(actionPath);
            const conversationStarters = (_b = actionManifest.capabilities) === null || _b === void 0 ? void 0 : _b.conversation_starters;
            if (conversationStarters) {
                if (!gptManifest.conversation_starters) {
                    gptManifest.conversation_starters = [];
                }
                for (const starter of conversationStarters) {
                    if (gptManifest.conversation_starters.length >= 6) {
                        break;
                    }
                    if (!gptManifest.conversation_starters.some((existingStarter) => existingStarter.text === starter.text)) {
                        gptManifest.conversation_starters.push(starter);
                    }
                }
            }
            const updateGptManifestRes = await exports.copilotGptManifestUtils.writeCopilotGptManifestFile(gptManifest, copilotGptPath);
            if (updateGptManifestRes.isErr()) {
                return (0, teamsfx_api_1.err)(updateGptManifestRes.error);
            }
            else {
                return (0, teamsfx_api_1.ok)(gptManifest);
            }
        }
    }
    logValidationErrors(validationRes, platform, pluginPath) {
        const validationErrors = validationRes.validationResult;
        const filePath = validationRes.filePath;
        const hasDeclarativeCopilotError = validationErrors.length > 0;
        let hasActionError = false;
        for (const actionValidationRes of validationRes.actionValidationResult) {
            if (actionValidationRes.validationResult.length > 0) {
                hasActionError = true;
                break;
            }
        }
        if (!hasDeclarativeCopilotError && !hasActionError) {
            return "";
        }
        if (platform !== teamsfx_api_1.Platform.CLI) {
            let outputMessage = "";
            if (hasDeclarativeCopilotError) {
                const errors = validationErrors
                    .map((error) => {
                    return `${constant_1.SummaryConstant.Failed} ${error}`;
                })
                    .join(os_1.EOL);
                outputMessage +=
                    (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateDeclarativeCopilotManifest.checkPath", filePath) +
                        os_1.EOL +
                        errors;
            }
            for (const actionValidationRes of validationRes.actionValidationResult) {
                if (!pluginPath || actionValidationRes.filePath !== pluginPath) {
                    // do not output validation result of the Declarative Copilot if same file has been validated when validating plugin manifest.
                    const actionValidationMessage = PluginManifestUtils_1.pluginManifestUtils.logValidationErrors(actionValidationRes, platform);
                    if (actionValidationMessage) {
                        outputMessage += (!outputMessage ? "" : os_1.EOL) + actionValidationMessage;
                    }
                }
            }
            return outputMessage;
        }
        else {
            const outputMessage = [];
            if (hasDeclarativeCopilotError) {
                outputMessage.push({
                    content: (0, localizeUtils_1.getDefaultString)("driver.teamsApp.summary.validateDeclarativeCopilotManifest.checkPath", filePath) + "\n",
                    color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                });
                validationErrors.map((error) => {
                    outputMessage.push({ content: `${constant_1.SummaryConstant.Failed} `, color: teamsfx_api_1.Colors.BRIGHT_RED });
                    outputMessage.push({
                        content: `${error}\n`,
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    });
                });
            }
            for (const actionValidationRes of validationRes.actionValidationResult) {
                if (!pluginPath || actionValidationRes.filePath !== pluginPath) {
                    const actionValidationMessage = PluginManifestUtils_1.pluginManifestUtils.logValidationErrors(actionValidationRes, platform);
                    if (actionValidationMessage) {
                        outputMessage.push(...actionValidationMessage);
                    }
                }
            }
            return outputMessage;
        }
    }
    async getDefaultNextAvailablePluginManifestPath(folder, pluginManifestFileName = teamsfx_api_1.DefaultPluginManifestFileName, isKiotaIntegration = false) {
        if (!(await fs_extra_1.default.pathExists(path_1.default.join(folder, pluginManifestFileName)))) {
            return path_1.default.join(folder, pluginManifestFileName);
        }
        const pluginManifestNamePrefix = pluginManifestFileName.split(".")[0];
        let pluginFileNameSuffix = 1;
        let pluginManifestName = this.getPluginManifestFileName(pluginManifestNamePrefix, pluginFileNameSuffix, isKiotaIntegration);
        while (await fs_extra_1.default.pathExists(path_1.default.join(folder, pluginManifestName))) {
            pluginFileNameSuffix++;
            pluginManifestName = this.getPluginManifestFileName(pluginManifestNamePrefix, pluginFileNameSuffix, isKiotaIntegration);
        }
        return path_1.default.join(folder, pluginManifestName);
    }
    getPluginManifestFileName(pluginManifestNamePrefix, pluginFileNameSuffix, isKiotaIntegration) {
        let pluginManifestName;
        if (isKiotaIntegration) {
            const pluginManifestNameSplit = pluginManifestNamePrefix.split("-");
            pluginManifestName = `${pluginManifestNameSplit[0]}_${pluginFileNameSuffix}-${pluginManifestNameSplit[1]}.json`;
        }
        else {
            pluginManifestName = `${pluginManifestNamePrefix}_${pluginFileNameSuffix}.json`;
        }
        return pluginManifestName;
    }
}
exports.CopilotGptManifestUtils = CopilotGptManifestUtils;
exports.copilotGptManifestUtils = new CopilotGptManifestUtils();
//# sourceMappingURL=CopilotGptManifestUtils.js.map
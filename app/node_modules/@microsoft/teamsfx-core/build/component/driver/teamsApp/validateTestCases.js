"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValidateWithTestCasesDriver = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const os_1 = require("os");
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const teamsDevPortalClient_1 = require("../../../client/teamsDevPortalClient");
const constants_1 = require("../../../common/constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const utils_1 = require("../../../common/utils");
const common_1 = require("../../../error/common");
const constant_1 = require("../../configManager/constant");
const metadataUtil_1 = require("../../utils/metadataUtil");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const wrapUtil_1 = require("../util/wrapUtil");
const constants_2 = require("./constants");
const AsyncAppValidationResponse_1 = require("./interfaces/AsyncAppValidationResponse");
const actionName = "teamsApp/validateWithTestCases";
let ValidateWithTestCasesDriver = class ValidateWithTestCasesDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("core.selectValidateMethodQuestion.validate.testCasesOptionDescription");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.progressBar.validateWithTestCases");
    }
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.validate(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async validate(args, context) {
        var _a, _b;
        const result = this.validateArgs(args);
        if (result.isErr()) {
            return (0, teamsfx_api_1.err)(result.error);
        }
        let appPackagePath = args.appPackagePath;
        if (!path.isAbsolute(appPackagePath)) {
            appPackagePath = path.join(context.projectPath, appPackagePath);
        }
        if (!(await fs_extra_1.default.pathExists(appPackagePath))) {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(actionName, appPackagePath));
        }
        const archivedFile = await fs_extra_1.default.readFile(appPackagePath);
        const zipEntries = new adm_zip_1.default(archivedFile).getEntries();
        const manifestFile = zipEntries.find((x) => x.entryName === constants_2.Constants.MANIFEST_FILE);
        if (manifestFile) {
            const manifestContent = manifestFile.getData().toString();
            const manifest = JSON.parse(manifestContent);
            metadataUtil_1.metadataUtil.parseManifest(manifest);
            // Add common properties like isCopilotPlugin: boolean
            const manifestTelemetries = teamsfx_api_1.ManifestUtil.parseCommonTelemetryProperties(manifest);
            (0, lodash_1.merge)(context.telemetryProperties, manifestTelemetries);
            const appStudioTokenRes = await context.m365TokenProvider.getAccessToken({
                scopes: constants_1.AppStudioScopes,
            });
            if (appStudioTokenRes.isErr()) {
                return (0, teamsfx_api_1.err)(appStudioTokenRes.error);
            }
            const appStudioToken = appStudioTokenRes.value;
            // Check if the app has ongoing validation
            const existingValidationResponse = await teamsDevPortalClient_1.teamsDevPortalClient.getAppValidationRequestList(appStudioToken, manifest.id);
            if (existingValidationResponse.appValidations) {
                for (const validation of existingValidationResponse.appValidations) {
                    if (validation.status === AsyncAppValidationResponse_1.AsyncAppValidationStatus.InProgress ||
                        validation.status === AsyncAppValidationResponse_1.AsyncAppValidationStatus.Created) {
                        if (context.platform === teamsfx_api_1.Platform.CLI) {
                            const message = [
                                {
                                    content: `A validation is currently in progress, please submit later. You can find this existing validation from `,
                                    color: teamsfx_api_1.Colors.BRIGHT_YELLOW,
                                },
                                {
                                    content: `${(0, constants_1.getAppStudioEndpoint)()}/apps/${manifest.id}/app-validation/${validation.id}`,
                                    color: teamsfx_api_1.Colors.BRIGHT_CYAN,
                                },
                            ];
                            (_a = context.ui) === null || _a === void 0 ? void 0 : _a.showMessage("warn", message, false);
                        }
                        else {
                            const message = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.progressBar.validateWithTestCases.conflict", `${(0, constants_1.getAppStudioEndpoint)()}/apps/${manifest.id}/app-validation/${validation.id}`);
                            context.logProvider.warning(message);
                        }
                        return (0, teamsfx_api_1.ok)(new Map());
                    }
                }
            }
            const response = await teamsDevPortalClient_1.teamsDevPortalClient.submitAppValidationRequest(appStudioToken, manifest.id);
            if (context.platform === teamsfx_api_1.Platform.CLI) {
                const message = [
                    {
                        content: `Validation request submitted, status: ${response.status}. View the validation result from `,
                        color: teamsfx_api_1.Colors.BRIGHT_WHITE,
                    },
                    {
                        content: `${(0, constants_1.getAppStudioEndpoint)()}/apps/${manifest.id}/app-validation/${response.appValidationId}`,
                        color: teamsfx_api_1.Colors.BRIGHT_CYAN,
                    },
                ];
                (_b = context.ui) === null || _b === void 0 ? void 0 : _b.showMessage("info", message, false);
            }
            else {
                const message = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.progressBar.validateWithTestCases.step", response.status, `${(0, constants_1.getAppStudioEndpoint)()}/apps/${manifest.id}/app-validation`);
                context.logProvider.info(message);
                // Do not await the final validation result, return immediately
                void this.runningBackgroundJob(args, context, appStudioToken, response, manifest.id);
            }
            return (0, teamsfx_api_1.ok)(new Map());
        }
        else {
            return (0, teamsfx_api_1.err)(new common_1.FileNotFoundError(actionName, "manifest.json"));
        }
    }
    /**
     * Periodically check the result until it's completed or aborted
     * @param args
     * @param context
     * @param appStudioToken
     * @param response
     * @param teamsAppId
     */
    async runningBackgroundJob(args, context, appStudioToken, response, teamsAppId) {
        const validationRequestListUrl = `${(0, constants_1.getAppStudioEndpoint)()}/apps/${teamsAppId}/app-validation`;
        try {
            if (args.showProgressBar && context.ui) {
                context.progressBar = context.ui.createProgressBar(this.progressTitle, 1);
                await context.progressBar.start();
                const message = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.progressBar.validateWithTestCases.step", response.status, validationRequestListUrl);
                await context.progressBar.next(message);
            }
            let resultResp = response;
            while (resultResp.status !== AsyncAppValidationResponse_1.AsyncAppValidationStatus.Completed &&
                resultResp.status !== AsyncAppValidationResponse_1.AsyncAppValidationStatus.Aborted) {
                await (0, utils_1.waitSeconds)(constants_2.CEHCK_VALIDATION_RESULTS_INTERVAL_SECONDS);
                const message = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.progressBar.validateWithTestCases.step", resultResp.status, validationRequestListUrl);
                context.logProvider.info(message);
                resultResp = await teamsDevPortalClient_1.teamsDevPortalClient.getAppValidationById(appStudioToken, resultResp.appValidationId);
            }
            this.evaluateValidationResults(args, context, resultResp, teamsAppId);
        }
        finally {
            if (args.showProgressBar && context.progressBar) {
                await context.progressBar.end(true);
            }
        }
    }
    /**
     * Evaluate the validation results and log the summary
     * @param args
     * @param context
     * @param resultResp
     * @param teamsAppId
     */
    evaluateValidationResults(args, context, resultResp, teamsAppId) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const validationStatusUrl = `${(0, constants_1.getAppStudioEndpoint)()}/apps/${teamsAppId}/app-validation/${resultResp.appValidationId}`;
        const failed = (_c = (_b = (_a = resultResp.validationResults) === null || _a === void 0 ? void 0 : _a.failures) === null || _b === void 0 ? void 0 : _b.length) !== null && _c !== void 0 ? _c : 0;
        const warns = (_f = (_e = (_d = resultResp.validationResults) === null || _d === void 0 ? void 0 : _d.warnings) === null || _e === void 0 ? void 0 : _e.length) !== null && _f !== void 0 ? _f : 0;
        const skipped = (_j = (_h = (_g = resultResp.validationResults) === null || _g === void 0 ? void 0 : _g.skipped) === null || _h === void 0 ? void 0 : _h.length) !== null && _j !== void 0 ? _j : 0;
        const passed = (_m = (_l = (_k = resultResp.validationResults) === null || _k === void 0 ? void 0 : _k.successes) === null || _l === void 0 ? void 0 : _l.length) !== null && _m !== void 0 ? _m : 0;
        const summaryStrArr = [];
        const detailStrArr = [];
        if (failed > 0) {
            summaryStrArr.push((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.failed", failed));
            for (const failure of resultResp.validationResults.failures) {
                detailStrArr.push((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateWithTestCases.result.detail", constant_1.SummaryConstant.Failed, failure.title, failure.message));
            }
        }
        if (warns > 0) {
            summaryStrArr.push((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.warning", warns));
            for (const warning of resultResp.validationResults.warnings) {
                detailStrArr.push((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateWithTestCases.result.detail", constant_1.SummaryConstant.Warning, warning.title, warning.message));
            }
        }
        if (skipped > 0) {
            summaryStrArr.push((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.skipped", skipped));
        }
        if (passed > 0) {
            summaryStrArr.push((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validate.succeed", passed));
        }
        const summaryStr = summaryStrArr.join(", ");
        let detailStr = detailStrArr.join(os_1.EOL);
        // start a new line if the detail is not empty.
        if (detailStr.length > 0) {
            detailStr = os_1.EOL + detailStr;
        }
        if (resultResp.status === AsyncAppValidationResponse_1.AsyncAppValidationStatus.Completed) {
            if (args.showMessage && context.ui) {
                void context.ui.showMessage("info", (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateWithTestCases.result", resultResp.status, summaryStr), false);
            }
            context.logProvider.info((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateWithTestCases", resultResp.status, summaryStr, validationStatusUrl, detailStr));
        }
        else {
            if (args.showMessage && context.ui) {
                void context.ui.showMessage("error", (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateWithTestCases.result", resultResp.status, ""), false);
            }
            context.logProvider.error((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.validateWithTestCases", resultResp.status, "", validationStatusUrl, ""));
        }
    }
    validateArgs(args) {
        if (!args || !args.appPackagePath) {
            return (0, teamsfx_api_1.err)(new common_1.InvalidActionInputError(actionName, ["appPackagePath"], "https://aka.ms/teamsfx-actions/teamsapp-validate-test-cases"));
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext]),
    tslib_1.__metadata("design:returntype", Promise)
], ValidateWithTestCasesDriver.prototype, "validate", null);
ValidateWithTestCasesDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(actionName)
], ValidateWithTestCasesDriver);
exports.ValidateWithTestCasesDriver = ValidateWithTestCasesDriver;
//# sourceMappingURL=validateTestCases.js.map
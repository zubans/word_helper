"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SyncManifestDriver = void 0;
const tslib_1 = require("tslib");
const deepDiff = tslib_1.__importStar(require("deep-diff"));
const typedi_1 = require("typedi");
const path = tslib_1.__importStar(require("path"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const appStudio = tslib_1.__importStar(require("./appStudio"));
const wrapUtil_1 = require("../util/wrapUtil");
const results_1 = require("./results");
const errors_1 = require("./errors");
const localizeUtils_1 = require("../../../common/localizeUtils");
const envUtil_1 = require("../../utils/envUtil");
const pathUtils_1 = require("../../utils/pathUtils");
const metadataUtil_1 = require("../../utils/metadataUtil");
const ManifestUtils_1 = require("./utils/ManifestUtils");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const actionName = "teamsApp/syncManifest";
let SyncManifestDriver = class SyncManifestDriver {
    async execute(args, context) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.sync(args, wrapContext);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async sync(args, context) {
        if (!args.projectPath || !args.env) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.SyncManifestFailedError.name, errors_1.AppStudioError.SyncManifestFailedError.message([
                (0, localizeUtils_1.getLocalizedString)("error.appstudio.syncManifestInvalidInput"),
            ])));
        }
        const res = await this.getTeamsAppIdAndManifestTemplatePath(args);
        if (res.isErr()) {
            return (0, teamsfx_api_1.err)(res.error);
        }
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const teamsAppId = res.value.get("teamsAppId");
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        const manifestTemplatePath = res.value.get("manifestTemplatePath");
        const appPackageRes = await appStudio.getAppPackage(teamsAppId, context.m365TokenProvider, context.logProvider);
        if (appPackageRes.isErr()) {
            return (0, teamsfx_api_1.err)(appPackageRes.error);
        }
        const appPackage = appPackageRes.value;
        if (!appPackage.manifest) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.SyncManifestFailedError.name, errors_1.AppStudioError.SyncManifestFailedError.message([
                (0, localizeUtils_1.getLocalizedString)("error.appstudio.syncManifestNoManifest"),
            ])));
        }
        const newManifest = JSON.parse(appPackage.manifest.toString("utf8"));
        // save the new manifest file.
        const timeStamp = new Date().toISOString().replace(/[-:]/g, "").replace(/\..+/, "");
        const manifestFileName = `manifest.${args.env}.${teamsAppId}.json`;
        const dirPath = path.join(args.projectPath, "appPackage", "syncHistory", timeStamp);
        const filePath = path.join(dirPath, manifestFileName);
        await fs_extra_1.default.mkdir(dirPath, { recursive: true });
        await fs_extra_1.default.writeFile(filePath, JSON.stringify(newManifest, null, "\t"));
        context.logProvider.info((0, localizeUtils_1.getLocalizedString)("core.syncManifest.saveManifestSuccess", filePath));
        const currentManifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestTemplatePath);
        if (currentManifestRes.isErr()) {
            return (0, teamsfx_api_1.err)(currentManifestRes.error);
        }
        const currentManifest = currentManifestRes.value;
        const differences = deepDiff.diff(currentManifest, newManifest);
        // If there are add or delete differences, log warnings and return.
        // If there are edit differences, check if the different values are variable placeholders, like: ${{Teams_APP_ID}}.
        const diffVariablesMap = new Map();
        for (const diff of differences !== null && differences !== void 0 ? differences : []) {
            if (diff.kind === "N") {
                context.logProvider.warning((0, localizeUtils_1.getLocalizedString)("core.syncManifest.addWarning", diff.path, diff.rhs));
                return (0, teamsfx_api_1.ok)(new Map());
            }
            if (diff.kind === "D") {
                context.logProvider.warning((0, localizeUtils_1.getLocalizedString)("core.syncManifest.deleteWarning", diff.path, diff.lhs));
                return (0, teamsfx_api_1.ok)(new Map());
            }
            if (diff.kind === "E") {
                const leftValue = diff.lhs;
                const rightValue = diff.rhs;
                const res = this.matchPlaceholders(leftValue, rightValue);
                if (res.isErr()) {
                    context.logProvider.warning(res.error.message);
                    return (0, teamsfx_api_1.ok)(new Map());
                }
                for (const [key, value] of res.value) {
                    if (diffVariablesMap.has(key)) {
                        if (diffVariablesMap.get(key) !== value) {
                            context.logProvider.warning((0, localizeUtils_1.getLocalizedString)("core.syncManifest.editKeyConflict", key, diffVariablesMap.get(key), value));
                            return (0, teamsfx_api_1.ok)(new Map());
                        }
                    }
                    else {
                        diffVariablesMap.set(key, value);
                    }
                }
            }
        }
        if (diffVariablesMap.size === 0) {
            context.logProvider.info((0, localizeUtils_1.getLocalizedString)("core.syncManifest.noDiff"));
            return (0, teamsfx_api_1.ok)(new Map());
        }
        const currentEnvRes = await envUtil_1.envUtil.readEnv(args.projectPath, args.env);
        if (currentEnvRes.isErr()) {
            return (0, teamsfx_api_1.err)(currentEnvRes.error);
        }
        const envToUpdate = {};
        for (const [key, value] of diffVariablesMap) {
            if (currentEnvRes.value[key] != value) {
                envToUpdate[key] = value;
            }
        }
        if (Object.keys(envToUpdate).length > 0) {
            const res = await envUtil_1.envUtil.writeEnv(args.projectPath, args.env, envToUpdate);
            if (res.isErr()) {
                return (0, teamsfx_api_1.err)(res.error);
            }
            context.logProvider.info((0, localizeUtils_1.getLocalizedString)("core.syncManifest.updateEnvSuccess", args.env, envToUpdate));
        }
        context.logProvider.info((0, localizeUtils_1.getLocalizedString)("core.syncManifest.success", args.env));
        return (0, teamsfx_api_1.ok)(new Map());
    }
    // Returns the teams app id and manifest template path.
    // Map key: "teamsAppId", "manifestTemplatePath".
    async getTeamsAppIdAndManifestTemplatePath(args) {
        var _a, _b, _c, _d, _e;
        const envRes = await envUtil_1.envUtil.readEnv(args.projectPath, args.env);
        if (envRes.isErr()) {
            return (0, teamsfx_api_1.err)(envRes.error);
        }
        const teamsappYamlPath = pathUtils_1.pathUtils.getYmlFilePath(args.projectPath, args.env);
        const yamlProjectModel = await metadataUtil_1.metadataUtil.parse(teamsappYamlPath, args.env);
        if (yamlProjectModel.isErr()) {
            return (0, teamsfx_api_1.err)(yamlProjectModel.error);
        }
        const projectModel = yamlProjectModel.value;
        let teamsAppId = args.teamsAppId;
        if (!teamsAppId) {
            for (const action of (_b = (_a = projectModel.provision) === null || _a === void 0 ? void 0 : _a.driverDefs) !== null && _b !== void 0 ? _b : []) {
                if (action.uses === "teamsApp/create") {
                    const teamsAppIdKeyName = ((_c = action.writeToEnvironmentFile) === null || _c === void 0 ? void 0 : _c.teamsAppId) || "TEAMS_APP_ID";
                    teamsAppId = envRes.value[teamsAppIdKeyName];
                }
            }
            if (!teamsAppId) {
                return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.SyncManifestFailedError.name, errors_1.AppStudioError.SyncManifestFailedError.message([
                    (0, localizeUtils_1.getLocalizedString)("error.appstudio.syncManifestNoTeamsAppId"),
                ])));
            }
        }
        let yamlManifestPath = "";
        for (const action of (_e = (_d = projectModel.provision) === null || _d === void 0 ? void 0 : _d.driverDefs) !== null && _e !== void 0 ? _e : []) {
            if (action.uses === "teamsApp/zipAppPackage") {
                const parameters = action.with;
                yamlManifestPath = parameters["manifestPath"];
            }
        }
        const deafultManifestTemplatePath = path.join(args.projectPath, "appPackage", "manifest.json");
        let manifestTemplatePath = "";
        if (!yamlManifestPath) {
            manifestTemplatePath = deafultManifestTemplatePath;
        }
        else if (path.isAbsolute(yamlManifestPath)) {
            manifestTemplatePath = yamlManifestPath;
        }
        else {
            manifestTemplatePath = path.join(args.projectPath, yamlManifestPath);
        }
        return (0, teamsfx_api_1.ok)(new Map([
            ["teamsAppId", teamsAppId],
            ["manifestTemplatePath", manifestTemplatePath],
        ]));
    }
    // Check if the value matches the template with placeholders and return the placeholder map.
    matchPlaceholders(template, value) {
        const placeholderPattern = /\${{(.*?)}}/g;
        const placeholders = [];
        let match;
        while ((match = placeholderPattern.exec(template)) !== null) {
            placeholders.push(match[1]);
        }
        if (placeholders.length === 0) {
            if (template === value) {
                return (0, teamsfx_api_1.ok)(new Map());
            }
            else {
                return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.SyncManifestFailedError.name, errors_1.AppStudioError.SyncManifestFailedError.message([
                    (0, localizeUtils_1.getLocalizedString)("core.syncManifest.editNonVarPlaceholder", template, value),
                ])));
            }
        }
        const regexPattern = template.replace(placeholderPattern, "(.*?)");
        const regex = new RegExp(`^${regexPattern}$`);
        const matchValues = value.match(regex);
        if (!matchValues) {
            return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.SyncManifestFailedError.name, errors_1.AppStudioError.SyncManifestFailedError.message([
                (0, localizeUtils_1.getLocalizedString)("core.syncManifest.editNotMatch", template, value),
            ])));
        }
        const result = new Map();
        for (let i = 0; i < placeholders.length; i++) {
            const key = placeholders[i];
            const matchValue = matchValues[i + 1];
            if (result.has(key)) {
                if (result.get(key) !== matchValue) {
                    return (0, teamsfx_api_1.err)(results_1.AppStudioResultFactory.UserError(errors_1.AppStudioError.SyncManifestFailedError.name, errors_1.AppStudioError.SyncManifestFailedError.message([
                        (0, localizeUtils_1.getLocalizedString)("core.syncManifest.editKeyConflict", key, result.get(key), matchValue),
                    ])));
                }
            }
            else {
                result.set(key, matchValue);
            }
        }
        return (0, teamsfx_api_1.ok)(result);
    }
};
SyncManifestDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(actionName)
], SyncManifestDriver);
exports.SyncManifestDriver = SyncManifestDriver;
//# sourceMappingURL=syncManifest.js.map
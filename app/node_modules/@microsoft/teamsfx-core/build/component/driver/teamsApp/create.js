"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CreateTeamsAppDriver = exports.internalOutputNames = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const typedi_1 = require("typedi");
const uuid_1 = require("uuid");
const teamsDevPortalClient_1 = require("../../../client/teamsDevPortalClient");
const constants_1 = require("../../../common/constants");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../../error/common");
const folder_1 = require("../../../folder");
const addStartAndEndTelemetry_1 = require("../middleware/addStartAndEndTelemetry");
const utils_1 = require("../util/utils");
const wrapUtil_1 = require("../util/wrapUtil");
const constants_2 = require("./constants");
const errors_1 = require("./errors");
const results_1 = require("./results");
const actionName = "teamsApp/create";
const defaultOutputNames = {
    teamsAppId: "TEAMS_APP_ID",
};
exports.internalOutputNames = {
    teamsAppTenantId: "TEAMS_APP_TENANT_ID",
};
let CreateTeamsAppDriver = class CreateTeamsAppDriver {
    constructor() {
        this.description = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.description.createDriver");
        this.progressTitle = (0, localizeUtils_1.getLocalizedString)("driver.teamsApp.progressBar.createTeamsAppStepMessage");
    }
    async execute(args, context, outputEnvVarNames) {
        const wrapContext = new wrapUtil_1.WrapDriverContext(context, actionName, actionName);
        const res = await this.create(args, wrapContext, outputEnvVarNames);
        return {
            result: res,
            summaries: wrapContext.summaries,
        };
    }
    async create(args, context, outputEnvVarNames) {
        const result = this.validateArgs(args);
        if (result.isErr()) {
            return (0, teamsfx_api_1.err)(result.error);
        }
        if (!outputEnvVarNames) {
            outputEnvVarNames = new Map(Object.entries(defaultOutputNames));
        }
        outputEnvVarNames = new Map([...outputEnvVarNames, ...Object.entries(exports.internalOutputNames)]);
        const state = (0, utils_1.loadStateFromEnv)(outputEnvVarNames);
        let create = true;
        const appStudioTokenRes = await context.m365TokenProvider.getAccessToken({
            scopes: constants_1.AppStudioScopes,
        });
        if (appStudioTokenRes.isErr()) {
            return (0, teamsfx_api_1.err)(appStudioTokenRes.error);
        }
        const appStudioToken = appStudioTokenRes.value;
        let createdAppDefinition;
        const teamsAppId = state.teamsAppId;
        if (teamsAppId) {
            try {
                createdAppDefinition = await teamsDevPortalClient_1.teamsDevPortalClient.getApp(appStudioToken, teamsAppId);
                create = false;
            }
            catch (error) { }
        }
        if (create) {
            const manifest = new teamsfx_api_1.TeamsAppManifest();
            manifest.name.short = args.name;
            if (teamsAppId) {
                manifest.id = teamsAppId;
            }
            else {
                manifest.id = (0, uuid_1.v4)();
            }
            const zip = new adm_zip_1.default();
            zip.addFile(constants_2.Constants.MANIFEST_FILE, Buffer.from(JSON.stringify(manifest, null, 4)));
            const sourceTemplatesFolder = (0, folder_1.getTemplatesFolder)();
            const defaultColorPath = path.join(sourceTemplatesFolder, constants_2.COLOR_TEMPLATE);
            const defaultOutlinePath = path.join(sourceTemplatesFolder, constants_2.OUTLINE_TEMPLATE);
            const colorFile = await fs_extra_1.default.readFile(defaultColorPath);
            zip.addFile(constants_2.DEFAULT_COLOR_PNG_FILENAME, colorFile);
            const outlineFile = await fs_extra_1.default.readFile(defaultOutlinePath);
            zip.addFile(constants_2.DEFAULT_OUTLINE_PNG_FILENAME, outlineFile);
            const archivedFile = zip.toBuffer();
            try {
                createdAppDefinition = await teamsDevPortalClient_1.teamsDevPortalClient.importApp(appStudioTokenRes.value, archivedFile);
                const message = (0, localizeUtils_1.getLocalizedString)("plugins.appstudio.teamsAppCreatedNotice", createdAppDefinition.teamsAppId);
                context.logProvider.verbose(message);
                context.addSummary(message);
                return (0, teamsfx_api_1.ok)(new Map([
                    [outputEnvVarNames.get("teamsAppId"), createdAppDefinition.teamsAppId],
                    [outputEnvVarNames.get("teamsAppTenantId"), createdAppDefinition.tenantId],
                ]));
            }
            catch (e) {
                if (e instanceof teamsfx_api_1.UserError || e instanceof teamsfx_api_1.SystemError) {
                    if (e instanceof teamsfx_api_1.UserError && !e.helpLink) {
                        e.helpLink = "https://aka.ms/teamsfx-actions/teamsapp-create";
                    }
                    return (0, teamsfx_api_1.err)(e);
                }
                else {
                    const error = results_1.AppStudioResultFactory.SystemError(errors_1.AppStudioError.TeamsAppCreateFailedError.name, errors_1.AppStudioError.TeamsAppCreateFailedError.message(e), "https://aka.ms/teamsfx-actions/teamsapp-create");
                    return (0, teamsfx_api_1.err)(error);
                }
            }
        }
        else {
            context.addSummary((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.createTeamsAppAlreadyExists", teamsAppId));
            context.logProvider.verbose((0, localizeUtils_1.getLocalizedString)("driver.teamsApp.summary.createTeamsAppAlreadyExists", teamsAppId));
            return (0, teamsfx_api_1.ok)(new Map([
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                [outputEnvVarNames.get("teamsAppId"), createdAppDefinition.teamsAppId],
                // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion
                [outputEnvVarNames.get("teamsAppTenantId"), createdAppDefinition.tenantId],
            ]));
        }
    }
    validateArgs(args) {
        const invalidParams = [];
        if (!args || !args.name) {
            invalidParams.push("name");
        }
        if (invalidParams.length > 0) {
            return (0, teamsfx_api_1.err)(new common_1.InvalidActionInputError(actionName, invalidParams, "https://aka.ms/teamsfx-actions/teamsapp-create"));
        }
        else {
            return (0, teamsfx_api_1.ok)(undefined);
        }
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(actionName, actionName)]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, wrapUtil_1.WrapDriverContext,
        Map]),
    tslib_1.__metadata("design:returntype", Promise)
], CreateTeamsAppDriver.prototype, "create", null);
CreateTeamsAppDriver = tslib_1.__decorate([
    (0, typedi_1.Service)(actionName)
], CreateTeamsAppDriver);
exports.CreateTeamsAppDriver = CreateTeamsAppDriver;
//# sourceMappingURL=create.js.map
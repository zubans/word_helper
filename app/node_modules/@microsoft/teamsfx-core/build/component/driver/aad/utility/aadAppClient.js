"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.AadAppClient = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const axios_retry_1 = tslib_1.__importDefault(require("axios-retry"));
const constants_1 = require("../../../../common/constants");
const localizeUtils_1 = require("../../../../common/localizeUtils");
const globalVars_1 = require("../../../../common/globalVars");
const aadManifestError_1 = require("../error/aadManifestError");
const clientSecretNotAllowedError_1 = require("../error/clientSecretNotAllowedError");
const credentialInvalidLifetimeError_1 = require("../error/credentialInvalidLifetimeError");
const signInAudience_1 = require("../interface/signInAudience");
const aadManifestHelper_1 = require("./aadManifestHelper");
const constants_2 = require("./constants");
class AadAppClient {
    constructor(m365TokenProvider, logProvider) {
        this.retryNumber = 5;
        this.baseUrl = "https://graph.microsoft.com/v1.0";
        this.tokenProvider = m365TokenProvider;
        this.logProvider = logProvider;
        // Create axios instance which sets authorization header automatically before each MS Graph request
        this.axios = axios_1.default.create({
            baseURL: this.baseUrl,
        });
        this.axios.interceptors.request.use(async (config) => {
            var _a;
            (_a = this.logProvider) === null || _a === void 0 ? void 0 : _a.debug((0, localizeUtils_1.getLocalizedString)("core.common.SendingApiRequest", config.url, JSON.stringify(config.data)));
            const tokenResponse = await this.tokenProvider.getAccessToken({ scopes: constants_1.GraphScopes });
            if (tokenResponse.isErr()) {
                throw tokenResponse.error;
            }
            const token = tokenResponse.value;
            if (!config.headers) {
                config.headers = {};
            }
            config.headers["Authorization"] = `Bearer ${token}`;
            return config;
        });
        this.axios.interceptors.response.use((response) => {
            var _a;
            (_a = this.logProvider) === null || _a === void 0 ? void 0 : _a.debug((0, localizeUtils_1.getLocalizedString)("core.common.ReceiveApiResponse", JSON.stringify(response.data)));
            return response;
        });
        // Add retry logic. Retry post request may result in creating additional resources but should be fine in Microsoft Entra driver.
        (0, axios_retry_1.default)(this.axios, {
            retries: this.retryNumber,
            retryDelay: axios_retry_1.default.exponentialDelay,
            retryCondition: (error) => axios_retry_1.default.isNetworkError(error) || axios_retry_1.default.isRetryableError(error), // retry when there's network error or 5xx error
        });
    }
    async createAadApp(displayName, signInAudience = signInAudience_1.SignInAudience.AzureADMyOrg, serviceManagementReference) {
        const requestBody = {
            displayName: displayName,
            signInAudience: signInAudience,
            serviceManagementReference: serviceManagementReference,
        }; // Create a Microsoft Entra app and optionally set service tree id
        const response = await this.axios.post("applications", requestBody);
        return response.data;
    }
    async deleteAadApp(id) {
        await this.axios.delete(`applications/${id}`);
    }
    async generateClientSecret(objectId, clientSecretExpireDays = 180, // Recommended lifetime from Azure Portal
    clientSecretDescription = "default") {
        var _a, _b, _c, _d;
        const startDate = new Date();
        const endDate = new Date(startDate.getTime());
        endDate.setDate(endDate.getDate() + clientSecretExpireDays);
        const requestBody = {
            passwordCredential: {
                displayName: clientSecretDescription,
                endDateTime: endDate.toISOString(),
                startDateTime: startDate.toISOString(),
            },
        };
        try {
            const response = await this.axios.post(`applications/${objectId}/addPassword`, requestBody, {
                "axios-retry": {
                    retries: this.retryNumber,
                    retryDelay: axios_retry_1.default.exponentialDelay,
                    retryCondition: (error) => axios_retry_1.default.isNetworkError(error) ||
                        axios_retry_1.default.isRetryableError(error) ||
                        this.is404Error(error), // also retry 404 error since Microsoft Entra need sometime to sync created Microsoft Entra app data
                },
            });
            return response.data.secretText;
        }
        catch (err) {
            if (axios_1.default.isAxiosError(err) && err.response) {
                if (((_b = (_a = err.response.data) === null || _a === void 0 ? void 0 : _a.error) === null || _b === void 0 ? void 0 : _b.code) === constants_2.aadErrorCode.credentialInvalidLifetimeAsPerAppPolicy) {
                    throw new credentialInvalidLifetimeError_1.CredentialInvalidLifetimeError(AadAppClient.name);
                }
                if (((_d = (_c = err.response.data) === null || _c === void 0 ? void 0 : _c.error) === null || _d === void 0 ? void 0 : _d.code) === constants_2.aadErrorCode.credentialTypeNotAllowedAsPerAppPolicy) {
                    throw new clientSecretNotAllowedError_1.ClientSecretNotAllowedError(AadAppClient.name);
                }
            }
            throw err;
        }
    }
    async updateAadApp(manifest) {
        var _a, _b;
        const objectId = manifest.id; // You need to ensure the object id exists in manifest
        const requestBody = aadManifestHelper_1.AadManifestHelper.manifestToApplication(manifest);
        try {
            await this.axios.patch(`applications/${objectId}`, requestBody, {
                "axios-retry": {
                    retries: this.retryNumber,
                    retryDelay: axios_retry_1.default.exponentialDelay,
                    retryCondition: (error) => axios_retry_1.default.isNetworkError(error) ||
                        axios_retry_1.default.isRetryableError(error) ||
                        this.is404Error(error) || // also retry 404 error since Microsoft Entra need sometime to sync created Microsoft Entra app data
                        this.is400Error(error), // sometimes Microsoft Entra will complain OAuth permission not found if we pre-authorize a newly created permission
                },
            });
        }
        catch (err) {
            if (axios_1.default.isAxiosError(err) && err.response && err.response.status === 400) {
                if (((_a = err.response.data.error) === null || _a === void 0 ? void 0 : _a.code) === constants_2.aadErrorCode.permissionErrorCode) {
                    throw new aadManifestError_1.DeleteOrUpdatePermissionFailedError(AadAppClient.name);
                }
                if (((_b = err.response.data.error) === null || _b === void 0 ? void 0 : _b.code) === constants_2.aadErrorCode.hostNameNotOnVerifiedDomain) {
                    throw new aadManifestError_1.HostNameNotOnVerifiedDomainError(AadAppClient.name, err.response.data.error.message);
                }
            }
            throw err;
        }
    }
    async getOwners(objectId) {
        var _a;
        const response = await this.axios.get(`applications/${objectId}/owners`, {
            "axios-retry": {
                retries: this.retryNumber,
                retryDelay: axios_retry_1.default.exponentialDelay,
                retryCondition: (error) => axios_retry_1.default.isNetworkError(error) ||
                    axios_retry_1.default.isRetryableError(error) ||
                    this.is404Error(error), // also retry 404 error since Microsoft Entra need sometime to sync created Microsoft Entra app data
            },
        });
        const aadOwners = [];
        for (const aadOwner of response.data.value) {
            aadOwners.push({
                userObjectId: aadOwner.id,
                resourceId: objectId,
                displayName: aadOwner.displayName,
                // For guest account, aadOwner.userPrincipalName will contains "EXT", thus use mail instead.
                userPrincipalName: (_a = aadOwner.mail) !== null && _a !== void 0 ? _a : aadOwner.userPrincipalName,
            });
        }
        return aadOwners;
    }
    async addOwner(objectId, userObjectId) {
        const requestBody = {
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            "@odata.id": `${this.axios.defaults.baseURL}/directoryObjects/${userObjectId}`,
        };
        await this.axios.post(`applications/${objectId}/owners/$ref`, requestBody, {
            "axios-retry": {
                retries: this.retryNumber,
                retryDelay: axios_retry_1.default.exponentialDelay,
                retryCondition: (error) => axios_retry_1.default.isNetworkError(error) ||
                    axios_retry_1.default.isRetryableError(error) ||
                    this.is404Error(error), // also retry 404 error since Microsoft Entra need sometime to sync created Microsoft Entra app data
            },
        });
    }
    // only use it to retry 404 errors for create client secret / update Microsoft Entra app requests right after Microsoft Entra app creation
    is404Error(error) {
        return error.code !== "ECONNABORTED" && (!error.response || error.response.status === 404);
    }
    is400Error(error) {
        return error.code !== "ECONNABORTED" && (!error.response || error.response.status === 400);
    }
}
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Graph", component: "AadAppClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AadAppClient.prototype, "createAadApp", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Graph", component: "AadAppClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], AadAppClient.prototype, "deleteAadApp", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Graph", component: "AadAppClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AadAppClient.prototype, "generateClientSecret", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Graph", component: "AadAppClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object]),
    tslib_1.__metadata("design:returntype", Promise)
], AadAppClient.prototype, "updateAadApp", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Graph", component: "AadAppClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], AadAppClient.prototype, "getOwners", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Graph", component: "AadAppClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AadAppClient.prototype, "addOwner", null);
exports.AadAppClient = AadAppClient;
//# sourceMappingURL=aadAppClient.js.map
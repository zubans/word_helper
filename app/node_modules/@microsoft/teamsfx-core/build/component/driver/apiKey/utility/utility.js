"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateDomain = exports.getDomain = exports.loadStateFromEnv = void 0;
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const common_1 = require("../../../utils/common");
const constants_1 = require("./constants");
const apiKeyDomainInvalid_1 = require("../error/apiKeyDomainInvalid");
const apiKeyFailedToGetDomain_1 = require("../error/apiKeyFailedToGetDomain");
const apiKeyAuthMissingInSpec_1 = require("../error/apiKeyAuthMissingInSpec");
// Needs to validate the parameters outside of the function
function loadStateFromEnv(outputEnvVarNames) {
    const result = {};
    for (const [propertyName, envVarName] of outputEnvVarNames) {
        result[propertyName] = process.env[envVarName];
    }
    return result;
}
exports.loadStateFromEnv = loadStateFromEnv;
// TODO: need to add logic to read domain from env if need to support non-lifecycle commands
async function getDomain(args, context, actionName) {
    const absolutePath = (0, common_1.getAbsolutePath)(args.apiSpecPath, context.projectPath);
    const parser = new m365_spec_parser_1.SpecParser(absolutePath, {
        allowBearerTokenAuth: true,
        allowMultipleParameters: true,
    });
    const listResult = await parser.list();
    const operations = listResult.APIs;
    const filteredOperations = operations.filter((value) => {
        const auth = value.auth;
        return (auth &&
            auth.authScheme.type === "http" &&
            auth.authScheme.scheme === "bearer" &&
            auth.name === args.name);
    });
    if (filteredOperations.length === 0) {
        throw new apiKeyAuthMissingInSpec_1.ApiKeyAuthMissingInSpecError(actionName, args.name);
    }
    const servers = filteredOperations.map((value) => value.server);
    const uniqueServerUrls = servers.filter((value, index, self) => self.indexOf(value) === index);
    return uniqueServerUrls;
}
exports.getDomain = getDomain;
function validateDomain(domain, actionName) {
    if (domain.length > constants_1.maxDomainPerApiKey) {
        throw new apiKeyDomainInvalid_1.ApiKeyDomainInvalidError(actionName);
    }
    if (domain.length === 0 || domain.includes("")) {
        throw new apiKeyFailedToGetDomain_1.ApiKeyFailedToGetDomainError(actionName);
    }
}
exports.validateDomain = validateDomain;
//# sourceMappingURL=utility.js.map
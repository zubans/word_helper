"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnvWriterMW = exports.EnvLoaderMW = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = tslib_1.__importDefault(require("lodash"));
const globalVars_1 = require("../../common/globalVars");
const environmentName_1 = require("../../core/environmentName");
const error_1 = require("../../error");
const constants_1 = require("../../question/constants");
const other_1 = require("../../question/other");
const visitor_1 = require("../../ui/visitor");
const envUtil_1 = require("../utils/envUtil");
/**
 *
 * @param withLocalEnv whether include local env in env selection list
 * @param skipLoadIfNoEnvInput whether to ignore this middleware if input.env is not available
 * @returns
 */
function EnvLoaderMW(withLocalEnv, skipLoadIfNoEnvInput = false) {
    return async (ctx, next) => {
        const envBefore = lodash_1.default.cloneDeep(process.env);
        try {
            await envLoaderMWImpl(withLocalEnv, ctx, next, skipLoadIfNoEnvInput);
            return;
        }
        finally {
            const keys = Object.keys(process.env);
            for (const k of keys) {
                if (!(k in envBefore)) {
                    delete process.env[k];
                }
                else {
                    process.env[k] = envBefore[k];
                }
            }
        }
    };
}
exports.EnvLoaderMW = EnvLoaderMW;
const envLoaderMWImpl = async (withLocalEnv, ctx, next, skipLoadIfNoEnvInput = false) => {
    const inputs = ctx.arguments[ctx.arguments.length - 1];
    const projectPath = inputs.projectPath;
    if (!projectPath) {
        ctx.result = (0, teamsfx_api_1.err)(new error_1.NoProjectOpenedError());
        return;
    }
    if (inputs.ignoreEnvInfo) {
        inputs.env = environmentName_1.environmentNameManager.getDefaultEnvName();
    }
    if (!inputs.env) {
        if (skipLoadIfNoEnvInput || inputs["ignore-env-file"] === true) {
            process.env.TEAMSFX_ENV = "dev"; // set TEAMSFX_ENV = dev is to avoid unexpected error in other components that depends on this env variable
            await next();
            return;
        }
        const question = (0, other_1.selectTargetEnvQuestion)(constants_1.QuestionNames.Env, !withLocalEnv, true);
        const res = await (0, visitor_1.traverse)({ data: question }, inputs, globalVars_1.TOOLS.ui);
        if (res.isErr()) {
            globalVars_1.TOOLS.logProvider.debug(`Failed to run question model for target environment.`);
            ctx.result = (0, teamsfx_api_1.err)(res.error);
            return;
        }
    }
    if (inputs.env) {
        const res = await envUtil_1.envUtil.readEnv(projectPath, inputs.env);
        if (res.isErr()) {
            ctx.result = (0, teamsfx_api_1.err)(res.error);
            return;
        }
        ctx.envVars = res.value;
    }
    await next();
};
const EnvWriterMW = async (ctx, next) => {
    await next();
    const inputs = ctx.arguments[0];
    const env = inputs.env;
    const projectPath = inputs.projectPath;
    const envVars = ctx.envVars;
    if (projectPath && env && envVars) {
        const res = await envUtil_1.envUtil.writeEnv(projectPath, env, envVars);
        if (res.isErr()) {
            ctx.result = (0, teamsfx_api_1.err)(res.error);
            return;
        }
    }
};
exports.EnvWriterMW = EnvWriterMW;
//# sourceMappingURL=envMW.js.map
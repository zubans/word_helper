"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.ActionExecutionMW = void 0;
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const lodash_1 = require("lodash");
const globalVars_1 = require("../../common/globalVars");
const telemetry_1 = require("../../common/telemetry");
const common_1 = require("../../error/common");
const visitor_1 = require("../../ui/visitor");
const telemetry_2 = require("../telemetry");
const settingsUtil_1 = require("../utils/settingsUtil");
function ActionExecutionMW(action) {
    return async (ctx, next) => {
        var _a, _b, _c;
        const componentName = action.componentName || ((_a = ctx.self) === null || _a === void 0 ? void 0 : _a.componentName) || ((_b = ctx.self) === null || _b === void 0 ? void 0 : _b.constructor.name);
        const telemetryComponentName = action.telemetryComponentName || componentName;
        const errorSource = action.errorSource || componentName;
        const methodName = ctx.method;
        const eventName = action.telemetryEventName || methodName;
        const telemetryProps = {
            [telemetry_1.TelemetryProperty.Component]: telemetryComponentName,
            env: process.env.TEAMSFX_ENV || "",
        };
        const telemetryMeasures = {};
        let progressBar;
        try {
            // send start telemetry
            if (action.enableTelemetry) {
                if (!globalVars_1.globalVars.trackingId) {
                    // try to get trackingId
                    const projectPath = ctx.arguments[0].projectPath;
                    if (projectPath) {
                        await settingsUtil_1.settingsUtil.readSettings(projectPath, false);
                    }
                }
                if (action.telemetryProps)
                    (0, lodash_1.assign)(telemetryProps, action.telemetryProps);
                if (globalVars_1.globalVars.trackingId)
                    telemetryProps[telemetry_1.TelemetryProperty.ProjectId] = globalVars_1.globalVars.trackingId; // add trackingId prop in telemetry
                (0, telemetry_2.sendStartEvent)(eventName, telemetryProps);
            }
            // run question model
            if (action.question) {
                const context = ctx.arguments[0];
                const inputs = ctx.arguments[1];
                const getQuestionRes = await action.question(context, inputs);
                if (getQuestionRes.isErr())
                    throw getQuestionRes.error;
                const node = getQuestionRes.value;
                if (node) {
                    const askQuestionRes = await (0, visitor_1.traverse)(node, inputs, context.userInteraction, context.telemetryReporter);
                    if (askQuestionRes.isErr())
                        throw askQuestionRes.error;
                }
            }
            // progress bar
            if (action.enableProgressBar) {
                progressBar = globalVars_1.TOOLS.ui.createProgressBar(action.progressTitle || methodName, action.progressSteps || 1);
                await progressBar.start();
            }
            if (action.enableTelemetry || action.enableProgressBar) {
                const actionContext = {
                    progressBar: progressBar,
                    telemetryProps: telemetryProps,
                    telemetryMeasures: telemetryMeasures,
                };
                ctx.arguments.push(actionContext);
            }
            const startTime = new Date().getTime();
            await next();
            const timeCost = new Date().getTime() - startTime;
            if (((_c = ctx.result) === null || _c === void 0 ? void 0 : _c.isErr) && ctx.result.isErr())
                throw ctx.result.error;
            // send end telemetry
            (0, lodash_1.merge)(telemetryMeasures, { [telemetry_1.TelemetryProperty.TimeCost]: timeCost });
            if (action.enableTelemetry) {
                (0, telemetry_2.sendSuccessEvent)(eventName, telemetryProps, telemetryMeasures);
            }
            await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(true));
        }
        catch (e) {
            await (progressBar === null || progressBar === void 0 ? void 0 : progressBar.end(false));
            const fxError = (0, common_1.assembleError)(e);
            if (fxError.source === "unknown") {
                fxError.source = errorSource || fxError.source;
                if (fxError instanceof teamsfx_api_1.UserError) {
                    fxError.helpLink = fxError.helpLink || action.errorHelpLink;
                }
                if (fxError instanceof teamsfx_api_1.SystemError) {
                    fxError.issueLink = fxError.issueLink || action.errorIssueLink;
                }
            }
            // send error telemetry
            if (action.enableTelemetry) {
                (0, telemetry_2.sendErrorEvent)(eventName, fxError, telemetryProps);
            }
            ctx.result = (0, teamsfx_api_1.err)(fxError);
        }
    };
}
exports.ActionExecutionMW = ActionExecutionMW;
//# sourceMappingURL=actionExecutionMW.js.map
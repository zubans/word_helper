"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.metadataRscPermissionUtil = exports.getWebApplicationIdStatus = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const versionMetadata_1 = require("../../common/versionMetadata");
const telemetry_1 = require("../../common/telemetry");
const ManifestUtils_1 = require("../driver/teamsApp/utils/ManifestUtils");
class MetadataRscPermissionUtil {
    async parseManifest(ymlPath, model, props) {
        var _a, _b;
        let manifestName = path_1.default.join(versionMetadata_1.MetadataV3.teamsManifestFolder, versionMetadata_1.MetadataV3.teamsManifestFileName);
        const action = (_a = model.provision) === null || _a === void 0 ? void 0 : _a.driverDefs.find((def) => def.uses === "teamsApp/validateManifest");
        // if teamsApp/validateManifest action is defined, use the manifest file in the action
        if (action) {
            const parameters = action.with;
            if (parameters && parameters["manifestPath"]) {
                manifestName = parameters["manifestPath"];
            }
        }
        const manifestPath = path_1.default.join(path_1.default.dirname(ymlPath), manifestName);
        if (!(await fs_extra_1.default.pathExists(manifestPath))) {
            return;
        }
        try {
            const result = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
            if (result.isErr()) {
                return;
            }
            const webApplicationApp = (_b = result.value.webApplicationInfo) === null || _b === void 0 ? void 0 : _b.id;
            props[telemetry_1.TelemetryProperty.WebApplicationId] = getWebApplicationIdStatus(webApplicationApp);
            const manifest = result.value;
            const summary = this.summary(manifest);
            if (summary) {
                props[telemetry_1.ProjectTypeProps.TeamsManifestVersion] = summary.version;
                props[telemetry_1.TelemetryProperty.RscApplication] = summary.rscApplication.join(",");
                props[telemetry_1.TelemetryProperty.RscDelegated] = summary.rscDelegated.join(",");
            }
        }
        catch (error) {
            return;
        }
    }
    summary(manifest) {
        var _a, _b, _c;
        const version = manifest.version;
        const rscApplication = [];
        const rscDelegated = [];
        for (const permission of ((_b = (_a = manifest.authorization) === null || _a === void 0 ? void 0 : _a.permissions) === null || _b === void 0 ? void 0 : _b.resourceSpecific) || []) {
            if (permission.type == "Application") {
                rscApplication.push(permission.name);
            }
            else {
                rscDelegated.push(permission.name);
            }
        }
        for (const permission of ((_c = manifest.webApplicationInfo) === null || _c === void 0 ? void 0 : _c.applicationPermissions) || []) {
            rscApplication.push(permission);
        }
        return {
            version,
            rscApplication,
            rscDelegated,
        };
    }
}
function getWebApplicationIdStatus(id) {
    if (!id) {
        return telemetry_1.WebApplicationIdValue.None;
    }
    if (id === "${{AAD_APP_CLIENT_ID}}") {
        return telemetry_1.WebApplicationIdValue.Default;
    }
    return telemetry_1.WebApplicationIdValue.Customized;
}
exports.getWebApplicationIdStatus = getWebApplicationIdStatus;
exports.metadataRscPermissionUtil = new MetadataRscPermissionUtil();
//# sourceMappingURL=metadataRscPermission.js.map
"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.forEachFileAndDir = exports.zipFolderAsync = void 0;
const tslib_1 = require("tslib");
const fs = tslib_1.__importStar(require("fs-extra"));
const klaw_1 = tslib_1.__importDefault(require("klaw"));
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const path_1 = tslib_1.__importDefault(require("path"));
const deploy_1 = require("../../error/deploy");
/**
 * Asynchronously zip a folder and return buffer
 * @param sourceDir base dir
 * @param notIncluded block list
 * @param cache zip cache file location
 */
async function zipFolderAsync(sourceDir, cache, notIncluded) {
    const tasks = [];
    const ig = notIncluded;
    // always delete cache if exists
    if (fs.existsSync(cache)) {
        try {
            await fs.remove(cache);
        }
        catch (e) {
            if (e instanceof Error && (e === null || e === void 0 ? void 0 : e.code) === "EBUSY") {
                throw new deploy_1.CacheFileInUse(cache, e);
            }
            throw e;
        }
    }
    const zip = new adm_zip_1.default();
    const addFileIntoZip = async (zp, filePath, zipPath, stats) => {
        var _a;
        const content = await fs.readFile(filePath);
        zp.addFile(zipPath, content);
        if (stats) {
            ((_a = zp.getEntry(zipPath)) === null || _a === void 0 ? void 0 : _a.header).time = stats.mtime;
        }
    };
    await forEachFileAndDir(sourceDir, (itemPath, stats) => {
        const relativePath = path_1.default.relative(sourceDir, itemPath);
        const zipPath = path_1.default.normalize(relativePath).split("\\").join("/");
        if (relativePath && !stats.isDirectory()) {
            const fullPath = path_1.default.join(sourceDir, relativePath);
            const task = addFileIntoZip(zip, fullPath, zipPath, stats);
            tasks.push(task);
        }
    }, (itemPath) => {
        return !ig.test(path_1.default.relative(sourceDir, itemPath)).ignored;
    });
    if (tasks.length === 0) {
        throw new deploy_1.DeployEmptyFolderError(sourceDir);
    }
    await Promise.all(tasks);
    // save to cache if exists
    if (cache && tasks) {
        await fs.mkdirs(path_1.default.dirname(cache));
        try {
            await new Promise((resolve, reject) => {
                zip.writeZip(cache, (err) => {
                    if (err) {
                        reject(err);
                    }
                    else {
                        resolve({});
                    }
                });
            });
        }
        catch (e) {
            if (e instanceof Error && (e === null || e === void 0 ? void 0 : e.code) === "ERR_OUT_OF_RANGE") {
                throw new deploy_1.ZipFileError(e);
            }
        }
    }
    return fs.createReadStream(cache);
}
exports.zipFolderAsync = zipFolderAsync;
async function forEachFileAndDir(root, callback, filter) {
    await new Promise((resolve, reject) => {
        const stream = (0, klaw_1.default)(root, { filter: filter });
        stream
            .on("data", (item) => {
            if (callback(item.path, item.stats)) {
                stream.emit("close");
            }
        })
            .on("end", () => resolve({}))
            .on("error", (err) => reject(err))
            .on("close", () => resolve({}));
    });
}
exports.forEachFileAndDir = forEachFileAndDir;
//# sourceMappingURL=fileOperation.js.map
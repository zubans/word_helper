"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resourceGroupHelper = exports.resourceGroupQuestionNode = exports.newResourceGroupNameQuestion = exports.validateResourceGroupName = exports.selectResourceGroupLocationQuestion = exports.selectResourceGroupQuestion = exports.newResourceGroupOption = void 0;
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const arm_resources_1 = require("@azure/arm-resources");
const arm_subscriptions_1 = require("@azure/arm-subscriptions");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const globalVars_1 = require("../../common/globalVars");
const azure_1 = require("../../error/azure");
const constants_1 = require("../../question/constants");
const visitor_1 = require("../../ui/visitor");
const localizeUtils_1 = require("../../common/localizeUtils");
const error_1 = require("../../error");
const MsResources = "Microsoft.Resources";
const ResourceGroups = "resourceGroups";
// TODO: use the emoji plus sign like Azure Functions extension
exports.newResourceGroupOption = "+ New resource group";
/**
 * select existing resource group or create new resource group
 */
function selectResourceGroupQuestion(azureAccountProvider, subscriptionId) {
    return {
        type: "singleSelect",
        name: constants_1.QuestionNames.TargetResourceGroupName,
        title: (0, localizeUtils_1.getLocalizedString)("core.QuestionSelectResourceGroup.title"),
        staticOptions: [{ id: exports.newResourceGroupOption, label: exports.newResourceGroupOption }],
        dynamicOptions: async (inputs) => {
            const rmClient = await exports.resourceGroupHelper.createRmClient(azureAccountProvider, subscriptionId);
            const listRgRes = await exports.resourceGroupHelper.listResourceGroups(rmClient);
            if (listRgRes.isErr())
                throw listRgRes.error;
            const rgList = listRgRes.value;
            const options = rgList.map((rg) => {
                return {
                    id: rg[0],
                    label: rg[0],
                    description: rg[1],
                };
            });
            const existingResourceGroupNames = rgList.map((rg) => rg[0]);
            inputs.existingResourceGroupNames = existingResourceGroupNames; // cache existing resource group names for valiation usage
            return [{ id: exports.newResourceGroupOption, label: exports.newResourceGroupOption }, ...options];
        },
        skipSingleOption: true,
        returnObject: true,
        forgetLastValue: true,
    };
}
exports.selectResourceGroupQuestion = selectResourceGroupQuestion;
function selectResourceGroupLocationQuestion(azureAccountProvider, subscriptionId) {
    return {
        type: "singleSelect",
        name: constants_1.QuestionNames.NewResourceGroupLocation,
        title: (0, localizeUtils_1.getLocalizedString)("core.QuestionNewResourceGroupLocation.title"),
        staticOptions: [],
        dynamicOptions: async (inputs) => {
            const rmClient = await exports.resourceGroupHelper.createRmClient(azureAccountProvider, subscriptionId);
            const getLocationsRes = await exports.resourceGroupHelper.getLocations(azureAccountProvider, rmClient);
            if (getLocationsRes.isErr()) {
                throw getLocationsRes.error;
            }
            const recommended = getLocationsRes.value.filter((location) => {
                return constants_1.recommendedLocations.indexOf(location) >= 0;
            });
            const others = getLocationsRes.value.filter((location) => {
                return constants_1.recommendedLocations.indexOf(location) < 0;
            });
            return [
                ...recommended.map((location) => {
                    return {
                        id: location,
                        label: location,
                        groupName: (0, localizeUtils_1.getLocalizedString)("core.QuestionNewResourceGroupLocation.group.recommended"),
                    };
                }),
                ...others.map((location) => {
                    return {
                        id: location,
                        label: location,
                        groupName: (0, localizeUtils_1.getLocalizedString)("core.QuestionNewResourceGroupLocation.group.others"),
                    };
                }),
            ];
        },
        default: "Central US",
    };
}
exports.selectResourceGroupLocationQuestion = selectResourceGroupLocationQuestion;
function validateResourceGroupName(input, inputs) {
    const name = input;
    // https://docs.microsoft.com/en-us/rest/api/resources/resource-groups/create-or-update#uri-parameters
    const match = name.match(/^[-\w._()]+$/);
    if (!match) {
        return (0, localizeUtils_1.getLocalizedString)("core.QuestionNewResourceGroupName.validation");
    }
    // To avoid the issue in CLI that using async func for validation and filter will make users input answers twice,
    // we check the existence of a resource group from the list rather than call the api directly for now.
    // Bug: https://msazure.visualstudio.com/Microsoft%20Teams%20Extensibility/_workitems/edit/15066282
    // GitHub issue: https://github.com/SBoudrias/Inquirer.js/issues/1136
    if (inputs === null || inputs === void 0 ? void 0 : inputs.existingResourceGroupNames) {
        const maybeExist = inputs.existingResourceGroupNames.findIndex((o) => o.toLowerCase() === input.toLowerCase()) >= 0;
        if (maybeExist) {
            return `resource group already exists: ${name}`;
        }
    }
    return undefined;
}
exports.validateResourceGroupName = validateResourceGroupName;
function newResourceGroupNameQuestion(defaultResourceGroupName) {
    return {
        type: "text",
        name: constants_1.QuestionNames.NewResourceGroupName,
        title: (0, localizeUtils_1.getLocalizedString)("core.QuestionNewResourceGroupName.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.QuestionNewResourceGroupName.placeholder"),
        // default resource group name will change with env name
        forgetLastValue: true,
        default: defaultResourceGroupName,
        validation: {
            validFunc: validateResourceGroupName,
        },
    };
}
exports.newResourceGroupNameQuestion = newResourceGroupNameQuestion;
function resourceGroupQuestionNode(azureAccountProvider, subscriptionId, defaultResourceGroupName) {
    return {
        data: selectResourceGroupQuestion(azureAccountProvider, subscriptionId),
        children: [
            {
                condition: { equals: exports.newResourceGroupOption },
                data: newResourceGroupNameQuestion(defaultResourceGroupName),
                children: [
                    {
                        data: selectResourceGroupLocationQuestion(azureAccountProvider, subscriptionId),
                    },
                ],
            },
        ],
    };
}
exports.resourceGroupQuestionNode = resourceGroupQuestionNode;
class ResourceGroupHelper {
    async createNewResourceGroup(resourceGroupName, azureAccountProvider, subscriptionId, location) {
        const rmClient = await this.createRmClient(azureAccountProvider, subscriptionId);
        const maybeExist = await this.checkResourceGroupExistence(resourceGroupName, rmClient);
        if (maybeExist.isErr()) {
            return (0, teamsfx_api_1.err)(maybeExist.error);
        }
        if (maybeExist.value) {
            return (0, teamsfx_api_1.err)(new azure_1.ResourceGroupConflictError(resourceGroupName, subscriptionId));
        }
        try {
            const response = await rmClient.resourceGroups.createOrUpdate(resourceGroupName, {
                location: location,
                tags: { "created-by": "teamsfx" },
            });
            if (response.name === undefined) {
                return (0, teamsfx_api_1.err)(new azure_1.CreateResourceGroupError(resourceGroupName, subscriptionId, `illegal response: ${JSON.stringify(response)}`));
            }
            return (0, teamsfx_api_1.ok)(response.name);
        }
        catch (e) {
            delete e["request"];
            return (0, teamsfx_api_1.err)(new azure_1.CreateResourceGroupError(resourceGroupName, subscriptionId, e.message || JSON.stringify(e), e));
        }
    }
    async checkResourceGroupExistence(resourceGroupName, rmClient) {
        try {
            const checkRes = await rmClient.resourceGroups.checkExistence(resourceGroupName);
            return (0, teamsfx_api_1.ok)(!!checkRes.body);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new azure_1.CheckResourceGroupExistenceError(resourceGroupName, rmClient.subscriptionId, e.message || JSON.stringify(e), e));
        }
    }
    async getResourceGroupInfo(resourceGroupName, rmClient) {
        try {
            const getRes = await rmClient.resourceGroups.get(resourceGroupName);
            if (getRes.name) {
                return (0, teamsfx_api_1.ok)({
                    createNewResourceGroup: false,
                    name: getRes.name,
                    location: getRes.location,
                });
            }
            else
                return (0, teamsfx_api_1.ok)(undefined);
        }
        catch (e) {
            delete e["request"];
            return (0, teamsfx_api_1.err)(new azure_1.GetResourceGroupError(resourceGroupName, rmClient.subscriptionId, e.message || JSON.stringify(e), e));
        }
    }
    async listResourceGroups(rmClient) {
        var _a;
        try {
            const results = [];
            const res = rmClient.resourceGroups.list();
            let result;
            do {
                result = await res.next();
                if ((_a = result.value) === null || _a === void 0 ? void 0 : _a.name)
                    results.push([result.value.name, result.value.location]);
            } while (!result.done);
            return (0, teamsfx_api_1.ok)(results);
        }
        catch (e) {
            delete e["request"];
            return (0, teamsfx_api_1.err)(new azure_1.ListResourceGroupsError(rmClient.subscriptionId, e.message || JSON.stringify(e), e));
        }
    }
    async getLocations(azureAccountProvider, rmClient) {
        var _a, _b;
        const azureToken = await azureAccountProvider.getIdentityCredentialAsync();
        if (!azureToken)
            return (0, teamsfx_api_1.err)(new azure_1.InvalidAzureCredentialError());
        const subscriptionClient = new arm_subscriptions_1.SubscriptionClient(azureToken);
        const askSubRes = await azureAccountProvider.getSelectedSubscription(true);
        try {
            const res = subscriptionClient.subscriptions.listLocations(askSubRes.subscriptionId);
            const locations = [];
            let result;
            do {
                result = await res.next();
                if ((_a = result.value) === null || _a === void 0 ? void 0 : _a.displayName)
                    locations.push(result.value.displayName);
            } while (!result.done);
            const providerData = await rmClient.providers.get(MsResources);
            const resourceTypeData = (_b = providerData.resourceTypes) === null || _b === void 0 ? void 0 : _b.find((rt) => { var _a; return ((_a = rt.resourceType) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === ResourceGroups.toLowerCase(); });
            const resourceLocations = resourceTypeData === null || resourceTypeData === void 0 ? void 0 : resourceTypeData.locations;
            const rgLocations = resourceLocations === null || resourceLocations === void 0 ? void 0 : resourceLocations.filter((item) => locations.includes(item));
            if (!rgLocations || rgLocations.length == 0) {
                return (0, teamsfx_api_1.err)(new azure_1.ListResourceGroupLocationsError(rmClient.subscriptionId, "No available locations found!"));
            }
            return (0, teamsfx_api_1.ok)(rgLocations);
        }
        catch (e) {
            delete e["request"];
            return (0, teamsfx_api_1.err)(new azure_1.ListResourceGroupLocationsError(rmClient.subscriptionId, e.message || JSON.stringify(e), e));
        }
    }
    /**
     * Ask user to create a new resource group or use an existing resource group  V3
     */
    async askResourceGroupInfoV3(inputs, azureAccountProvider, rmClient, defaultResourceGroupName) {
        const node = resourceGroupQuestionNode(azureAccountProvider, rmClient.subscriptionId, defaultResourceGroupName);
        if (node) {
            const res = await (0, visitor_1.traverse)(node, inputs, globalVars_1.TOOLS.ui);
            if (res.isErr()) {
                return (0, teamsfx_api_1.err)(res.error);
            }
        }
        const targetResourceGroupNameOptionItem = inputs[constants_1.QuestionNames.TargetResourceGroupName];
        const targetResourceGroupName = targetResourceGroupNameOptionItem.id;
        if (!targetResourceGroupName || typeof targetResourceGroupName !== "string") {
            return (0, teamsfx_api_1.err)(new error_1.InputValidationError("targetResourceGroupName", "Invalid targetResourceGroupName", "ResourceGroupHelper"));
        }
        if (targetResourceGroupName === exports.newResourceGroupOption) {
            return (0, teamsfx_api_1.ok)({
                name: inputs[constants_1.QuestionNames.NewResourceGroupName],
                location: inputs[constants_1.QuestionNames.NewResourceGroupLocation],
                createNewResourceGroup: true,
            });
        }
        else {
            const location = targetResourceGroupNameOptionItem.description; // location must exist because the user can only select from this list.
            return (0, teamsfx_api_1.ok)({
                createNewResourceGroup: false,
                name: targetResourceGroupName,
                location: location,
            });
        }
    }
    async createRmClient(azureAccountProvider, subscriptionId) {
        const azureToken = await azureAccountProvider.getIdentityCredentialAsync();
        if (azureToken === undefined) {
            throw new azure_1.InvalidAzureCredentialError();
        }
        await azureAccountProvider.setSubscription(subscriptionId);
        const rmClient = new arm_resources_1.ResourceManagementClient(azureToken, subscriptionId);
        return rmClient;
    }
}
exports.resourceGroupHelper = new ResourceGroupHelper();
//# sourceMappingURL=ResourceGroupHelper.js.map
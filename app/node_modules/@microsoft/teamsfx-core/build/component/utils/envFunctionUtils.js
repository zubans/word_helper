"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.expandVariableWithFunction = exports.ManifestType = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const strip_bom_1 = tslib_1.__importDefault(require("strip-bom"));
const error_1 = require("../../error");
const common_1 = require("./common");
const localizeUtils_1 = require("../../common/localizeUtils");
const featureFlags_1 = require("../../common/featureFlags");
const source = "ResolveManifestFunction";
const telemetryEvent = "manifest-with-function";
const helpLink = "https://aka.ms/teamsfx-customize-manifest";
var TelemetryPropertyKey;
(function (TelemetryPropertyKey) {
    TelemetryPropertyKey["manifestType"] = "manifest-type";
    TelemetryPropertyKey["functionCount"] = "function-count";
})(TelemetryPropertyKey || (TelemetryPropertyKey = {}));
var ManifestType;
(function (ManifestType) {
    ManifestType["TeamsManifest"] = "teams-manifest";
    ManifestType["PluginManifest"] = "plugin-manifest";
    ManifestType["DeclarativeCopilotManifest"] = "declarative-copilot-manifest";
    ManifestType["ApiSpec"] = "api-spec";
})(ManifestType = exports.ManifestType || (exports.ManifestType = {}));
async function expandVariableWithFunction(content, ctx, envs, isJson, manifestType, fromPath) {
    if (!featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.EnvFileFunc)) {
        return (0, teamsfx_api_1.ok)(content);
    }
    const regex = /\$\[ *[a-zA-Z][a-zA-Z]*\([^\]]*\) *\]/g;
    const matches = content.match(regex);
    if (!matches) {
        return (0, teamsfx_api_1.ok)(content); // no function
    }
    let count = 0;
    for (const placeholder of matches) {
        const processedRes = await processFunction(placeholder.slice(2, -1).trim(), ctx, envs, fromPath);
        if (processedRes.isErr()) {
            return (0, teamsfx_api_1.err)(processedRes.error);
        }
        let value = processedRes.value;
        if (isJson && value) {
            value = JSON.stringify(value).slice(1, -1);
        }
        if (value) {
            count += 1;
            content = content.replace(placeholder, value);
        }
    }
    if (count > 0) {
        ctx.telemetryReporter.sendTelemetryEvent(telemetryEvent, {
            [TelemetryPropertyKey.manifestType]: manifestType.toString(),
            [TelemetryPropertyKey.functionCount]: count.toString(),
        });
    }
    return (0, teamsfx_api_1.ok)(content);
}
exports.expandVariableWithFunction = expandVariableWithFunction;
async function processFunction(content, ctx, envs, path) {
    const firstTrimmedContent = content.trim();
    if (!firstTrimmedContent.startsWith("file(") || !firstTrimmedContent.endsWith(")")) {
        ctx.logProvider.error((0, localizeUtils_1.getLocalizedString)("core.envFunc.unsupportedFunction.errorLog", firstTrimmedContent, "file"));
        return (0, teamsfx_api_1.err)(new InvalidFunctionError(ctx.platform));
    }
    // file()
    const trimmedParameter = content.slice(5, -1).trim();
    if (trimmedParameter[0] === "'" && trimmedParameter[trimmedParameter.length - 1] === "'") {
        // static string as function parameter
        const res = await readFileContent(trimmedParameter.substring(1, trimmedParameter.length - 1), ctx, envs, path);
        return res;
    }
    else if (trimmedParameter.startsWith("${{") && trimmedParameter.endsWith("}}")) {
        // env variable inside
        const resolvedParameter = (0, common_1.expandEnvironmentVariable)(trimmedParameter, envs);
        const res = readFileContent(resolvedParameter, ctx, envs, path);
        return res;
    }
    else if (trimmedParameter.startsWith("file(") && trimmedParameter.endsWith(")")) {
        // nested function inside
        const processsedRes = await processFunction(trimmedParameter, ctx, envs, path);
        if (processsedRes.isErr()) {
            return (0, teamsfx_api_1.err)(processsedRes.error);
        }
        const readFileRes = await readFileContent(processsedRes.value, ctx, envs, path);
        return readFileRes;
    }
    else {
        // invalid content inside function
        ctx.logProvider.error((0, localizeUtils_1.getLocalizedString)("core.envFunc.invalidFunctionParameter.errorLog", trimmedParameter, "file"));
        return (0, teamsfx_api_1.err)(new InvalidFunctionParameter(ctx.platform));
    }
}
async function readFileContent(filePath, ctx, envs, fromPath) {
    const ext = path_1.default.extname(filePath);
    if (ext.toLowerCase() !== ".txt" && ext.toLowerCase() !== ".md") {
        ctx.logProvider.error((0, localizeUtils_1.getLocalizedString)("core.envFunc.unsupportedFile.errorLog", filePath, "txt"));
        return (0, teamsfx_api_1.err)(new UnsupportedFileFormatError(ctx.platform));
    }
    const absolutePath = getAbsolutePath(filePath, fromPath);
    if (await fs_extra_1.default.pathExists(absolutePath)) {
        try {
            let fileContent = await fs_extra_1.default.readFile(absolutePath, "utf8");
            fileContent = (0, strip_bom_1.default)(fileContent);
            let processedFileContent = (0, common_1.expandEnvironmentVariable)(fileContent, envs);
            processedFileContent = processedFileContent.replace(/\r\n/g, "\n");
            return (0, teamsfx_api_1.ok)(processedFileContent);
        }
        catch (e) {
            ctx.logProvider.error((0, localizeUtils_1.getLocalizedString)("core.envFunc.readFile.errorLog", absolutePath, e === null || e === void 0 ? void 0 : e.toString()));
            return (0, teamsfx_api_1.err)(new ReadFileError(ctx.platform, absolutePath));
        }
    }
    else {
        return (0, teamsfx_api_1.err)(new error_1.FileNotFoundError(source, filePath));
    }
}
function getAbsolutePath(relativeOrAbsolutePath, fromPath) {
    return path_1.default.isAbsolute(relativeOrAbsolutePath)
        ? relativeOrAbsolutePath
        : path_1.default.join(path_1.default.dirname(fromPath), relativeOrAbsolutePath);
}
class UnsupportedFileFormatError extends teamsfx_api_1.UserError {
    constructor(platform) {
        const message = platform === teamsfx_api_1.Platform.VSCode
            ? (0, localizeUtils_1.getLocalizedString)("core.envFunc.unsupportedFile.errorMessage", (0, localizeUtils_1.getLocalizedString)("core.error.checkOutput.vsc"))
            : (0, localizeUtils_1.getLocalizedString)("core.envFunc.unsupportedFile.errorMessage");
        const errorOptions = {
            source,
            name: "UnsupportedFileFormat",
            message,
            displayMessage: message,
            helpLink,
        };
        super(errorOptions);
    }
}
class InvalidFunctionError extends teamsfx_api_1.UserError {
    constructor(platform) {
        const message = platform === teamsfx_api_1.Platform.VSCode
            ? (0, localizeUtils_1.getLocalizedString)("core.envFunc.unsupportedFunction.errorMessage", (0, localizeUtils_1.getLocalizedString)("core.error.checkOutput.vsc"))
            : (0, localizeUtils_1.getLocalizedString)("core.envFunc.unsupportedFunction.errorMessage", "");
        const errorOptions = {
            source,
            name: "InvalidFunction",
            message,
            displayMessage: message,
            helpLink,
        };
        super(errorOptions);
    }
}
class InvalidFunctionParameter extends teamsfx_api_1.UserError {
    constructor(platform) {
        const message = platform === teamsfx_api_1.Platform.VSCode
            ? (0, localizeUtils_1.getLocalizedString)("core.envFunc.invalidFunctionParameter.errorMessage", "file", (0, localizeUtils_1.getLocalizedString)("core.error.checkOutput.vsc"))
            : (0, localizeUtils_1.getLocalizedString)("core.envFunc.invalidFunctionParameter.errorMessage", "file", "");
        const errorOptions = {
            source,
            name: "InvalidFunctionParameter",
            message,
            displayMessage: message,
            helpLink,
        };
        super(errorOptions);
    }
}
class ReadFileError extends teamsfx_api_1.UserError {
    constructor(platform, filePath) {
        const message = platform === teamsfx_api_1.Platform.VSCode
            ? (0, localizeUtils_1.getLocalizedString)("core.envFunc.readFile.errorMessage", filePath, (0, localizeUtils_1.getLocalizedString)("core.error.checkOutput.vsc"))
            : (0, localizeUtils_1.getLocalizedString)("core.envFunc.readFile.errorMessage", filePath, "");
        const errorOptions = {
            source,
            name: "ReadFileError",
            message,
            displayMessage: message,
            helpLink,
        };
        super(errorOptions);
    }
}
//# sourceMappingURL=envFunctionUtils.js.map
"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.GitHubHelpers = exports.TestToolChecker = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const node_fetch_1 = tslib_1.__importDefault(require("node-fetch"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const max_satisfying_1 = tslib_1.__importDefault(require("semver/ranges/max-satisfying"));
const url = tslib_1.__importStar(require("url"));
const uuid = tslib_1.__importStar(require("uuid"));
const localizeUtils_1 = require("../../../common/localizeUtils");
const error_1 = require("../../../error");
const helpLink_1 = require("../constant/helpLink");
const message_1 = require("../constant/message");
const telemetry_1 = require("../constant/telemetry");
const depsChecker_1 = require("../depsChecker");
const util_1 = require("../util");
const downloadHelper_1 = require("../util/downloadHelper");
const fileHelper_1 = require("../util/fileHelper");
const system_1 = require("../util/system");
var InstallType;
(function (InstallType) {
    InstallType["Global"] = "global";
    InstallType["Portable"] = "portable";
})(InstallType || (InstallType = {}));
const InstallTimeout = 5 * 60 * 1000;
class TestToolChecker {
    constructor() {
        this.name = "Teams App Test Tool";
        this.npmPackageName = "@microsoft/teams-app-test-tool";
        this.checkUpdateTimeout = 10 * 1000;
        this.npmCommandName = (0, system_1.isWindows)() ? "teamsapptester.cmd" : "teamsapptester";
        this.binaryCommandName = (0, system_1.isWindows)() ? "teamsapptester.exe" : "teamsapptester";
        this.portableDirNameNpm = "testTool";
        this.portableDirNameBinary = "testToolBinary";
        // Limit 1 hour check update internval because of GitHub API throttling limitation
        // https://docs.github.com/en/rest/using-the-rest-api/rate-limits-for-the-rest-api?apiVersion=2022-11-28#primary-rate-limit-for-unauthenticated-users
        this.defaultUpdateInterval = 1 * 60 * 60 * 1000;
        this.telemetryProperties = {};
    }
    async getInstallationInfo(installOptions) {
        this.telemetryProperties[telemetry_1.TelemetryProperties.InstallTestToolReleaseType] =
            installOptions.releaseType;
        const symlinkDir = installOptions.symlinkDir
            ? path.resolve(installOptions.projectPath, installOptions.symlinkDir)
            : undefined;
        // check version in symlink dir
        if (symlinkDir) {
            const versionRes = await this.checkVersion(installOptions.releaseType, installOptions.versionRange, this.getBinFolder(installOptions.releaseType, symlinkDir));
            if (versionRes.isOk()) {
                this.telemetryProperties[telemetry_1.TelemetryProperties.SymlinkTestToolVersion] = versionRes.value;
                return await this.getSuccessDepsInfo(versionRes.value, symlinkDir);
            }
            else {
                this.telemetryProperties[telemetry_1.TelemetryProperties.SymlinkTestToolVersionError] =
                    versionRes.error.message;
                await (0, fileHelper_1.unlinkSymlink)(symlinkDir);
            }
        }
        // check version in ${HOME}/.fx/bin and createSymlink if asked for
        const version = await this.findLatestInstalledPortableVersion(installOptions.releaseType, installOptions.versionRange);
        if (version) {
            const portablePath = path.join(this.getPortableVersionsDir(installOptions.releaseType), version);
            this.telemetryProperties[telemetry_1.TelemetryProperties.SelectedPortableTestToolVersion] = version;
            if (symlinkDir) {
                await (0, fileHelper_1.createSymlink)(portablePath, symlinkDir);
                return await this.getSuccessDepsInfo(version, symlinkDir);
            }
            else {
                return await this.getSuccessDepsInfo(version, portablePath);
            }
        }
        // check global version in PATH
        const globalVersionRes = await this.checkVersion(installOptions.releaseType, installOptions.versionRange);
        if (globalVersionRes.isOk()) {
            const version = globalVersionRes.value;
            this.telemetryProperties[telemetry_1.TelemetryProperties.GlobalTestToolVersion] = version;
            return this.getSuccessDepsInfo(version, undefined);
        }
        else {
            this.telemetryProperties[telemetry_1.TelemetryProperties.GlobalTestToolVersionError] =
                globalVersionRes.error.message;
        }
        return this.createFailureDepsInfo(installOptions.versionRange, undefined);
    }
    async resolve(installOptions) {
        this.telemetryProperties[telemetry_1.TelemetryProperties.InstallTestToolReleaseType] =
            installOptions.releaseType;
        let installationInfo;
        try {
            if (installOptions.releaseType === depsChecker_1.TestToolReleaseType.Npm && !(await this.hasNode())) {
                throw new error_1.NodejsNotFoundError();
            }
            installationInfo = await this.getInstallationInfo(installOptions);
            if (!installationInfo.isInstalled) {
                const symlinkDir = installOptions.symlinkDir
                    ? path.resolve(installOptions.projectPath, installOptions.symlinkDir)
                    : undefined;
                installationInfo = await this.install(installOptions.releaseType, installOptions.projectPath, installOptions.versionRange, symlinkDir);
            }
            else {
                if (installationInfo.installType === InstallType.Portable) {
                    const updateInstallationInfo = await this.autoUpdate(installOptions);
                    if (updateInstallationInfo) {
                        installationInfo = updateInstallationInfo;
                    }
                }
            }
            return installationInfo;
        }
        catch (error) {
            if (error instanceof teamsfx_api_1.UserError) {
                return await this.createFailureDepsInfo(installOptions.versionRange, error);
            }
            return await this.createFailureDepsInfo(installOptions.versionRange, new error_1.DepsCheckerError(error.message, helpLink_1.v3DefaultHelpLink));
        }
    }
    async install(releaseType, projectPath, versionRange, symlinkDir) {
        if (releaseType === depsChecker_1.TestToolReleaseType.Npm && !(await this.hasNPM())) {
            throw new error_1.DepsCheckerError(message_1.Messages.needInstallNpm(), helpLink_1.v3DefaultHelpLink);
        }
        const tmpVersion = `tmp-${uuid.v4().slice(0, 6)}`;
        const tmpPath = this.getPortableInstallPath(releaseType, tmpVersion);
        await fs.ensureDir(tmpPath);
        if (releaseType === depsChecker_1.TestToolReleaseType.Npm) {
            await this.npmInstall(projectPath, tmpPath, versionRange);
        }
        else {
            await this.binaryInstall(tmpPath, versionRange);
        }
        const versionRes = await this.checkVersion(releaseType, versionRange, this.getBinFolder(releaseType, tmpPath));
        if (versionRes.isErr()) {
            await (0, fileHelper_1.cleanup)(tmpPath);
            this.telemetryProperties[telemetry_1.TelemetryProperties.InstallTestToolError] = versionRes.error.message;
            throw new error_1.DepsCheckerError(message_1.Messages.failToValidateTestTool(versionRes.error.message), helpLink_1.v3DefaultHelpLink);
        }
        const actualVersion = versionRes.value;
        this.telemetryProperties[telemetry_1.TelemetryProperties.InstalledTestToolVersion] = actualVersion;
        const portablePath = this.getPortableInstallPath(releaseType, actualVersion);
        await (0, fileHelper_1.rename)(tmpPath, portablePath);
        if (symlinkDir) {
            await (0, fileHelper_1.createSymlink)(portablePath, symlinkDir);
        }
        await this.writeInstallInfoFile(projectPath);
        if (symlinkDir) {
            return await this.getSuccessDepsInfo(actualVersion, symlinkDir);
        }
        else {
            return await this.getSuccessDepsInfo(actualVersion, portablePath);
        }
    }
    async hasNewVersionReleasedInRange(releaseType, latestInstalledVersion, versionRange) {
        if (releaseType === depsChecker_1.TestToolReleaseType.Npm) {
            try {
                const result = await util_1.cpUtils.executeCommand(undefined, undefined, 
                // avoid powershell execution policy issue.
                { shell: (0, system_1.isWindows)() ? "cmd.exe" : true, timeout: this.checkUpdateTimeout }, "npm", "view", `"${this.npmPackageName}@${versionRange}"`, "version", "--json");
                // when there are one result, it will return string
                // when there are multiple results, it will return array of strings
                let versionList = JSON.parse(result);
                if (typeof versionList === "string") {
                    versionList = [versionList];
                }
                if (!Array.isArray(versionList)) {
                    // do update if npm returned invalid result
                    return true;
                }
                return versionList.filter((v) => semver_1.default.gt(v, latestInstalledVersion)).length > 0;
            }
            catch (_a) {
                // just a best effort optimization to save one download if no recent version has been released
                // do update if check failed
                return true;
            }
        }
        else {
            // get version list
            const releases = await GitHubHelpers.listGitHubReleases();
            const versionList = releases.map((release) => release.version);
            return versionList.filter((v) => semver_1.default.gt(v, latestInstalledVersion)).length > 0;
        }
    }
    // return undefined if not updated or update failure
    async autoUpdate(installOptions) {
        var _a;
        const installInfo = await this.readInstallInfoFile(installOptions.projectPath);
        const now = new Date().getTime();
        const updateExpired = !installInfo || now > installInfo.lastCheckTimestamp + this.defaultUpdateInterval;
        if (!updateExpired) {
            return undefined;
        }
        const latestInstalledVersion = await this.findLatestInstalledPortableVersion(installOptions.releaseType, installOptions.versionRange);
        if (latestInstalledVersion !== undefined &&
            !(await this.hasNewVersionReleasedInRange(installOptions.releaseType, latestInstalledVersion, installOptions.versionRange))) {
            return undefined;
        }
        this.telemetryProperties[telemetry_1.TelemetryProperties.TestToolLastUpdateTimestamp] =
            ((_a = installInfo === null || installInfo === void 0 ? void 0 : installInfo.lastCheckTimestamp) === null || _a === void 0 ? void 0 : _a.toString()) || "<never>";
        this.telemetryProperties[telemetry_1.TelemetryProperties.TestToolUpdatePreviousVersion] =
            latestInstalledVersion || "<undefined>";
        const symlinkDir = installOptions.symlinkDir
            ? path.resolve(installOptions.projectPath, installOptions.symlinkDir)
            : undefined;
        try {
            return await this.install(installOptions.releaseType, installOptions.projectPath, installOptions.versionRange, symlinkDir);
        }
        catch (e) {
            // ignore update failure and use existing version
            if (e instanceof Error) {
                this.telemetryProperties[telemetry_1.TelemetryProperties.TestToolUpdateError] = e.message;
            }
            await this.writeInstallInfoFile(installOptions.projectPath);
            return undefined;
        }
    }
    validateInstallInfoFile(data) {
        if ("lastCheckTimestamp" in data) {
            if (typeof data.lastCheckTimestamp === "number") {
                return true;
            }
        }
        return false;
    }
    async readInstallInfoFile(projectPath) {
        const installInfoPath = this.getInstallInfoPath(projectPath);
        try {
            const data = await fs.readJson(installInfoPath);
            if (this.validateInstallInfoFile(data)) {
                return data;
            }
        }
        catch (_a) {
            // ignore invalid installation info file
        }
        await (0, fileHelper_1.cleanup)(installInfoPath);
        return undefined;
    }
    async writeInstallInfoFile(projectPath) {
        const projectInfoPath = this.getInstallInfoPath(projectPath);
        const installInfo = {
            lastCheckTimestamp: new Date().getTime(),
        };
        await fs.ensureDir(path.dirname(projectInfoPath));
        await fs.writeJson(projectInfoPath, installInfo);
    }
    async findLatestInstalledPortableVersion(releaseType, versionRange) {
        var _a;
        let portablePath;
        try {
            const portableVersionsDir = this.getPortableVersionsDir(releaseType);
            const dirs = await fs.readdir(portableVersionsDir, { withFileTypes: true });
            const satisfiedVersions = dirs
                .filter((dir) => dir.isDirectory() && semver_1.default.valid(dir.name) && semver_1.default.satisfies(dir.name, versionRange))
                .map((dir) => dir.name);
            // sort by version desc
            satisfiedVersions.sort((a, b) => semver_1.default.rcompare(a, b));
            // find the latest version that is working
            for (const version of satisfiedVersions) {
                portablePath = path.join(portableVersionsDir, version);
                const checkVersionRes = await this.checkVersion(releaseType, versionRange, this.getBinFolder(releaseType, portablePath));
                if (checkVersionRes.isOk()) {
                    return version;
                }
                this.telemetryProperties[telemetry_1.TelemetryProperties.VersioningTestToolVersionError] =
                    ((_a = this.telemetryProperties[telemetry_1.TelemetryProperties.VersioningTestToolVersionError]) !== null && _a !== void 0 ? _a : "") +
                        `[${version}] ${checkVersionRes.error.message}`;
            }
        }
        catch (_b) {
            // ignore errors if portable dir doesn't exist
        }
        return undefined;
    }
    async checkVersion(releaseType, versionRange, binFolder) {
        try {
            const actualVersion = await this.queryVersion(releaseType, binFolder);
            if (semver_1.default.satisfies(actualVersion, versionRange)) {
                return (0, teamsfx_api_1.ok)(actualVersion);
            }
            else {
                return (0, teamsfx_api_1.err)(new error_1.DepsCheckerError(message_1.Messages.testToolVersionNotMatch(actualVersion, versionRange), helpLink_1.v3DefaultHelpLink));
            }
        }
        catch (error) {
            return (0, teamsfx_api_1.err)(new error_1.DepsCheckerError(error.message, helpLink_1.v3DefaultHelpLink));
        }
    }
    async queryVersion(releaseType, binFolder) {
        const commandName = releaseType === depsChecker_1.TestToolReleaseType.Npm ? this.npmCommandName : this.binaryCommandName;
        const execPath = binFolder ? path.resolve(binFolder, commandName) : commandName;
        const output = await util_1.cpUtils.executeCommand(undefined, undefined, 
        // avoid powershell execution policy issue.
        { shell: (0, system_1.isWindows)() ? "cmd.exe" : true, timeout: InstallTimeout }, `"${execPath}"`, "--version");
        return output.trim();
    }
    async hasNode() {
        try {
            await util_1.cpUtils.executeCommand(undefined, undefined, { shell: true }, "node", "--version");
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async hasNPM() {
        try {
            await util_1.cpUtils.executeCommand(undefined, undefined, { shell: true }, "npm", "--version");
            return true;
        }
        catch (error) {
            return false;
        }
    }
    async npmInstall(projectPath, prefix, versionRange) {
        var _a, _b;
        let pkg;
        // Before we release package to npm registry we can use tgz to test
        pkg || (pkg = await this.findLocalNpmPackage(projectPath));
        pkg || (pkg = await this.findLocalNpmPackage(path.join(projectPath, "devTools")));
        pkg || (pkg = `${this.npmPackageName}@${versionRange}`);
        try {
            await util_1.cpUtils.executeCommand(undefined, undefined, 
            // avoid powershell execution policy issue.
            { shell: (0, system_1.isWindows)() ? "cmd.exe" : true, timeout: InstallTimeout }, `npm`, "install", `"${pkg}"`, "--prefix", `"${prefix}"`, "--no-audit");
        }
        catch (error) {
            await (0, fileHelper_1.cleanup)(prefix);
            // @ is incorrectly identified as an email format.
            this.telemetryProperties[telemetry_1.TelemetryProperties.InstallTestToolError] = (_b = (_a = error.message) === null || _a === void 0 ? void 0 : _a.split(pkg)) === null || _b === void 0 ? void 0 : _b.join(pkg);
            throw new error_1.DepsCheckerError((0, localizeUtils_1.getLocalizedString)("error.common.InstallSoftwareError", this.name), helpLink_1.v3DefaultHelpLink);
        }
    }
    // TODO: remove after release to npm
    async findLocalNpmPackage(dir) {
        try {
            const files = await fs.readdir(dir);
            for (const fileName of files) {
                const fullPath = path.join(dir, fileName);
                if (fileName.match(/microsoft-teams-app-test-tool.*\.tgz/i)) {
                    try {
                        const st = await fs.stat(fullPath);
                        if (st.isFile()) {
                            // encode special characters in path
                            return url.pathToFileURL(fullPath).toString();
                        }
                    }
                    catch (_a) {
                        // ignore invalid files
                    }
                }
            }
        }
        catch (_b) {
            // local npm package error should not block
        }
        return undefined;
    }
    async binaryInstall(installPath, versionRange) {
        const releases = await GitHubHelpers.listGitHubReleases();
        const targetVersion = (0, max_satisfying_1.default)(releases.map((release) => release.version), versionRange);
        if (targetVersion === null) {
            throw new error_1.DepsCheckerError((0, localizeUtils_1.getLocalizedString)("error.common.VersionError", versionRange), helpLink_1.v3DefaultHelpLink);
        }
        const release = releases.find((value) => value.version === targetVersion);
        await (0, downloadHelper_1.downloadToTempFile)(release.url, {
            timeout: InstallTimeout,
            headers: {
                Accept: "application/octet-stream",
            },
        }, async (filePath) => {
            await (0, downloadHelper_1.unzip)(filePath, installPath);
        });
    }
    getBinFolder(releaseType, installPath) {
        if (releaseType === depsChecker_1.TestToolReleaseType.Npm) {
            return path.join(installPath, "node_modules", ".bin");
        }
        else {
            return path.join(installPath);
        }
    }
    getPortableVersionsDir(releaseType) {
        if (releaseType === depsChecker_1.TestToolReleaseType.Npm) {
            return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", this.portableDirNameNpm);
        }
        else {
            return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", this.portableDirNameBinary);
        }
    }
    getPortableInstallPath(releaseType, version) {
        return path.join(this.getPortableVersionsDir(releaseType), version);
    }
    getInstallInfoPath(projectDir) {
        return path.join(projectDir, "devTools", ".testTool.installInfo.json");
    }
    async getSuccessDepsInfo(version, binFolder) {
        return Promise.resolve({
            name: this.name,
            type: depsChecker_1.DepsType.TestTool,
            isInstalled: true,
            command: this.npmCommandName,
            details: {
                isLinuxSupported: true,
                supportedVersions: [],
                binFolders: binFolder ? [binFolder] : [],
                installVersion: version,
            },
            telemetryProperties: this.telemetryProperties,
            error: undefined,
            installType: binFolder ? InstallType.Portable : InstallType.Global,
        });
    }
    async createFailureDepsInfo(version, error) {
        return Promise.resolve({
            name: this.name,
            type: depsChecker_1.DepsType.TestTool,
            isInstalled: false,
            command: this.npmCommandName,
            details: {
                isLinuxSupported: true,
                supportedVersions: [],
                binFolders: [],
                installVersion: version,
            },
            telemetryProperties: this.telemetryProperties,
            error: error,
        });
    }
}
exports.TestToolChecker = TestToolChecker;
class GitHubHelpers {
    static async listGitHubReleases() {
        // GitHub API without auth
        const response = await (0, node_fetch_1.default)("https://api.github.com/repos/OfficeDev/TeamsFx/releases", {
            headers: {
                Accept: "application/vnd.github+json",
                "X-Github-Api-Version": "2022-11-28",
            },
            timeout: InstallTimeout,
        });
        const releases = await response.json();
        const result = [];
        for (const release of releases) {
            const parts = release.tag_name.split("@");
            const assets = release.assets.filter((asset) => asset.name.includes(`${this.artifactNamePrefix}-${os.platform()}-${os.arch()}`));
            if (parts.length === 2) {
                const pkgName = parts[0];
                const version = parts[1];
                if (pkgName == this.releasePackageName && assets.length > 0) {
                    result.push({
                        version,
                        url: release.assets[0].url,
                    });
                }
            }
        }
        return result;
    }
}
exports.GitHubHelpers = GitHubHelpers;
GitHubHelpers.releasePackageName = "teams-app-test-tool";
GitHubHelpers.artifactNamePrefix = "teamsapptester";
//# sourceMappingURL=testToolChecker.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VxTestAppChecker = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const fs = tslib_1.__importStar(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const depCheck_1 = require("../../../error/depCheck");
const depsChecker_1 = require("../depsChecker");
const util_1 = require("../util");
const downloadHelper_1 = require("../util/downloadHelper");
const fileHelper_1 = require("../util/fileHelper");
const VxTestAppName = "Video Extensibility Test App";
// https://www.electronjs.org/docs/latest/tutorial/application-distribution#manual-packaging
const VxTestAppExecutableName = (0, util_1.isWindows)()
    ? "video-extensibility-test-app.exe"
    : (0, util_1.isMacOS)()
        ? "video-extensibility-test-app.app"
        : "video-extensibility-test-app";
const VxTestAppDirRelPath = path.join(".tools", "video-extensibility-test-app");
const VxTestAppGlobalBasePath = path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, `bin`, `video-extensibility-test-app`);
const VxTestAppDownloadTimeoutMillis = 5 * 60 * 1000;
// TODO: change to GitHub release after new VxTestApp is released.
const VxTestAppDownloadUrlTemplate = "https://github.com/microsoft/teams-videoapp-sample/releases/download/testApp-v@version/video-extensibility-test-app-@platform-@arch-portable.zip";
class VxTestAppChecker {
    constructor(logger, telemetry) {
        this._logger = logger;
        this._telemetry = telemetry;
    }
    async resolve(installOptions) {
        if (!this.isValidInstallOptions(installOptions)) {
            return VxTestAppChecker.newDependencyStatusForInstallError(
            // documentation no longer exists, replaced with empty string.
            new depCheck_1.VxTestAppInvalidInstallOptionsError());
        }
        // check installation in project dir
        const installInfo = await this.getInstallationInfo(installOptions);
        if (installInfo.isInstalled) {
            return installInfo;
        }
        // ensure vxTestApp is installed in global dir
        const globalInstallDir = path.join(VxTestAppGlobalBasePath, installOptions.version);
        if (!(await this.isValidInstalltion(globalInstallDir, installOptions.version))) {
            await fs.remove(globalInstallDir);
            await this.installVersion(installOptions.version, globalInstallDir);
        }
        // ensure vxTestApp is installed in project dir
        const projectInstallDir = path.join(installOptions.projectPath, VxTestAppDirRelPath);
        await (0, fileHelper_1.createSymlink)(globalInstallDir, projectInstallDir);
        // TODO: need to chmod to add executable permission for non-Windows OS
        if (!(await this.isValidInstalltion(projectInstallDir, installOptions.version))) {
            return VxTestAppChecker.newDependencyStatusForInstallError(
            // documentation no longer exists, replaced with empty string.
            new depCheck_1.VxTestAppValidationError());
        }
        return {
            name: VxTestAppName,
            type: depsChecker_1.DepsType.VxTestApp,
            isInstalled: true,
            command: VxTestAppExecutableName,
            details: {
                isLinuxSupported: false,
                supportedVersions: [installOptions.version],
                binFolders: [projectInstallDir],
            },
            error: undefined,
        };
    }
    async getInstallationInfo(installOptions) {
        if (!this.isValidInstallOptions(installOptions)) {
            return VxTestAppChecker.newDependencyStatusForInstallError(
            // documentation no longer exists, replaced with empty string.
            new depCheck_1.VxTestAppValidationError());
        }
        const installDir = path.join(installOptions.projectPath, VxTestAppDirRelPath);
        if (!(await this.isValidInstalltion(installDir, installOptions.version))) {
            return VxTestAppChecker.newDependencyStatusForNotInstalled(installOptions.version);
        }
        const projectInstallDir = path.join(installOptions.projectPath, VxTestAppDirRelPath);
        return {
            name: VxTestAppName,
            type: depsChecker_1.DepsType.VxTestApp,
            isInstalled: true,
            command: VxTestAppExecutableName,
            details: {
                isLinuxSupported: false,
                supportedVersions: [installOptions.version],
                binFolders: [projectInstallDir],
            },
            error: undefined,
        };
    }
    async installVersion(version, installDir) {
        const downloadUrl = this.getDownloadUrl(version);
        await (0, downloadHelper_1.downloadToTempFile)(downloadUrl, { timeout: VxTestAppDownloadTimeoutMillis }, async (zipFilePath) => {
            await (0, downloadHelper_1.unzip)(zipFilePath, installDir);
        });
    }
    getDownloadUrl(version) {
        const url = VxTestAppDownloadUrlTemplate.replace(/@version/g, version)
            .replace(/@platform/g, os.platform())
            .replace(/@arch/g, os.arch());
        return url;
    }
    async isValidInstalltion(installDir, version) {
        const vxTestAppExecutable = path.join(installDir, VxTestAppExecutableName);
        if (!(await fs.pathExists(vxTestAppExecutable))) {
            return false;
        }
        // TODO(aochengwang):
        //   1. check executable permission for non-Windows OS
        //   2. check whether installed version is correct?
        return true;
    }
    isValidInstallOptions(installOptions) {
        return !((installOptions === null || installOptions === void 0 ? void 0 : installOptions.projectPath) === undefined && (installOptions === null || installOptions === void 0 ? void 0 : installOptions.version) === undefined);
    }
    static newDependencyStatusForNotInstalled(version) {
        return {
            name: VxTestAppName,
            type: depsChecker_1.DepsType.VxTestApp,
            isInstalled: false,
            command: VxTestAppExecutableName,
            details: {
                isLinuxSupported: false,
                supportedVersions: version === undefined ? [] : [version],
            },
            error: undefined,
        };
    }
    static newDependencyStatusForInstallError(error, version) {
        return {
            name: VxTestAppName,
            type: depsChecker_1.DepsType.VxTestApp,
            isInstalled: false,
            command: VxTestAppExecutableName,
            details: {
                isLinuxSupported: false,
                supportedVersions: version === undefined ? [] : [version],
            },
            error: error,
        };
    }
}
exports.VxTestAppChecker = VxTestAppChecker;
//# sourceMappingURL=vxTestAppChecker.js.map
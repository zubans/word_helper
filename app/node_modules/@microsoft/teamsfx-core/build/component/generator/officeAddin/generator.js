"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.OfficeAddinGeneratorNew = exports.getHost = exports.OfficeAddinGenerator = void 0;
const tslib_1 = require("tslib");
/**
 * @author yefuwang@microsoft.com
 */
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const childProcess = tslib_1.__importStar(require("child_process"));
const lodash_1 = require("lodash");
const office_addin_manifest_1 = require("office-addin-manifest");
const office_addin_project_1 = require("office-addin-project");
const path_1 = require("path");
const util_1 = require("util");
const localizeUtils_1 = require("../../../common/localizeUtils");
const error_1 = require("../../../error");
const constants_1 = require("../../../question/constants");
const create_1 = require("../../../question/create");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const generator_1 = require("../generator");
const templateGenerator_1 = require("../templates/templateGenerator");
const utils_1 = require("../utils");
const helperMethods_1 = require("./helperMethods");
const envUtil_1 = require("../../utils/envUtil");
const stringUtils_1 = require("../../../common/stringUtils");
const componentName = "office-addin";
const telemetryEvent = "generate";
const templateName = "office-addin";
const templateNameForWXPO = "office-json-addin";
/**
 * case 1: project-type=office-xml-addin-type AND addin-host=outlook
 * case 2: project-type=office-addin-type (addin-host=undefined)
 * case 3: project-type=outlook-addin-type (addin-host=undefined)
 */
class OfficeAddinGenerator {
    static async generate(context, inputs, destinationPath) {
        const result = await OfficeAddinGenerator.doScaffolding(context, inputs, destinationPath);
        if (result.isErr()) {
            return (0, teamsfx_api_1.err)(result.error);
        }
        // If lang is undefined, it means the project is created from a folder.
        const lang = (0, lodash_1.toLower)(inputs[constants_1.QuestionNames.ProgrammingLanguage]);
        const langKey = inputs[constants_1.QuestionNames.Capabilities] === constants_1.CapabilityOptions.outlookAddinImport().id ||
            inputs[constants_1.QuestionNames.Capabilities] === constants_1.CapabilityOptions.officeAddinImport().id
            ? "ts"
            : (0, utils_1.convertToLangKey)(lang);
        const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, inputs[constants_1.QuestionNames.ProjectType] === constants_1.ProjectTypeOptions.officeAddin().id
            ? templateNameForWXPO
            : templateName, langKey);
        if (templateRes.isErr())
            return (0, teamsfx_api_1.err)(templateRes.error);
        return (0, teamsfx_api_1.ok)(undefined);
    }
    static async childProcessExec(cmdLine) {
        return (0, util_1.promisify)(childProcess.exec)(cmdLine);
    }
    static async doScaffolding(context, inputs, destinationPath) {
        const name = inputs[constants_1.QuestionNames.AppName];
        const addinRoot = destinationPath;
        const fromFolder = inputs[constants_1.QuestionNames.OfficeAddinFolder];
        const projectType = inputs[constants_1.QuestionNames.ProjectType];
        const capability = inputs[constants_1.QuestionNames.Capabilities];
        const inputHost = inputs[constants_1.QuestionNames.OfficeAddinHost];
        const workingDir = process.cwd();
        const importProgressStr = (0, localizeUtils_1.getLocalizedString)("core.generator.officeAddin.importOfficeProject.title");
        const importProgress = context.userInteraction.createProgressBar(importProgressStr, 3);
        process.chdir(addinRoot);
        try {
            if (!fromFolder) {
                let host = inputHost;
                if (projectType === constants_1.ProjectTypeOptions.outlookAddin().id) {
                    host = "outlook";
                }
                else if (projectType === constants_1.ProjectTypeOptions.officeMetaOS().id ||
                    projectType === constants_1.ProjectTypeOptions.officeAddin().id) {
                    if (capability === "json-taskpane") {
                        host = "wxpo"; // wxpo - support word, excel, powerpoint, outlook
                    }
                    else if (capability === constants_1.CapabilityOptions.officeContentAddin().id) {
                        host = "xp"; // content add-in support excel, powerpoint
                    }
                }
                if (!["outlook", "wxpo", "xp"].includes(host)) {
                    return (0, teamsfx_api_1.err)(new error_1.InputValidationError(constants_1.QuestionNames.OfficeAddinHost, `Invalid host: ${host}`, "office-addin-generator"));
                }
                // from template
                const templateConfig = (0, create_1.getOfficeAddinTemplateConfig)();
                const projectLink = projectType === constants_1.ProjectTypeOptions.officeMetaOS().id
                    ? "https://github.com/OfficeDev/Office-Addin-TaskPane/archive/json-wxpo-preview.zip"
                    : "";
                // Copy project template files from project repository
                if (projectLink) {
                    const fetchRes = await helperMethods_1.HelperMethods.fetchAndUnzip("office-addin-generator", projectLink, addinRoot);
                    if (fetchRes.isErr()) {
                        return (0, teamsfx_api_1.err)(fetchRes.error);
                    }
                    const cmdLine = `npm run convert-to-single-host --if-present -- ${host} json`; // Call 'convert-to-single-host' npm script in generated project, passing in host parameter
                    await OfficeAddinGenerator.childProcessExec(cmdLine);
                    const manifestPath = templateConfig[capability].manifestPath;
                    // modify manifest guid and DisplayName
                    await office_addin_manifest_1.OfficeAddinManifest.modifyManifestFile(`${(0, path_1.join)(addinRoot, manifestPath)}`, "random", `${name}`);
                    await helperMethods_1.HelperMethods.moveManifestLocation(addinRoot, manifestPath);
                }
            }
            else {
                await importProgress.start();
                // from existing project
                await importProgress.next((0, localizeUtils_1.getLocalizedString)("core.generator.officeAddin.importProject.copyFiles"));
                helperMethods_1.HelperMethods.copyAddinFiles(fromFolder, addinRoot);
                const sourceManifestFile = inputs[constants_1.QuestionNames.OfficeAddinManifest];
                let manifestFile = sourceManifestFile.replace(fromFolder, addinRoot);
                await importProgress.next((0, localizeUtils_1.getLocalizedString)("core.generator.officeAddin.importProject.convertProject"));
                if (manifestFile.endsWith(".xml")) {
                    // Need to convert to json project first
                    await (0, office_addin_project_1.convertProject)(manifestFile, "./backup.zip", "", true);
                    manifestFile = manifestFile.replace(/\.xml$/, ".json");
                }
                inputs[constants_1.QuestionNames.OfficeAddinHost] = await getHost(manifestFile);
                await importProgress.next((0, localizeUtils_1.getLocalizedString)("core.generator.officeAddin.importProject.updateManifest"));
                await helperMethods_1.HelperMethods.updateManifest(destinationPath, manifestFile);
            }
            process.chdir(workingDir);
            await importProgress.end(true, true);
            return (0, teamsfx_api_1.ok)(undefined);
        }
        catch (e) {
            process.chdir(workingDir);
            await importProgress.end(false, true);
            return (0, teamsfx_api_1.err)((0, error_1.assembleError)(e));
        }
    }
}
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, actionExecutionMW_1.ActionExecutionMW)({
            enableTelemetry: true,
            telemetryComponentName: componentName,
            telemetryEventName: telemetryEvent,
            errorSource: componentName,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], OfficeAddinGenerator, "generate", null);
exports.OfficeAddinGenerator = OfficeAddinGenerator;
async function getHost(addinManifestPath) {
    var _a, _b, _c;
    // Read add-in manifest file
    const addinManifest = await teamsfx_api_1.ManifestUtil.loadFromPath(addinManifestPath);
    let host = "Outlook";
    switch ((_c = (_b = (_a = addinManifest.extensions) === null || _a === void 0 ? void 0 : _a[0].requirements) === null || _b === void 0 ? void 0 : _b.scopes) === null || _c === void 0 ? void 0 : _c[0]) {
        case "document":
            host = "Word";
            break;
        case "mail":
            host = "Outlook";
            break;
        // case "notebook":
        //   host = "OneNote";
        case "presentation":
            host = "PowerPoint";
            break;
        // case "project":
        //   host = "Project";
        case "workbook":
            host = "Excel";
            break;
    }
    return host;
}
exports.getHost = getHost;
class OfficeAddinGeneratorNew extends templateGenerator_1.DefaultTemplateGenerator {
    constructor() {
        super(...arguments);
        this.componentName = "office-addin-generator";
    }
    // activation condition
    activate(context, inputs) {
        const projectType = inputs[constants_1.QuestionNames.ProjectType];
        return constants_1.ProjectTypeOptions.officeAddinAllIds().includes(projectType);
    }
    async getTemplateInfos(context, inputs, destinationPath, actionContext) {
        const projectType = inputs[constants_1.QuestionNames.ProjectType];
        const tplName = projectType === constants_1.ProjectTypeOptions.officeMetaOS().id ||
            projectType === constants_1.ProjectTypeOptions.officeAddin().id
            ? templateNameForWXPO
            : templateName;
        let lang = (0, lodash_1.toLower)(inputs[constants_1.QuestionNames.ProgrammingLanguage]);
        lang =
            inputs[constants_1.QuestionNames.Capabilities] === constants_1.CapabilityOptions.outlookAddinImport().id ||
                inputs[constants_1.QuestionNames.Capabilities] === constants_1.CapabilityOptions.officeAddinImport().id
                ? constants_1.ProgrammingLanguage.TS
                : lang;
        const res = await OfficeAddinGenerator.doScaffolding(context, inputs, destinationPath);
        if (res.isErr())
            return (0, teamsfx_api_1.err)(res.error);
        return Promise.resolve((0, teamsfx_api_1.ok)([{ templateName: tplName, language: lang, replaceMap: { manifestId: (0, stringUtils_1.getUuid)() } }]));
    }
    async post(context, inputs, destinationPath, actionContext) {
        const fromFolder = inputs[constants_1.QuestionNames.OfficeAddinFolder];
        if (fromFolder) {
            // reset all env files
            const envRes = await envUtil_1.envUtil.listEnv(destinationPath);
            if (envRes.isOk()) {
                const envs = envRes.value;
                for (const env of envs) {
                    await envUtil_1.envUtil.resetEnv(destinationPath, env, ["TEAMSFX_ENV", "APP_NAME_SUFFIX"]);
                }
            }
        }
        return (0, teamsfx_api_1.ok)({});
    }
}
exports.OfficeAddinGeneratorNew = OfficeAddinGeneratorNew;
//# sourceMappingURL=generator.js.map
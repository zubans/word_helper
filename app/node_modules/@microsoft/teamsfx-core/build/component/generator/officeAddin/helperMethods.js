"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.unzipErrorHandler = exports.HelperMethods = void 0;
const tslib_1 = require("tslib");
/**
 * @author darrmill@microsoft.com, yefuwang@microsoft.com
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const common_1 = require("../../../error/common");
const ManifestUtils_1 = require("../../driver/teamsApp/utils/ManifestUtils");
const utils_1 = require("../utils");
class HelperMethods {
    static copyAddinFiles(fromFolder, toFolder) {
        fs_extra_1.default.copySync(fromFolder, toFolder, {
            filter: (path) => !path.includes("node_modules"),
        });
    }
    static async updateManifest(projectRoot, addinManifestPath) {
        // Read add-in manifest file
        const addinManifest = await teamsfx_api_1.ManifestUtil.loadFromPath(addinManifestPath);
        // Open project manifest file
        const manifestTemplatePath = ManifestUtils_1.manifestUtils.getTeamsAppManifestPath(projectRoot);
        if (!(await fs_extra_1.default.pathExists(manifestTemplatePath))) {
            return;
        }
        const manifest = await teamsfx_api_1.ManifestUtil.loadFromPath(manifestTemplatePath);
        // Update project manifest
        manifest.extensions = addinManifest.extensions;
        manifest.authorization = addinManifest.authorization;
        // Save project manifest
        await teamsfx_api_1.ManifestUtil.writeToPath(manifestTemplatePath, manifest);
    }
    // Move the manifest.json and assets to appPackage folder and update related files.
    static async moveManifestLocation(projectRoot, manifestRelativePath) {
        const manifestPath = path.join(projectRoot, manifestRelativePath);
        if (await fs_extra_1.default.pathExists(manifestPath)) {
            if (!(await fs_extra_1.default.pathExists(path.join(projectRoot, "appPackage")))) {
                await fs_extra_1.default.mkdir(path.join(projectRoot, "appPackage"));
            }
            await fs_extra_1.default.rename(manifestPath, path.join(projectRoot, "appPackage", "manifest.json"));
            const packageJsonPath = path.join(projectRoot, "package.json");
            if (await fs_extra_1.default.pathExists(packageJsonPath)) {
                const content = (await fs_extra_1.default.readFile(packageJsonPath)).toString();
                const reg = /\smanifest\.json/g;
                const data = content.replace(reg, ` appPackage/manifest.json`);
                await fs_extra_1.default.writeFile(packageJsonPath, data);
            }
            const assetsPath = path.join(projectRoot, "assets");
            if (await fs_extra_1.default.pathExists(assetsPath)) {
                await fs_extra_1.default.move(assetsPath, path.join(projectRoot, "appPackage", "assets"));
            }
            const webpackConfigPath = path.join(projectRoot, "webpack.config.js");
            if (await fs_extra_1.default.pathExists(webpackConfigPath)) {
                const content = (await fs_extra_1.default.readFile(webpackConfigPath)).toString();
                const manifestReg = /\"manifest\*\.json\"/g;
                const assetsReg = /\"assets\/\*\"/g;
                const data = content
                    .replace(manifestReg, `"appPackage/manifest*.json"`)
                    .replace(assetsReg, `"appPackage/assets/*"`);
                await fs_extra_1.default.writeFile(webpackConfigPath, data);
            }
            const htmlPath = path.join(projectRoot, "src", "taskpane", "taskpane.html");
            if (await fs_extra_1.default.pathExists(htmlPath)) {
                const content = (await fs_extra_1.default.readFile(htmlPath)).toString();
                const assetsReg = /\/assets\//g;
                const data = content.replace(assetsReg, `/appPackage/assets/`);
                await fs_extra_1.default.writeFile(htmlPath, data);
            }
        }
    }
    static async fetchAndUnzip(component, zipUrl, targetDir, skipRootFolder = true) {
        let zip;
        try {
            zip = await (0, utils_1.fetchZipFromUrl)(zipUrl);
        }
        catch (e) {
            return (0, teamsfx_api_1.err)(new common_1.AccessGithubError(zipUrl, component, e));
        }
        if (!zip) {
            return (0, teamsfx_api_1.err)(new common_1.AccessGithubError(zipUrl, component, new Error(`Failed to fetch zip from url: ${zipUrl}, result is undefined.`)));
        }
        const entries = zip.getEntries();
        let rootFolderName = "";
        for (const entry of entries) {
            const entryName = entry.entryName;
            if (skipRootFolder && !rootFolderName) {
                rootFolderName = entryName;
                continue;
            }
            const rawEntryData = entry.getData();
            const entryData = rawEntryData;
            const targetPath = path.join(targetDir, entryName.replace(rootFolderName, ""));
            try {
                if (entry.isDirectory) {
                    await fs_extra_1.default.ensureDir(targetPath);
                }
                else {
                    await fs_extra_1.default.writeFile(targetPath, entryData);
                }
            }
            catch (error) {
                return (0, teamsfx_api_1.err)(new common_1.WriteFileError(error, component));
            }
        }
        return (0, teamsfx_api_1.ok)(undefined);
    }
}
exports.HelperMethods = HelperMethods;
function unzipErrorHandler(projectFolder, reject, error) {
    if (error.message) {
        error.message = `Unable to unzip project zip file for "${projectFolder}", reason: ${error.message}`;
    }
    reject(new common_1.ReadFileError(error, "OfficeAddinGenerator"));
}
exports.unzipErrorHandler = unzipErrorHandler;
//# sourceMappingURL=helperMethods.js.map
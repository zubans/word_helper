"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultTemplateGenerator = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const telemetry_1 = require("../../../common/telemetry");
const messages_1 = require("../../messages");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const constant_1 = require("../constant");
const constants_1 = require("../../../question/constants");
const generator_1 = require("../generator");
const utils_1 = require("../utils");
const lodash_1 = require("lodash");
const generatorAction_1 = require("../generatorAction");
const templateNames_1 = require("./templateNames");
const templateReplaceMap_1 = require("./templateReplaceMap");
class DefaultTemplateGenerator {
    constructor() {
        // override this property to send telemetry event with different component name
        this.componentName = constant_1.componentName;
    }
    // override this method to determine whether to run this generator
    activate(context, inputs) {
        return (0, templateNames_1.tryGetTemplateName)(inputs) !== undefined;
    }
    // The main entry of the generator. Do not override this method.
    async run(context, inputs, destinationPath, actionContext) {
        const preResult = await this.getTemplateInfos(context, inputs, destinationPath, actionContext);
        if (preResult.isErr())
            return (0, teamsfx_api_1.err)(preResult.error);
        const templateInfos = preResult.value;
        for (const templateInfo of templateInfos) {
            templateInfo.replaceMap = Object.assign(Object.assign({}, (0, templateReplaceMap_1.getTemplateReplaceMap)(inputs)), templateInfo.replaceMap);
            await this.scaffolding(context, templateInfo, destinationPath, actionContext);
        }
        const postRes = await this.post(context, inputs, destinationPath, actionContext);
        return postRes;
    }
    // override this method to 1) do pre-step before template download and 2) provide information of templates to be downloaded
    getTemplateInfos(context, inputs, destinationPath, actionContext) {
        const templateName = (0, templateNames_1.getTemplateName)(inputs);
        const language = inputs[constants_1.QuestionNames.ProgrammingLanguage];
        return Promise.resolve((0, teamsfx_api_1.ok)([{ templateName, language }]));
    }
    // override this method to do post-step after template download
    post(context, inputs, destinationPath, actionContext) {
        return Promise.resolve((0, teamsfx_api_1.ok)({}));
    }
    async scaffolding(context, templateInfo, destinationPath, actionContext) {
        var _a, _b, _c;
        const name = templateInfo.templateName;
        const language = (_a = (0, utils_1.convertToLangKey)(templateInfo.language)) !== null && _a !== void 0 ? _a : constant_1.commonTemplateName;
        const replaceMap = templateInfo.replaceMap;
        const filterFn = (_b = templateInfo.filterFn) !== null && _b !== void 0 ? _b : (() => true);
        const templateName = `${name}-${language}`;
        (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.TemplateName]: templateName,
        });
        const generatorContext = {
            name: name,
            language: language,
            destination: destinationPath,
            logProvider: context.logProvider,
            fileNameReplaceFn: (fileName, fileData) => (0, utils_1.renderTemplateFileName)(fileName, fileData, replaceMap)
                .replace(/\\/g, "/")
                .replace(`${name}/`, ""),
            fileDataReplaceFn: (fileName, fileData) => (0, utils_1.renderTemplateFileData)(fileName, fileData, replaceMap),
            filterFn: (fileName) => fileName.replace(/\\/g, "/").startsWith(`${name}/`) && filterFn(fileName),
            onActionError: generator_1.templateDefaultOnActionError,
        };
        await ((_c = actionContext === null || actionContext === void 0 ? void 0 : actionContext.progressBar) === null || _c === void 0 ? void 0 : _c.next(messages_1.ProgressMessages.generateTemplate));
        context.logProvider.debug(`Downloading app template "${templateName}" to ${destinationPath}`);
        await generator_1.Generator.generate(generatorContext, generatorAction_1.TemplateActionSeq);
        (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetry_1.TelemetryProperty.Fallback]: generatorContext.fallback ? "true" : "false", // Track fallback cases.
        });
    }
}
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, actionExecutionMW_1.ActionExecutionMW)({
            enableProgressBar: true,
            progressTitle: messages_1.ProgressTitles.create,
            progressSteps: 1,
            enableTelemetry: true,
            telemetryEventName: telemetry_1.TelemetryEvent.GenerateTemplate,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], DefaultTemplateGenerator.prototype, "run", null);
exports.DefaultTemplateGenerator = DefaultTemplateGenerator;
//# sourceMappingURL=templateGenerator.js.map
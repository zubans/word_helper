"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.CopilotExtensionGenerator = void 0;
const tslib_1 = require("tslib");
/**
 * @author yuqzho@microsoft.com
 */
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const templateGenerator_1 = require("../templates/templateGenerator");
const question_1 = require("../../../question");
const generator_1 = require("../generator");
const lodash_1 = require("lodash");
const templateNames_1 = require("../templates/templateNames");
const featureFlags_1 = require("../../../common/featureFlags");
const constant_1 = require("../constant");
const helper_1 = require("./helper");
const path_1 = tslib_1.__importDefault(require("path"));
const CopilotGptManifestUtils_1 = require("../../driver/teamsApp/utils/CopilotGptManifestUtils");
const common_1 = require("../../utils/common");
/**
 * Generator for copilot extensions including declarative copilot with no plugin,
 * declarative copilot with API plugin from scratch, declarative copilot with existing plugin (to be add later),
 * and API plugin from scratch.
 */
class CopilotExtensionGenerator extends templateGenerator_1.DefaultTemplateGenerator {
    constructor() {
        super(...arguments);
        this.componentName = "copilot-extension-from-scratch-generator";
    }
    activate(context, inputs) {
        return ((inputs[question_1.QuestionNames.Capabilities] === question_1.CapabilityOptions.declarativeCopilot().id &&
            inputs[question_1.QuestionNames.ApiPluginType] !== question_1.ApiPluginStartOptions.apiSpec().id) ||
            (inputs[question_1.QuestionNames.Capabilities] === question_1.CapabilityOptions.apiPlugin().id &&
                inputs[question_1.QuestionNames.ApiPluginType] === question_1.ApiPluginStartOptions.newApi().id));
    }
    getTemplateInfos(context, inputs, destinationPath, actionContext) {
        const auth = inputs[question_1.QuestionNames.ApiAuth];
        const appName = inputs[question_1.QuestionNames.AppName];
        const language = inputs[question_1.QuestionNames.ProgrammingLanguage];
        const safeProjectNameFromVS = language === "csharp" ? inputs[question_1.QuestionNames.SafeProjectName] : undefined;
        const isDeclarativeCopilot = checkDeclarativeCopilot(inputs);
        const replaceMap = Object.assign(Object.assign({}, generator_1.Generator.getDefaultVariables(appName, safeProjectNameFromVS, inputs.targetFramework, inputs.placeProjectFileInSolutionDir === "true")), { DeclarativeCopilot: isDeclarativeCopilot ? "true" : "", FileFunction: featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.EnvFileFunc) ? "true" : "", MicrosoftEntra: auth === question_1.ApiAuthOptions.microsoftEntra().id ? "true" : "" });
        const filterFn = (fileName) => {
            if (fileName.toLowerCase().includes("declarativeagent.json")) {
                return isDeclarativeCopilot;
            }
            else if (fileName.includes(constant_1.declarativeCopilotInstructionFileName)) {
                return isDeclarativeCopilot && featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.EnvFileFunc);
            }
            else {
                return true;
            }
        };
        let templateName;
        const apiPluginFromScratch = inputs[question_1.QuestionNames.ApiPluginType] === question_1.ApiPluginStartOptions.newApi().id;
        if (apiPluginFromScratch) {
            const authTemplateMap = {
                [question_1.ApiAuthOptions.apiKey().id]: templateNames_1.TemplateNames.ApiPluginFromScratchBearer,
                [question_1.ApiAuthOptions.microsoftEntra().id]: templateNames_1.TemplateNames.ApiPluginFromScratchOAuth,
                [question_1.ApiAuthOptions.oauth().id]: templateNames_1.TemplateNames.ApiPluginFromScratchOAuth,
            };
            templateName = authTemplateMap[auth] || templateNames_1.TemplateNames.ApiPluginFromScratch;
        }
        else {
            templateName = templateNames_1.TemplateNames.BasicGpt;
        }
        (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            ["template-name" /* telemetryProperties.templateName */]: templateName,
            ["is-declarative-copilot" /* telemetryProperties.isDeclarativeCopilot */]: isDeclarativeCopilot.toString(),
            ["is-microsoft-entra" /* telemetryProperties.isMicrosoftEntra */]: auth === question_1.ApiAuthOptions.microsoftEntra().id ? "true" : "",
            ["need-add-plugin-from-existing" /* telemetryProperties.needAddPluginFromExisting */]: inputs[question_1.QuestionNames.ApiPluginType] ===
                question_1.ApiPluginStartOptions.existingPlugin().id.toString(),
        });
        return Promise.resolve((0, teamsfx_api_1.ok)([
            {
                templateName,
                language: language,
                replaceMap,
                filterFn,
            },
        ]));
    }
    async post(context, inputs, destinationPath, actionContext) {
        const isAddingFromExistingPlugin = inputs[question_1.QuestionNames.ApiPluginType] === question_1.ApiPluginStartOptions.existingPlugin().id;
        if (isAddingFromExistingPlugin) {
            const teamsManifestPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName);
            const declarativeCopilotManifestPathRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.getManifestPath(teamsManifestPath);
            if (declarativeCopilotManifestPathRes.isErr()) {
                return (0, teamsfx_api_1.err)(declarativeCopilotManifestPathRes.error);
            }
            const addPluginRes = await (0, helper_1.addExistingPlugin)(declarativeCopilotManifestPathRes.value, inputs[question_1.QuestionNames.PluginManifestFilePath], inputs[question_1.QuestionNames.PluginOpenApiSpecFilePath], "action_1", context, this.componentName);
            if (addPluginRes.isErr()) {
                return (0, teamsfx_api_1.err)(addPluginRes.error);
            }
            else {
                if (inputs.platform === teamsfx_api_1.Platform.CLI || inputs.platform === teamsfx_api_1.Platform.VS) {
                    const warningMessage = (0, common_1.outputScaffoldingWarningMessage)(addPluginRes.value.warnings);
                    if (warningMessage) {
                        context.logProvider.info(warningMessage);
                    }
                }
                return (0, teamsfx_api_1.ok)({ warnings: addPluginRes.value.warnings });
            }
        }
        else {
            return (0, teamsfx_api_1.ok)({});
        }
    }
}
exports.CopilotExtensionGenerator = CopilotExtensionGenerator;
function checkDeclarativeCopilot(inputs) {
    return inputs[question_1.QuestionNames.Capabilities] === question_1.CapabilityOptions.declarativeCopilot().id;
}
//# sourceMappingURL=generator.js.map
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateSourcePluginManifest = exports.addExistingPlugin = void 0;
const tslib_1 = require("tslib");
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const CopilotGptManifestUtils_1 = require("../../driver/teamsApp/utils/CopilotGptManifestUtils");
const PluginManifestUtils_1 = require("../../driver/teamsApp/utils/PluginManifestUtils");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const utils_1 = require("../../driver/teamsApp/utils/utils");
const localizeUtils_1 = require("../../../common/localizeUtils");
const common_1 = require("../../utils/common");
const telemetry_1 = require("../../../common/telemetry");
const error_1 = require("../../../error");
const pluginManifestPlaceholderWarning = "add-exsiting-plugin-manifest-placehoder";
const apiSpecPlaceholderWarning = "add-exsiting-plugin-api-spec-placehoder";
const readApiSpecErrorTelemetry = "read-api-spec-error";
async function addExistingPlugin(declarativeCopilotManifestPath, fromPluginManifestPath, fromApiSpecPath, actionId, context, source) {
    var _a;
    const pluginManifestRes = await PluginManifestUtils_1.pluginManifestUtils.readPluginManifestFile(fromPluginManifestPath);
    if (pluginManifestRes.isErr()) {
        return (0, teamsfx_api_1.err)(pluginManifestRes.error);
    }
    const pluginManifest = pluginManifestRes.value;
    // prerequiste check
    const checkRes = validateSourcePluginManifest(pluginManifest, source);
    if (checkRes.isErr()) {
        return (0, teamsfx_api_1.err)(checkRes.error);
    }
    const runtimes = pluginManifest.runtimes; // have validated that the value exists.
    const destinationApiSpecRelativePath = runtimes.find((runtime) => runtime.type === "OpenApi")
        .spec.url; // have validated that the value exists.
    const outputFolder = path_1.default.dirname(declarativeCopilotManifestPath);
    // Copy OpenAPI spec
    const originalDestApiSPecRelativePath = path_1.default.resolve(outputFolder, destinationApiSpecRelativePath);
    let destinationApiSpecPath = originalDestApiSPecRelativePath;
    const needUpdatePluginManifest = (await fs_extra_1.default.pathExists(originalDestApiSPecRelativePath)) ||
        path_1.default.relative(outputFolder, originalDestApiSPecRelativePath).startsWith("..");
    if (needUpdatePluginManifest) {
        destinationApiSpecPath = await PluginManifestUtils_1.pluginManifestUtils.getDefaultNextAvailableApiSpecPath(fromApiSpecPath, path_1.default.join(outputFolder, teamsfx_api_1.DefaultApiSpecFolderName));
    }
    await fs_extra_1.default.ensureFile(destinationApiSpecPath);
    await fs_extra_1.default.copyFile(fromApiSpecPath, destinationApiSpecPath);
    // Save plugin manifest
    if (needUpdatePluginManifest) {
        const runtimeSpecUrl = (0, utils_1.normalizePath)(path_1.default.relative(outputFolder, destinationApiSpecPath), true);
        for (const runtime of runtimes) {
            if (runtime.type === "OpenApi" && ((_a = runtime.spec) === null || _a === void 0 ? void 0 : _a.url)) {
                runtime.spec.url = runtimeSpecUrl;
            }
        }
    }
    const destinationPluginManifestPath = await CopilotGptManifestUtils_1.copilotGptManifestUtils.getDefaultNextAvailablePluginManifestPath(outputFolder);
    await fs_extra_1.default.ensureFile(destinationPluginManifestPath);
    const pluginManifestContent = JSON.stringify(pluginManifest, undefined, 4);
    await fs_extra_1.default.writeFile(destinationPluginManifestPath, pluginManifestContent);
    // Update declarative copilot plugin manifest
    const addActionRes = await CopilotGptManifestUtils_1.copilotGptManifestUtils.addAction(declarativeCopilotManifestPath, actionId, (0, utils_1.normalizePath)(path_1.default.relative(outputFolder, destinationPluginManifestPath), true));
    if (addActionRes.isErr()) {
        return (0, teamsfx_api_1.err)(addActionRes.error);
    }
    const warnings = [];
    const pluginManifestVariables = (0, common_1.getEnvironmentVariables)(JSON.stringify(pluginManifest));
    if (pluginManifestVariables.length > 0) {
        warnings.push({
            type: pluginManifestPlaceholderWarning,
            content: (0, localizeUtils_1.getLocalizedString)("core.addPlugin.warning.manifestVariables", pluginManifestVariables.join(", ")),
        });
    }
    try {
        const apiSpecContent = await fs_extra_1.default.readFile(destinationApiSpecPath, "utf8");
        const apiSpecVariables = (0, common_1.getEnvironmentVariables)(apiSpecContent);
        if (apiSpecVariables.length > 0) {
            warnings.push({
                type: apiSpecPlaceholderWarning,
                content: (0, localizeUtils_1.getLocalizedString)("core.addPlugin.warning.apiSpecVariables", apiSpecVariables.join(", ")),
            });
        }
    }
    catch (e) {
        (0, telemetry_1.sendTelemetryErrorEvent)(source, readApiSpecErrorTelemetry, (0, error_1.assembleError)(e));
    }
    return (0, teamsfx_api_1.ok)({
        destinationPluginManifestPath,
        warnings,
    });
}
exports.addExistingPlugin = addExistingPlugin;
function validateSourcePluginManifest(manifest, source) {
    var _a;
    if (!manifest.schema_version) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MissingSchemaVersion", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "schema_version"), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "schema_version")));
    }
    if (!manifest.runtimes) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MissingRuntimes", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "runtimes"), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.MissingRequiredProperty", "runtimes")));
    }
    const apiSpecPaths = new Set();
    for (const runtime of manifest.runtimes) {
        if (runtime.type === "OpenApi" && ((_a = runtime.spec) === null || _a === void 0 ? void 0 : _a.url)) {
            apiSpecPaths.add(runtime.spec.url);
        }
    }
    if (apiSpecPaths.size === 0) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MissingApiSpec", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.pluginManifestMissingApiSpec", "OpenApi"), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.pluginManifestMissingApiSpec", "OpenApi")));
    }
    if (apiSpecPaths.size > 1) {
        return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError(source, "MultipleApiSpecInPluginManifest", (0, localizeUtils_1.getDefaultString)("core.createProjectQuestion.addPlugin.pluginManifestMultipleApiSpec", Array.from(apiSpecPaths).join(", ")), (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addPlugin.pluginManifestMultipleApiSpec", Array.from(apiSpecPaths).join(", "))));
    }
    return (0, teamsfx_api_1.ok)(undefined);
}
exports.validateSourcePluginManifest = validateSourcePluginManifest;
//# sourceMappingURL=helper.js.map
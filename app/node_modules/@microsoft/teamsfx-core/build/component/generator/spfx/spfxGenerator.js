"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
/* eslint-disable @typescript-eslint/no-unnecessary-type-assertion */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SPFxGeneratorImport = exports.SPFxGeneratorNew = exports.SPFxGenerator = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const lodash_1 = require("lodash");
const os_1 = require("os");
const path = tslib_1.__importStar(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const util = tslib_1.__importStar(require("util"));
const deps_checker_1 = require("../../deps-checker");
const jsonUtils_1 = require("../../../common/jsonUtils");
const localizeUtils_1 = require("../../../common/localizeUtils");
const error_1 = require("../../../error");
const constants_1 = require("../../../question/constants");
const ManifestUtils_1 = require("../../driver/teamsApp/utils/ManifestUtils");
const actionExecutionMW_1 = require("../../middleware/actionExecutionMW");
const envUtil_1 = require("../../utils/envUtil");
const generator_1 = require("../generator");
const templateGenerator_1 = require("../templates/templateGenerator");
const generatorChecker_1 = require("./depsChecker/generatorChecker");
const yoChecker_1 = require("./depsChecker/yoChecker");
const error_2 = require("./error");
const constants_2 = require("./utils/constants");
const progress_helper_1 = require("./utils/progress-helper");
const telemetry_helper_1 = require("./utils/telemetry-helper");
const telemetryEvents_1 = require("./utils/telemetryEvents");
const utils_1 = require("./utils/utils");
class SPFxGenerator {
    static async generate(context, inputs, destinationPath, actionContext) {
        const spfxSolution = inputs[constants_1.QuestionNames.SPFxSolution];
        (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetryEvents_1.TelemetryProperty.SPFxSolution]: spfxSolution,
        });
        if (spfxSolution === "new") {
            return await this.newSPFxProject(context, inputs, destinationPath);
        }
        else {
            return await this.importSPFxProject(context, inputs, destinationPath, actionContext);
        }
    }
    static async newSPFxProject(context, inputs, destinationPath) {
        const yeomanRes = await this.doYeomanScaffold(context, inputs, destinationPath);
        if (yeomanRes.isErr())
            return (0, teamsfx_api_1.err)(yeomanRes.error);
        const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, constants_2.Constants.TEMPLATE_NAME, "ts");
        if (templateRes.isErr())
            return (0, teamsfx_api_1.err)(templateRes.error);
        return (0, teamsfx_api_1.ok)(undefined);
    }
    static async importSPFxProject(context, inputs, destinationPath, actionContext) {
        var _a, _b, _c, _d;
        const importProgress = context.userInteraction.createProgressBar((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.title"), 3);
        await importProgress.start();
        const importDetails = [];
        try {
            // Copy & paste existing SPFx solution
            await importProgress.next((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.copyExistingSPFxSolution"));
            const spfxFolder = inputs[constants_1.QuestionNames.SPFxFolder];
            const destSpfxFolder = path.join(destinationPath, "src");
            importDetails.push(os_1.EOL +
                `(.) Processing: Copying existing SPFx solution from ${spfxFolder} to ${destSpfxFolder}...`);
            await this.copySPFxSolution(spfxFolder, destSpfxFolder);
            importDetails.push(`(√) Done: Succeeded to copy existing SPFx solution.`);
            // Retrieve solution info to generate template
            await importProgress.next((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.generateSPFxTemplates"));
            importDetails.push(`(.) Processing: Reading web part manifest in SPFx solution...`);
            const webpartManifest = await this.getWebpartManifest(spfxFolder);
            if (!webpartManifest ||
                !webpartManifest["id"] ||
                !webpartManifest["preconfiguredEntries"][0].title.default) {
                importDetails.push(`(×) Error: Failed to Read web part manifest due to invalid ${!webpartManifest
                    ? "web part manifest"
                    : !webpartManifest["id"]
                        ? "web part manifest id"
                        : "preconfiguredEntries title in web part manifest file"}!`);
                throw (0, error_2.RetrieveSPFxInfoError)();
            }
            importDetails.push(`(√) Done: Succeeded to retrieve web part manifest in SPFx solution.`);
            if (!context.templateVariables) {
                context.templateVariables = generator_1.Generator.getDefaultVariables(inputs[constants_1.QuestionNames.AppName]);
            }
            const nodeVersion = await this.getNodeVersion(destSpfxFolder, context);
            context.templateVariables["SpfxNodeVersion"] = nodeVersion;
            context.templateVariables["componentId"] = webpartManifest["id"];
            context.templateVariables["webpartName"] =
                webpartManifest["preconfiguredEntries"][0].title.default;
            importDetails.push(`(.) Processing: Generating SPFx project templates with app name: ${inputs[constants_1.QuestionNames.AppName]}, component id: ${webpartManifest["id"]}, web part name: ${webpartManifest["preconfiguredEntries"][0].title.default}`);
            const templateRes = await generator_1.Generator.generateTemplate(context, destinationPath, constants_2.Constants.TEMPLATE_NAME, "ts");
            if (templateRes.isErr()) {
                importDetails.push(`(×) Error: Failed to generate SPFx project templates!`);
                throw templateRes.error;
            }
            importDetails.push(`(√) Done: Succeeded to generate SPFx project templates.`);
            // Update manifest and related files
            await importProgress.next((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.updateTemplates"));
            await this.updateSPFxTemplate(spfxFolder, destinationPath, importDetails);
        }
        catch (error) {
            await importProgress.end(false);
            importDetails.push((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.log.fail", (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.getLogFilePath()));
            await context.logProvider.logInFile(teamsfx_api_1.LogLevel.Info, importDetails.join(os_1.EOL));
            void context.logProvider.error((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.log.fail", (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.getLogFilePath()));
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
                return (0, teamsfx_api_1.err)(error);
            }
            return (0, teamsfx_api_1.err)((0, error_2.ImportSPFxSolutionError)(error));
        }
        await importProgress.end(true);
        importDetails.push((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.log.success", (_c = context.logProvider) === null || _c === void 0 ? void 0 : _c.getLogFilePath()));
        await context.logProvider.logInFile(teamsfx_api_1.LogLevel.Info, importDetails.join(os_1.EOL));
        void context.logProvider.info((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.log.success", (_d = context.logProvider) === null || _d === void 0 ? void 0 : _d.getLogFilePath()));
        void context.userInteraction.showMessage("info", (0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.success", destinationPath), false);
        return (0, teamsfx_api_1.ok)(undefined);
    }
    static async doYeomanScaffold(context, inputs, destinationPath) {
        var _a, _b;
        const ui = context.userInteraction;
        const progressHandler = await progress_helper_1.ProgressHelper.startScaffoldProgressHandler(ui, inputs.stage == teamsfx_api_1.Stage.addWebpart);
        let shouldInstallLocally = inputs[constants_1.QuestionNames.SPFxInstallPackage] === constants_1.SPFxVersionOptionIds.installLocally;
        try {
            const webpartName = inputs[constants_1.QuestionNames.SPFxWebpartName];
            const framework = inputs[constants_1.QuestionNames.SPFxFramework];
            const solutionName = inputs[constants_1.QuestionNames.AppName];
            const isAddSPFx = inputs.stage == teamsfx_api_1.Stage.addWebpart;
            const componentName = utils_1.Utils.normalizeComponentName(webpartName);
            const componentNameCamelCase = (0, lodash_1.camelCase)(componentName);
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next((0, localizeUtils_1.getLocalizedString)("plugins.spfx.scaffold.dependencyCheck")));
            const yoChecker = new yoChecker_1.YoChecker(context.logProvider);
            const spGeneratorChecker = new generatorChecker_1.GeneratorChecker(context.logProvider);
            let targetVersion = constants_2.Constants.LatestVersion;
            let localVersion = undefined;
            if (isAddSPFx) {
                const yoInfoPath = path.join(inputs[constants_1.QuestionNames.SPFxFolder], constants_2.Constants.YO_RC_FILE);
                targetVersion = await this.getSolutionVersion(yoInfoPath);
                if (!targetVersion) {
                    context.logProvider.error((0, localizeUtils_1.getLocalizedString)("plugins.spfx.addWebPart.cannotFindSolutionVersion", yoInfoPath));
                    throw (0, error_2.SolutionVersionMissingError)(yoInfoPath);
                }
                const versions = await Promise.all([
                    spGeneratorChecker.findLocalInstalledVersion(),
                    spGeneratorChecker.findGloballyInstalledVersion(undefined, false),
                ]);
                localVersion = versions[0];
                shouldInstallLocally = await this.shouldAddWebPartWithLocalDependencies(targetVersion, versions[1], localVersion, context);
            }
            if (shouldInstallLocally) {
                await this.ensureLocalDependencies(targetVersion, localVersion, inputs, context, yoChecker, spGeneratorChecker, progressHandler);
            }
            else {
                const isLowerVersion = !!inputs.globalSpfxPackageVersion &&
                    semver_1.default.lt(inputs.globalSpfxPackageVersion, constants_2.Constants.RecommendedLowestSpfxVersion.substring(1));
                if (isLowerVersion) {
                    context.telemetryReporter.sendTelemetryEvent(telemetryEvents_1.TelemetryEvents.UseNotRecommendedVersion);
                }
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next((0, localizeUtils_1.getLocalizedString)(isAddSPFx
                ? "driver.spfx.add.progress.scaffoldWebpart"
                : "plugins.spfx.scaffold.scaffoldProject")));
            if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
                context.logProvider.outputChannel.show();
            }
            const yoEnv = process.env;
            if (yoEnv.PATH) {
                yoEnv.PATH = shouldInstallLocally
                    ? `${yoChecker.getBinFolders().join(path.delimiter)}${path.delimiter}${(_a = process.env.PATH) !== null && _a !== void 0 ? _a : ""}`
                    : process.env.PATH;
            }
            else {
                yoEnv.Path = shouldInstallLocally
                    ? `${yoChecker.getBinFolders().join(path.delimiter)}${path.delimiter}${(_b = process.env.Path) !== null && _b !== void 0 ? _b : ""}`
                    : process.env.Path;
            }
            const args = [
                shouldInstallLocally ? spGeneratorChecker.getSpGeneratorPath() : "@microsoft/sharepoint",
                "--skip-install",
                "true",
                "--component-type",
                "webpart",
                "--component-name",
                webpartName,
                "--environment",
                "spo",
                "--skip-feature-deployment",
                "true",
                "--is-domain-isolated",
                "false",
            ];
            if (framework) {
                args.push("--framework", framework);
            }
            if (solutionName) {
                args.push("--solution-name", `"${solutionName}"`);
            }
            try {
                await deps_checker_1.cpUtils.executeCommand(isAddSPFx ? inputs[constants_1.QuestionNames.SPFxFolder] : destinationPath, context.logProvider, {
                    timeout: 2 * 60 * 1000,
                    env: yoEnv,
                    shell: (0, utils_1.getShellOptionValue)(),
                }, "yo", ...args);
            }
            catch (yoError) {
                if (yoError.message) {
                    void context.logProvider.error(yoError.message);
                }
                throw (0, error_2.YoGeneratorScaffoldError)();
            }
            const newPath = path.join(destinationPath, "src");
            if (!isAddSPFx) {
                const currentPath = path.join(destinationPath, solutionName);
                await fs_extra_1.default.rename(currentPath, newPath);
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next((0, localizeUtils_1.getLocalizedString)("plugins.spfx.scaffold.updateManifest")));
            const manifestPath = `${newPath}/src/webparts/${componentNameCamelCase}/${componentName}WebPart.manifest.json`;
            const manifest = await fs_extra_1.default.readFile(manifestPath, "utf8");
            let manifestString = manifest.toString();
            manifestString = manifestString.replace(`"supportedHosts": ["SharePointWebPart"]`, `"supportedHosts": ["SharePointWebPart", "TeamsPersonalApp", "TeamsTab"]`);
            await fs_extra_1.default.writeFile(manifestPath, manifestString);
            const matchHashComment = new RegExp(/(\/\/ .*)/, "gi");
            const manifestJson = JSON.parse(manifestString.replace(matchHashComment, "").trim());
            const componentId = manifestJson.id;
            if (!isAddSPFx) {
                if (!context.templateVariables) {
                    context.templateVariables = generator_1.Generator.getDefaultVariables(solutionName);
                }
                context.templateVariables["componentId"] = componentId;
                context.templateVariables["webpartName"] = webpartName;
                const nodeVersion = await this.getNodeVersion(newPath, context);
                context.templateVariables["SpfxNodeVersion"] = nodeVersion;
            }
            // remove dataVersion() function, related issue: https://github.com/SharePoint/sp-dev-docs/issues/6469
            const webpartFile = `${newPath}/src/webparts/${componentNameCamelCase}/${componentName}WebPart.ts`;
            const codeFile = await fs_extra_1.default.readFile(webpartFile, "utf8");
            let codeString = codeFile.toString();
            codeString = codeString.replace(`  protected get dataVersion(): Version {\r\n    return Version.parse('1.0');\r\n  }\r\n\r\n`, ``);
            codeString = codeString.replace(`import { Version } from '@microsoft/sp-core-library';\r\n`, ``);
            await fs_extra_1.default.writeFile(webpartFile, codeString);
            // remove .vscode
            const debugPath = `${newPath}/.vscode`;
            if (await fs_extra_1.default.pathExists(debugPath)) {
                await fs_extra_1.default.remove(debugPath);
            }
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(true));
            return (0, teamsfx_api_1.ok)(componentId);
        }
        catch (error) {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.end(false));
            return (0, teamsfx_api_1.err)((0, error_2.ScaffoldError)(error));
        }
    }
    static async getSolutionVersion(yoInfoPath) {
        if (await fs_extra_1.default.pathExists(yoInfoPath)) {
            const yoInfo = await fs_extra_1.default.readJson(yoInfoPath);
            if (yoInfo["@microsoft/generator-sharepoint"]) {
                return yoInfo["@microsoft/generator-sharepoint"][constants_2.Constants.YO_RC_VERSION];
            }
        }
        else {
            throw new error_1.FileNotFoundError(constants_2.Constants.PLUGIN_NAME, yoInfoPath);
        }
        return "";
    }
    static async ensureLocalDependencies(targetSPFxVersion, localSPFxVersion, inputs, context, yoChecker, spGeneratorChecker, progressHandler) {
        let needInstallYo = false;
        let needInstallGenerator = false;
        const isAddWebPart = targetSPFxVersion !== constants_2.Constants.LatestVersion;
        // yo
        if (!isAddWebPart) {
            const latestYoInstalled = await yoChecker.isLatestInstalled();
            needInstallYo = !latestYoInstalled;
        }
        else {
            const localYoVersion = await yoChecker.findLocalInstalledVersion();
            needInstallYo = !localYoVersion;
        }
        // spfx generator
        if (!isAddWebPart) {
            const latestGeneratorInstalled = await spGeneratorChecker.isLatestInstalled(inputs.latestSpfxPackageVersion);
            needInstallGenerator = !latestGeneratorInstalled;
        }
        else {
            // we have check and confirmed with user before install/upgrade dependencies for user
            needInstallGenerator = !localSPFxVersion || semver_1.default.lt(localSPFxVersion, targetSPFxVersion);
        }
        if (needInstallYo || needInstallGenerator) {
            await (progressHandler === null || progressHandler === void 0 ? void 0 : progressHandler.next((0, localizeUtils_1.getLocalizedString)("plugins.spfx.scaffold.dependencyInstall")));
            if (needInstallYo) {
                const yoRes = await yoChecker.ensureDependency(context, constants_2.Constants.LatestVersion);
                if (yoRes.isErr()) {
                    if (isAddWebPart) {
                        throw (0, error_2.PackageTargetVersionInstallError)(constants_2.Constants.YeomanPackageName, constants_2.Constants.LatestVersion);
                    }
                    else {
                        throw (0, error_2.LatestPackageInstallError)();
                    }
                }
            }
            if (needInstallGenerator) {
                const spGeneratorRes = await spGeneratorChecker.ensureDependency(context, targetSPFxVersion);
                if (spGeneratorRes.isErr()) {
                    if (isAddWebPart) {
                        throw (0, error_2.PackageTargetVersionInstallError)(constants_2.Constants.GeneratorPackageName, targetSPFxVersion);
                    }
                    else {
                        throw (0, error_2.LatestPackageInstallError)();
                    }
                }
            }
        }
    }
    // return shouldUseLocal
    static async shouldAddWebPartWithLocalDependencies(solutionVersion, globalVersion, localVersion, context) {
        if (globalVersion === solutionVersion) {
            // use globally installed pacakge to add web part
            context.telemetryReporter.sendTelemetryEvent(telemetryEvents_1.TelemetryEvents.CheckAddWebPartPackage, {
                [telemetryEvents_1.TelemetryProperty.PackageSource]: "global",
            });
            return false;
        }
        if (localVersion === solutionVersion) {
            // use locally installed package to add web part
            context.telemetryReporter.sendTelemetryEvent(telemetryEvents_1.TelemetryEvents.CheckAddWebPartPackage, {
                [telemetryEvents_1.TelemetryProperty.PackageSource]: "local",
                [telemetryEvents_1.TelemetryProperty.UserAction]: "none",
            });
            return true;
        }
        const displayedSolutionVersion = `v${solutionVersion}`;
        const displayedLocalVersion = localVersion ? `v${localVersion}` : undefined;
        const displayedGlobalVersion = globalVersion ? `v${globalVersion}` : undefined;
        let userAnswer;
        let continueText;
        let defaultContinueText;
        if (!localVersion) {
            // ask user to confirm to install locally
            continueText = (0, localizeUtils_1.getLocalizedString)("plugins.spfx.addWebPart.install");
            defaultContinueText = (0, localizeUtils_1.getDefaultString)("plugins.spfx.addWebPart.install");
            const res = await context.userInteraction.showMessage("info", (0, localizeUtils_1.getLocalizedString)("plugins.spfx.addWebPart.confirmInstall", displayedSolutionVersion, displayedSolutionVersion), true, continueText);
            userAnswer = res.isOk() ? res.value : undefined;
        }
        else if (semver_1.default.lt(localVersion, solutionVersion)) {
            // ask user to confirm to upgrade local SPFx
            continueText = (0, localizeUtils_1.getLocalizedString)("plugins.spfx.addWebPart.upgrade");
            defaultContinueText = (0, localizeUtils_1.getDefaultString)("plugins.spfx.addWebPart.upgrade");
            const res = await context.userInteraction.showMessage("info", (0, localizeUtils_1.getLocalizedString)("plugins.spfx.addWebPart.confirmUpgrade", displayedLocalVersion, displayedSolutionVersion, displayedSolutionVersion), true, continueText);
            userAnswer = res.isOk() ? res.value : undefined;
        }
        else {
            // localVersion > solutionVersion
            // ask user to confirm to continue, learn more or cancel
            continueText = (0, localizeUtils_1.getLocalizedString)("plugins.spfx.addWebPart.versionMismatch.continue");
            defaultContinueText = (0, localizeUtils_1.getDefaultString)("plugins.spfx.addWebPart.versionMismatch.continue");
            let userSelected;
            const helpText = (0, localizeUtils_1.getLocalizedString)("plugins.spfx.addWebPart.versionMismatch.help");
            do {
                const res = await context.userInteraction.showMessage("info", (0, localizeUtils_1.getLocalizedString)("plugins.spfx.addWebPart.versionMismatch.continueConfirm", displayedSolutionVersion, displayedLocalVersion), true, helpText, continueText);
                userSelected = res.isOk() ? res.value : undefined;
                if (userSelected === helpText) {
                    context.telemetryReporter.sendTelemetryEvent(telemetryEvents_1.TelemetryEvents.LearnMoreVersionMismatch);
                    void context.userInteraction.openUrl(constants_2.Constants.AddWebpartHelpLink);
                }
            } while (userSelected === helpText);
            userAnswer = userSelected;
            context.logProvider.log(teamsfx_api_1.LogLevel.Warning, displayedGlobalVersion
                ? (0, localizeUtils_1.getLocalizedString)("plugins.spfx.addWebPart.versionMismatch.output", displayedSolutionVersion, displayedGlobalVersion, displayedLocalVersion, displayedLocalVersion, constants_2.Constants.AddWebpartHelpLink)
                : (0, localizeUtils_1.getLocalizedString)("plugins.spfx.addWebPart.versionMismatch.localOnly.output", displayedSolutionVersion, displayedLocalVersion, displayedLocalVersion, constants_2.Constants.AddWebpartHelpLink));
        }
        context.telemetryReporter.sendTelemetryEvent(telemetryEvents_1.TelemetryEvents.CheckAddWebPartPackage, {
            [telemetryEvents_1.TelemetryProperty.PackageSource]: "local",
            [telemetryEvents_1.TelemetryProperty.UserAction]: defaultContinueText,
            [telemetryEvents_1.TelemetryProperty.ConfirmAddWebPartResult]: !userAnswer ? "Cancel" : defaultContinueText,
        });
        if (userAnswer !== continueText) {
            throw new error_1.UserCancelError(constants_2.Constants.PLUGIN_NAME);
        }
        else {
            return true;
        }
    }
    static async copySPFxSolution(src, dest) {
        try {
            await fs_extra_1.default.ensureDir(dest);
            await fs_extra_1.default.copy(src, dest, {
                overwrite: true,
                recursive: true,
                filter: (file) => {
                    return file.indexOf("node_modules") < 0;
                },
            });
        }
        catch (e) {
            throw (0, error_2.CopyExistingSPFxSolutionError)(e);
        }
    }
    static async getWebpartManifest(spfxFolder) {
        const webpartsDir = path.join(spfxFolder, "src", "webparts");
        if (await fs_extra_1.default.pathExists(webpartsDir)) {
            const webparts = (await fs_extra_1.default.readdir(webpartsDir)).filter((file) => fs_extra_1.default.statSync(path.join(webpartsDir, file)).isDirectory());
            if (webparts.length < 1) {
                return undefined;
            }
            const webpartManifest = (await fs_extra_1.default.readdir(path.join(webpartsDir, webparts[0]))).find((file) => file.endsWith("WebPart.manifest.json"));
            if (webpartManifest === undefined) {
                throw new error_1.FileNotFoundError(constants_2.Constants.PLUGIN_NAME, path.join(webpartsDir, webparts[0], `${webparts[0].split(path.sep).pop()}WebPart.manifest.json`), constants_2.Constants.IMPORT_HELP_LINK);
            }
            const matchHashComment = new RegExp(/(\/\/ .*)/, "gi");
            const manifest = JSON.parse((await fs_extra_1.default.readFile(path.join(webpartsDir, webparts[0], webpartManifest), "utf8"))
                .toString()
                .replace(matchHashComment, "")
                .trim());
            return manifest;
        }
        return undefined;
    }
    static async updateSPFxTemplate(spfxFolder, destinationPath, importDetails) {
        var _a, _b;
        try {
            importDetails.push(`(.) Processing: Loading manifest.local.json...`);
            const localManifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "manifest.local.json"));
            if (localManifestRes.isErr())
                throw localManifestRes.error;
            const localManifest = localManifestRes.value;
            importDetails.push(`(√) Done: Succeeded to load manifest.local.json.`);
            importDetails.push(`(.) Processing: Loading manifest.json...`);
            const remoteManifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "manifest.json"));
            if (remoteManifestRes.isErr())
                throw remoteManifestRes.error;
            let remoteManifest = remoteManifestRes.value;
            importDetails.push(`(√) Done: Succeeded to load manifest.json.`);
            const webpartsDir = path.join(spfxFolder, "src", "webparts");
            const webparts = (await fs_extra_1.default.readdir(webpartsDir)).filter((file) => fs_extra_1.default.statSync(path.join(webpartsDir, file)).isDirectory());
            if (webparts.length > 1) {
                importDetails.push(`(.) Processing: There're multiple web parts in the SPFx solution, exposing each of them in Teams manifest...`);
                for (let i = 1; i < webparts.length; i++) {
                    const webpart = webparts[i];
                    const webpartManifestFile = (await fs_extra_1.default.readdir(path.join(webpartsDir, webpart))).find((file) => file.endsWith("WebPart.manifest.json"));
                    if (webpartManifestFile === undefined) {
                        importDetails.push(` [${i}] Web part manifest doesn't exist at ${path.join(webpartsDir, webpart, `${webpart}WebPart.manifest.json`)}, skip...`);
                        continue;
                    }
                    const matchHashComment = new RegExp(/(\/\/ .*)/, "gi");
                    const webpartManifest = JSON.parse((await fs_extra_1.default.readFile(path.join(webpartsDir, webpart, webpartManifestFile), "utf8"))
                        .toString()
                        .replace(matchHashComment, "")
                        .trim());
                    importDetails.push(` [${i}] Adding web part to Teams manifest with component id: ${webpartManifest["id"]}, web part name: ${webpartManifest["preconfiguredEntries"][0].title.default}...`);
                    const componentId = webpartManifest["id"];
                    const webpartName = webpartManifest["preconfiguredEntries"][0].title.default;
                    const remoteStaticSnippet = {
                        entityId: componentId,
                        name: webpartName,
                        contentUrl: util.format(constants_2.ManifestTemplate.REMOTE_CONTENT_URL, componentId),
                        websiteUrl: constants_2.ManifestTemplate.WEBSITE_URL,
                        scopes: ["personal"],
                    };
                    const localStaticSnippet = {
                        entityId: componentId,
                        name: webpartName,
                        contentUrl: util.format(constants_2.ManifestTemplate.LOCAL_CONTENT_URL, componentId),
                        websiteUrl: constants_2.ManifestTemplate.WEBSITE_URL,
                        scopes: ["personal"],
                    };
                    (_a = localManifest.staticTabs) === null || _a === void 0 ? void 0 : _a.push(localStaticSnippet);
                    (_b = remoteManifest.staticTabs) === null || _b === void 0 ? void 0 : _b.push(remoteStaticSnippet);
                }
                importDetails.push(`(√) Done: Succeeded to expose additional web parts in Teams manifest.`);
            }
            if (await fs_extra_1.default.pathExists(path.join(spfxFolder, "teams", "manifest.json"))) {
                importDetails.push(`(.) Processing: There's existing Teams manifest under ${path.join(spfxFolder, "teams", "manifest.json")}, updating default template...`);
                const existingManifest = await fs_extra_1.default.readJson(path.join(spfxFolder, "teams", "manifest.json"));
                importDetails.push(`(.) Processing: Writing existing app id in manifest.json to TEAMS_APP_ID in env.dev...`);
                await envUtil_1.envUtil.writeEnv(destinationPath, "dev", { TEAMS_APP_ID: existingManifest.id });
                importDetails.push(`(√) Done: Succeeded to write existing app id to env.dev.`);
                importDetails.push(`(.) Processing: Updating default manifest with existing one...`);
                existingManifest.$schema = remoteManifest.$schema;
                existingManifest.manifestVersion = remoteManifest.manifestVersion;
                existingManifest.id = remoteManifest.id;
                existingManifest.icons = remoteManifest.icons;
                existingManifest.staticTabs = remoteManifest.staticTabs;
                existingManifest.configurableTabs = remoteManifest.configurableTabs;
                remoteManifest = existingManifest;
            }
            // Truncate manifest app name if exceed limitation
            localManifest.name.short = utils_1.Utils.truncateAppShortName(localManifest.name.short);
            remoteManifest.name.short = utils_1.Utils.truncateAppShortName(remoteManifest.name.short);
            importDetails.push(`(.) Processing: Writing to save changes to manifest.local.json...`);
            await ManifestUtils_1.manifestUtils._writeAppManifest(localManifest, path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "manifest.local.json"));
            importDetails.push(`(√) Done: Succeeded to write manifest.local.json.`);
            importDetails.push(`(.) Processing: Writing to save changes to manifest.json...`);
            await ManifestUtils_1.manifestUtils._writeAppManifest(remoteManifest, path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "manifest.json"));
            importDetails.push(`(√) Done: Succeeded to write manifest.json.`);
            let colorUpdated = false, outlineUpdated = false;
            if (await fs_extra_1.default.pathExists(path.join(spfxFolder, "teams"))) {
                for (const file of await fs_extra_1.default.readdir(path.join(spfxFolder, "teams"))) {
                    if (file.endsWith("color.png") && !colorUpdated) {
                        importDetails.push(`(.) Processing: Updating color.png with existing ${path.join(spfxFolder, "teams", file)}`);
                        await fs_extra_1.default.copyFile(path.join(spfxFolder, "teams", file), path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "color.png"));
                        colorUpdated = true;
                        importDetails.push(`(√) Done: Succeeded to update color.png.`);
                    }
                    if (file.endsWith("outline.png") && !outlineUpdated) {
                        importDetails.push(`(.) Processing: Updating outline.png with existing ${path.join(spfxFolder, "teams", file)}`);
                        await fs_extra_1.default.copyFile(path.join(spfxFolder, "teams", file), path.join(destinationPath, teamsfx_api_1.AppPackageFolderName, "outline.png"));
                        outlineUpdated = true;
                        importDetails.push(`(√) Done: Succeeded to update outline.png.`);
                    }
                }
            }
        }
        catch (e) {
            throw (0, error_2.UpdateSPFxTemplateError)(e);
        }
    }
    static async getNodeVersion(solutionPath, context) {
        const packageJsonPath = path.join(solutionPath, constants_2.Constants.PACKAGE_JSON_FILE);
        if (await fs_extra_1.default.pathExists(packageJsonPath)) {
            const jsonContentRes = await jsonUtils_1.jsonUtils.readJSONFile(packageJsonPath);
            if (jsonContentRes.isErr()) {
                telemetry_helper_1.telemetryHelper.sendErrorEvent(context, telemetryEvents_1.TelemetryEvents.GetSpfxNodeVersionFailed, jsonContentRes.error);
            }
            else {
                const packageJson = jsonContentRes.value;
                if (!packageJson.engines) {
                    telemetry_helper_1.telemetryHelper.sendErrorEvent(context, telemetryEvents_1.TelemetryEvents.GetSpfxNodeVersionFailed, (0, error_2.CannotFindPropertyfromJsonError)("engines"));
                }
                else {
                    if (!packageJson.engines.node) {
                        telemetry_helper_1.telemetryHelper.sendErrorEvent(context, telemetryEvents_1.TelemetryEvents.GetSpfxNodeVersionFailed, (0, error_2.CannotFindPropertyfromJsonError)("engines.node"));
                    }
                    else {
                        return packageJson.engines.node;
                    }
                }
            }
        }
        else {
            telemetry_helper_1.telemetryHelper.sendErrorEvent(context, telemetryEvents_1.TelemetryEvents.GetSpfxNodeVersionFailed, new error_1.FileNotFoundError(constants_2.Constants.PLUGIN_NAME, packageJsonPath));
        }
        return constants_2.Constants.DEFAULT_NODE_VERSION;
    }
}
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, actionExecutionMW_1.ActionExecutionMW)({
            enableTelemetry: true,
            telemetryComponentName: constants_2.Constants.PLUGIN_DEV_NAME,
            telemetryEventName: telemetryEvents_1.TelemetryEvents.Generate,
            errorSource: constants_2.Constants.PLUGIN_DEV_NAME,
        }),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], SPFxGenerator, "generate", null);
exports.SPFxGenerator = SPFxGenerator;
class SPFxGeneratorNew extends templateGenerator_1.DefaultTemplateGenerator {
    constructor() {
        super(...arguments);
        this.componentName = "spfx-new-generator";
    }
    activate(context, inputs) {
        const capability = inputs[constants_1.QuestionNames.Capabilities];
        const spfxSolution = inputs[constants_1.QuestionNames.SPFxSolution];
        return capability === constants_1.CapabilityOptions.SPFxTab().id && spfxSolution === "new";
    }
    async getTemplateInfos(context, inputs, destinationPath, actionContext) {
        const spfxSolution = inputs[constants_1.QuestionNames.SPFxSolution];
        (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            [telemetryEvents_1.TelemetryProperty.SPFxSolution]: spfxSolution,
        });
        const yeomanRes = await SPFxGenerator.doYeomanScaffold(context, inputs, destinationPath);
        if (yeomanRes.isErr())
            return (0, teamsfx_api_1.err)(yeomanRes.error);
        return (0, teamsfx_api_1.ok)([
            {
                templateName: constants_2.Constants.TEMPLATE_NAME,
                language: constants_1.ProgrammingLanguage.TS,
                replaceMap: context.templateVariables || {},
            },
        ]);
    }
}
exports.SPFxGeneratorNew = SPFxGeneratorNew;
class SPFxGeneratorImport extends templateGenerator_1.DefaultTemplateGenerator {
    constructor() {
        super(...arguments);
        this.componentName = "spfx-import-generator";
        this.importDetails = [];
    }
    activate(context, inputs) {
        const capability = inputs[constants_1.QuestionNames.Capabilities];
        const spfxSolution = inputs[constants_1.QuestionNames.SPFxSolution];
        return capability === constants_1.CapabilityOptions.SPFxTab().id && spfxSolution !== "new";
    }
    async getTemplateInfos(context, inputs, destinationPath, actionContext) {
        var _a, _b;
        this.importDetails = [];
        try {
            const spfxSolution = inputs[constants_1.QuestionNames.SPFxSolution];
            (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
                [telemetryEvents_1.TelemetryProperty.SPFxSolution]: spfxSolution,
            });
            const spfxFolder = inputs[constants_1.QuestionNames.SPFxFolder];
            const destSpfxFolder = path.join(destinationPath, "src");
            this.importDetails.push(os_1.EOL +
                `(.) Processing: Copying existing SPFx solution from ${spfxFolder} to ${destSpfxFolder}...`);
            await SPFxGenerator.copySPFxSolution(spfxFolder, destSpfxFolder);
            this.importDetails.push(`(√) Done: Succeeded to copy existing SPFx solution.`);
            this.importDetails.push(`(.) Processing: Reading web part manifest in SPFx solution...`);
            const webpartManifest = await SPFxGenerator.getWebpartManifest(spfxFolder);
            if (!webpartManifest ||
                !webpartManifest["id"] ||
                !webpartManifest["preconfiguredEntries"][0].title.default) {
                this.importDetails.push(`(×) Error: Failed to Read web part manifest due to invalid ${!webpartManifest
                    ? "web part manifest"
                    : !webpartManifest["id"]
                        ? "web part manifest id"
                        : "preconfiguredEntries title in web part manifest file"}!`);
                throw (0, error_2.RetrieveSPFxInfoError)();
            }
            this.importDetails.push(`(√) Done: Succeeded to retrieve web part manifest in SPFx solution.`);
            if (!context.templateVariables) {
                context.templateVariables = generator_1.Generator.getDefaultVariables(inputs[constants_1.QuestionNames.AppName]);
            }
            const nodeVersion = await SPFxGenerator.getNodeVersion(destSpfxFolder, context);
            context.templateVariables["SpfxNodeVersion"] = nodeVersion;
            context.templateVariables["componentId"] = webpartManifest["id"];
            context.templateVariables["webpartName"] =
                webpartManifest["preconfiguredEntries"][0].title.default;
            this.importDetails.push(`(.) Processing: Generating SPFx project templates with app name: ${inputs[constants_1.QuestionNames.AppName]}, component id: ${webpartManifest["id"]}, web part name: ${webpartManifest["preconfiguredEntries"][0].title.default}`);
            return (0, teamsfx_api_1.ok)([
                {
                    templateName: constants_2.Constants.TEMPLATE_NAME,
                    language: constants_1.ProgrammingLanguage.TS,
                    replaceMap: context.templateVariables,
                },
            ]);
        }
        catch (error) {
            this.importDetails.push((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.log.fail", (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.getLogFilePath()));
            await context.logProvider.logInFile(teamsfx_api_1.LogLevel.Info, this.importDetails.join(os_1.EOL));
            void context.logProvider.error((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.log.fail", (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.getLogFilePath()));
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
                return (0, teamsfx_api_1.err)(error);
            }
            return (0, teamsfx_api_1.err)((0, error_2.ImportSPFxSolutionError)(error));
        }
    }
    async post(context, inputs, destinationPath, actionContext) {
        var _a, _b, _c, _d;
        try {
            const spfxFolder = inputs[constants_1.QuestionNames.SPFxFolder];
            await SPFxGenerator.updateSPFxTemplate(spfxFolder, destinationPath, this.importDetails);
            this.importDetails.push((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.log.success", (_a = context.logProvider) === null || _a === void 0 ? void 0 : _a.getLogFilePath()));
            await context.logProvider.logInFile(teamsfx_api_1.LogLevel.Info, this.importDetails.join(os_1.EOL));
            void context.logProvider.info((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.log.success", (_b = context.logProvider) === null || _b === void 0 ? void 0 : _b.getLogFilePath()));
            void context.userInteraction.showMessage("info", (0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.success", destinationPath), false);
            return (0, teamsfx_api_1.ok)({});
        }
        catch (error) {
            this.importDetails.push((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.log.fail", (_c = context.logProvider) === null || _c === void 0 ? void 0 : _c.getLogFilePath()));
            await context.logProvider.logInFile(teamsfx_api_1.LogLevel.Info, this.importDetails.join(os_1.EOL));
            void context.logProvider.error((0, localizeUtils_1.getLocalizedString)("plugins.spfx.import.log.fail", (_d = context.logProvider) === null || _d === void 0 ? void 0 : _d.getLogFilePath()));
            if (error instanceof teamsfx_api_1.UserError || error instanceof teamsfx_api_1.SystemError) {
                return (0, teamsfx_api_1.err)(error);
            }
            return (0, teamsfx_api_1.err)((0, error_2.ImportSPFxSolutionError)(error));
        }
    }
}
exports.SPFxGeneratorImport = SPFxGeneratorImport;
//# sourceMappingURL=spfxGenerator.js.map
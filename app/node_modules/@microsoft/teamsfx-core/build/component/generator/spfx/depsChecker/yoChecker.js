"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.YoChecker = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const error_1 = require("../../../../error");
const cpUtils_1 = require("../../../deps-checker/util/cpUtils");
const error_2 = require("../error");
const constants_1 = require("../utils/constants");
const telemetry_helper_1 = require("../utils/telemetry-helper");
const telemetryEvents_1 = require("../utils/telemetryEvents");
const utils_1 = require("../utils/utils");
const name = constants_1.Constants.YeomanPackageName;
const displayName = `${name}`;
const timeout = 6 * 60 * 1000;
class YoChecker {
    constructor(logger) {
        this._logger = logger;
    }
    async ensureDependency(ctx, targetVersion) {
        telemetry_helper_1.telemetryHelper.sendSuccessEvent(ctx, telemetryEvents_1.TelemetryEvents.EnsureYoStart);
        try {
            void this._logger.info(`${displayName}@${targetVersion} not found, installing...`);
            await this.install(targetVersion);
            void this._logger.info(`Successfully installed ${displayName}@${targetVersion}`);
            telemetry_helper_1.telemetryHelper.sendSuccessEvent(ctx, telemetryEvents_1.TelemetryEvents.EnsureYo);
        }
        catch (error) {
            telemetry_helper_1.telemetryHelper.sendErrorEvent(ctx, telemetryEvents_1.TelemetryEvents.EnsureYo, error, {
                [telemetryEvents_1.TelemetryProperty.EnsureYoReason]: error.name,
            });
            this._logger.error(`Failed to install ${displayName}@${targetVersion}, error = '${error.toString()}'`);
            return (0, teamsfx_api_1.err)(error);
        }
        return (0, teamsfx_api_1.ok)(true);
    }
    async findLocalInstalledVersion() {
        try {
            const yoVersion = await this.queryVersion();
            const hasSentinel = await fs_extra_1.default.pathExists(this.getSentinelPath());
            return hasSentinel ? yoVersion : undefined;
        }
        catch (error) {
            return undefined;
        }
    }
    async isLatestInstalled() {
        try {
            const yoVersion = await this.findLocalInstalledVersion();
            const latestYeomanVersion = await this.findLatestVersion(10);
            return !!latestYeomanVersion && yoVersion === latestYeomanVersion;
        }
        catch (error) {
            return false;
        }
    }
    async install(targetVersion) {
        void this._logger.info("Start installing...");
        await this.cleanup();
        await this.installYo(targetVersion);
        void this._logger.info("Validating package...");
        if (!(await this.validate())) {
            void this._logger.debug("Failed to validate yo, cleaning up...");
            await this.cleanup();
            throw (0, error_2.DependencyValidateError)(name);
        }
    }
    getBinFolders() {
        const defaultPath = this.getDefaultInstallPath();
        return [defaultPath, path.join(defaultPath, "node_modules", ".bin")];
    }
    async findGloballyInstalledVersion(timeoutInSeconds) {
        return await utils_1.Utils.findGloballyInstalledVersion(this._logger, name, timeoutInSeconds !== null && timeoutInSeconds !== void 0 ? timeoutInSeconds : 0);
    }
    async findLatestVersion(timeoutInSeconds) {
        return await utils_1.Utils.findLatestVersion(this._logger, name, timeoutInSeconds);
    }
    async validate() {
        return await fs_extra_1.default.pathExists(this.getSentinelPath());
    }
    getDefaultInstallPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "yo");
    }
    getSentinelPath() {
        return path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "yo-sentinel");
    }
    async queryVersion() {
        var _a;
        const packagePath = path.join(this.getDefaultInstallPath(), "node_modules", "yo", "package.json");
        if (await fs_extra_1.default.pathExists(packagePath)) {
            const packageJson = await fs_extra_1.default.readJson(packagePath);
            return (_a = packageJson.version) !== null && _a !== void 0 ? _a : undefined;
        }
        return undefined;
    }
    async cleanup() {
        try {
            const legacyDirectory = path.join(os.homedir(), `.${teamsfx_api_1.ConfigFolderName}`, "bin", "spfx");
            if (fs_extra_1.default.existsSync(legacyDirectory)) {
                await fs_extra_1.default.emptyDir(legacyDirectory);
                await fs_extra_1.default.rmdir(legacyDirectory);
            }
            await fs_extra_1.default.emptyDir(this.getDefaultInstallPath());
            await fs_extra_1.default.remove(this.getSentinelPath());
            const yoExecutables = [
                "yo",
                "yo.cmd",
                "yo.ps1",
                "yo-complete",
                "yo-complete.cmd",
                "yo-complete.ps1",
            ];
            await Promise.all(yoExecutables.map(async (executable) => {
                const executablePath = path.join(this.getDefaultInstallPath(), executable);
                if (await fs_extra_1.default.pathExists(executablePath)) {
                    await fs_extra_1.default.remove(executablePath);
                }
            }));
        }
        catch (err) {
            this._logger.error(`Failed to clean up path: ${this.getDefaultInstallPath()}, error: ${err.toString()}`);
        }
    }
    async installYo(targetVersion) {
        const version = targetVersion !== null && targetVersion !== void 0 ? targetVersion : constants_1.Constants.LatestVersion;
        try {
            await fs_extra_1.default.ensureDir(path.join(this.getDefaultInstallPath(), "node_modules"));
            await cpUtils_1.cpUtils.executeCommand(undefined, this._logger, { timeout: timeout, shell: (0, utils_1.getShellOptionValue)() }, (0, utils_1.getExecCommand)("npm"), "install", `${name}@${version}`, "--prefix", `${this.getDefaultInstallPath()}`, "--no-audit", "--global-style");
            await fs_extra_1.default.ensureFile(this.getSentinelPath());
        }
        catch (error) {
            void this._logger.error(`Failed to execute npm install ${displayName}@${version}`);
            throw new error_1.NpmInstallError(error);
        }
    }
}
exports.YoChecker = YoChecker;
//# sourceMappingURL=yoChecker.js.map
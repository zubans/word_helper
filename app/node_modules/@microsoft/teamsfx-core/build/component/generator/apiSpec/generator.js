"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpecGenerator = void 0;
const tslib_1 = require("tslib");
/**
 * @author yuqzho@microsoft.com
 */
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs = tslib_1.__importStar(require("fs-extra"));
const lodash_1 = require("lodash");
const path_1 = tslib_1.__importDefault(require("path"));
const featureFlags_1 = require("../../../common/featureFlags");
const stringUtils_1 = require("../../../common/stringUtils");
const error_1 = require("../../../error");
const constants_1 = require("../../../question/constants");
const ManifestUtils_1 = require("../../driver/teamsApp/utils/ManifestUtils");
const generator_1 = require("../generator");
const templateGenerator_1 = require("../templates/templateGenerator");
const helper_1 = require("./helper");
const CopilotGptManifestUtils_1 = require("../../driver/teamsApp/utils/CopilotGptManifestUtils");
const constant_1 = require("../constant");
const utils_1 = require("../../../common/utils");
const defaultDeclarativeCopilotActionId = "action_1";
// const fromApiSpecComponentName = "copilot-plugin-existing-api";
// const pluginFromApiSpecComponentName = "api-copilot-plugin-existing-api";
const fromApiSpecTemplateName = "copilot-plugin-existing-api";
// const fromOpenAIPlugincomponentName = "copilot-plugin-from-oai-plugin";
const forCustomCopilotRagCustomApi = "custom-copilot-rag-custom-api";
const copilotPluginExistingApiSpecUrlTelemetryEvent = "copilot-plugin-existing-api-spec-url";
const apiPluginFromApiSpecTemplateName = "api-plugin-existing-api";
const failedToUpdateCustomApiTemplateErrorName = "failed-to-update-custom-api-template";
const defaultDeclarativeCopilotManifestFileName = "declarativeAgent.json";
function normalizePath(path) {
    return "./" + path.replace(/\\/g, "/");
}
class SpecGenerator extends templateGenerator_1.DefaultTemplateGenerator {
    constructor() {
        super(...arguments);
        this.componentName = "spec-generator";
    }
    // isYaml = false;
    // templateName = "";
    // url = "";
    // isPlugin = false;
    // type = -1;
    // activation condition
    activate(context, inputs) {
        const capability = inputs.capabilities;
        const meArchitecture = inputs[constants_1.QuestionNames.MeArchitectureType];
        return (inputs[constants_1.QuestionNames.ApiPluginType] === constants_1.ApiPluginStartOptions.apiSpec().id ||
            meArchitecture === constants_1.MeArchitectureOptions.apiSpec().id ||
            (capability === constants_1.CapabilityOptions.customCopilotRag().id &&
                inputs[constants_1.QuestionNames.CustomCopilotRag] === constants_1.CustomCopilotRagOptions.customApi().id));
    }
    getTemplateName(inputs) {
        const capability = inputs.capabilities;
        const meArchitecture = inputs[constants_1.QuestionNames.MeArchitectureType];
        let templateName = "";
        if ((capability === constants_1.CapabilityOptions.apiPlugin().id ||
            capability === constants_1.CapabilityOptions.declarativeCopilot().id) &&
            inputs[constants_1.QuestionNames.ApiPluginType] === constants_1.ApiPluginStartOptions.apiSpec().id) {
            templateName = apiPluginFromApiSpecTemplateName;
        }
        else if (meArchitecture === constants_1.MeArchitectureOptions.apiSpec().id) {
            templateName = fromApiSpecTemplateName;
        }
        else if (capability === constants_1.CapabilityOptions.customCopilotRag().id &&
            inputs[constants_1.QuestionNames.CustomCopilotRag] === constants_1.CustomCopilotRagOptions.customApi().id) {
            templateName = forCustomCopilotRagCustomApi;
        }
        return templateName;
    }
    async getTemplateInfos(context, inputs, destinationPath, actionContext) {
        var _a;
        const meArchitecture = inputs[constants_1.QuestionNames.MeArchitectureType];
        const getTemplateInfosState = {
            isYaml: false,
            templateName: this.getTemplateName(inputs),
            url: inputs[constants_1.QuestionNames.ApiSpecLocation].trim(),
            isPlugin: false,
            type: m365_spec_parser_1.ProjectType.SME,
        };
        let authData = undefined;
        if (inputs[constants_1.QuestionNames.ApiPluginType] === constants_1.ApiPluginStartOptions.apiSpec().id) {
            getTemplateInfosState.isPlugin = true;
            authData = inputs.apiAuthData;
        }
        else if (meArchitecture === constants_1.MeArchitectureOptions.apiSpec().id) {
            authData = inputs.apiAuthData;
        }
        const isDeclarativeCopilot = inputs[constants_1.QuestionNames.Capabilities] === constants_1.CapabilityOptions.declarativeCopilot().id;
        (0, lodash_1.merge)(actionContext === null || actionContext === void 0 ? void 0 : actionContext.telemetryProps, {
            ["template-name" /* telemetryProperties.templateName */]: getTemplateInfosState.templateName,
            ["is-declarative-copilot" /* telemetryProperties.isDeclarativeCopilot */]: isDeclarativeCopilot.toString(),
        });
        // For Kiota integration, we need to get auth info here
        const isKiotaIntegration = featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
            inputs[constants_1.QuestionNames.ApiPluginManifestPath];
        if (isKiotaIntegration) {
            const operationsResult = await (0, helper_1.listOperations)(context, inputs[constants_1.QuestionNames.ApiSpecLocation], inputs);
            if (operationsResult.isErr()) {
                const msg = operationsResult.error.map((e) => e.content).join("\n");
                return (0, teamsfx_api_1.err)(new teamsfx_api_1.UserError("generator", "ListOperationsFailed", msg));
            }
            const operations = operationsResult.value;
            const authApi = operations.find((api) => !!api.data.authName);
            if (authApi) {
                authData = authApi.data;
            }
        }
        const appName = inputs[constants_1.QuestionNames.AppName];
        let language = inputs[constants_1.QuestionNames.ProgrammingLanguage];
        if (getTemplateInfosState.templateName !== forCustomCopilotRagCustomApi) {
            language =
                language === constants_1.ProgrammingLanguage.CSharp
                    ? constants_1.ProgrammingLanguage.CSharp
                    : constants_1.ProgrammingLanguage.None;
        }
        const safeProjectNameFromVS = language === "csharp" ? inputs[constants_1.QuestionNames.SafeProjectName] : undefined;
        getTemplateInfosState.type =
            getTemplateInfosState.templateName === forCustomCopilotRagCustomApi
                ? m365_spec_parser_1.ProjectType.TeamsAi
                : getTemplateInfosState.isPlugin
                    ? m365_spec_parser_1.ProjectType.Copilot
                    : m365_spec_parser_1.ProjectType.SME;
        try {
            getTemplateInfosState.isYaml = !(await (0, utils_1.isJsonSpecFile)(getTemplateInfosState.url));
        }
        catch (e) { }
        const openapiSpecFileName = getTemplateInfosState.isYaml
            ? teamsfx_api_1.DefaultApiSpecYamlFileName
            : teamsfx_api_1.DefaultApiSpecJsonFileName;
        const llmService = inputs[constants_1.QuestionNames.LLMService];
        const openAIKey = inputs[constants_1.QuestionNames.OpenAIKey];
        const azureOpenAIKey = inputs[constants_1.QuestionNames.AzureOpenAIKey];
        const azureOpenAIEndpoint = inputs[constants_1.QuestionNames.AzureOpenAIEndpoint];
        const azureOpenAIDeploymentName = inputs[constants_1.QuestionNames.AzureOpenAIDeploymentName];
        const llmServiceData = {
            llmService,
            openAIKey,
            azureOpenAIKey,
            azureOpenAIEndpoint,
            azureOpenAIDeploymentName,
        };
        if (authData === null || authData === void 0 ? void 0 : authData.authName) {
            const envName = (0, helper_1.getEnvName)(authData.authName, authData.authType);
            context.templateVariables = generator_1.Generator.getDefaultVariables(appName, safeProjectNameFromVS, inputs.targetFramework, inputs.placeProjectFileInSolutionDir === "true", {
                authName: authData.authName,
                openapiSpecPath: isKiotaIntegration
                    ? normalizePath(path_1.default.join(teamsfx_api_1.AppPackageFolderName, path_1.default.basename(inputs[constants_1.QuestionNames.ApiSpecLocation])))
                    : normalizePath(path_1.default.join(teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.DefaultApiSpecFolderName, openapiSpecFileName)),
                registrationIdEnvName: envName,
                authType: authData.authType,
            }, llmServiceData);
        }
        else {
            context.templateVariables = generator_1.Generator.getDefaultVariables(appName, safeProjectNameFromVS, inputs.targetFramework, inputs.placeProjectFileInSolutionDir === "true", undefined, llmServiceData);
        }
        context.telemetryReporter.sendTelemetryEvent(copilotPluginExistingApiSpecUrlTelemetryEvent, {
            ["remote-url" /* telemetryProperties.isRemoteUrlTelemetryProperty */]: (0, stringUtils_1.isValidHttpUrl)(getTemplateInfosState.url).toString(),
            ["generate-type" /* telemetryProperties.generateType */]: getTemplateInfosState.type.toString(),
            ["auth-type" /* telemetryProperties.authType */]: (_a = authData === null || authData === void 0 ? void 0 : authData.authName) !== null && _a !== void 0 ? _a : "None",
        });
        inputs.getTemplateInfosState = getTemplateInfosState;
        return (0, teamsfx_api_1.ok)([
            {
                templateName: getTemplateInfosState.templateName,
                language: language,
                replaceMap: Object.assign(Object.assign({}, context.templateVariables), { DeclarativeCopilot: isDeclarativeCopilot ? "true" : "", FileFunction: featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.EnvFileFunc) ? "true" : "" }),
                filterFn: (fileName) => {
                    if (fileName.includes(`${defaultDeclarativeCopilotManifestFileName}.tpl`)) {
                        return isDeclarativeCopilot;
                    }
                    else if (fileName.includes(constant_1.declarativeCopilotInstructionFileName)) {
                        return (isDeclarativeCopilot && featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.EnvFileFunc));
                    }
                    {
                        return true;
                    }
                },
            },
        ]);
    }
    async post(context, inputs, destinationPath, actionContext) {
        try {
            const getTemplateInfosState = inputs.getTemplateInfosState;
            const isDeclarativeCopilot = inputs[constants_1.QuestionNames.Capabilities] === constants_1.CapabilityOptions.declarativeCopilot().id;
            const isKiotaIntegration = featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
                !!inputs[constants_1.QuestionNames.ApiPluginManifestPath];
            const manifestPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ManifestTemplateFileName);
            const apiSpecFolderPath = path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, isKiotaIntegration ? "" : teamsfx_api_1.DefaultApiSpecFolderName);
            const openapiSpecFileName = isKiotaIntegration
                ? path_1.default.basename(inputs[constants_1.QuestionNames.ApiSpecLocation])
                : getTemplateInfosState.isYaml
                    ? teamsfx_api_1.DefaultApiSpecYamlFileName
                    : teamsfx_api_1.DefaultApiSpecJsonFileName;
            let openapiSpecPath = path_1.default.join(apiSpecFolderPath, openapiSpecFileName);
            if (getTemplateInfosState.templateName === forCustomCopilotRagCustomApi) {
                const language = inputs[constants_1.QuestionNames.ProgrammingLanguage];
                if (language === constants_1.ProgrammingLanguage.CSharp) {
                    openapiSpecPath = path_1.default.join(destinationPath, teamsfx_api_1.DefaultApiSpecFolderName, openapiSpecFileName);
                }
            }
            await fs.ensureDir(apiSpecFolderPath);
            let warnings;
            const pluginManifestPath = getTemplateInfosState.type === m365_spec_parser_1.ProjectType.Copilot
                ? path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, isKiotaIntegration
                    ? path_1.default.basename(inputs[constants_1.QuestionNames.ApiPluginManifestPath])
                    : teamsfx_api_1.DefaultPluginManifestFileName)
                : undefined;
            const responseTemplateFolder = getTemplateInfosState.type === m365_spec_parser_1.ProjectType.SME
                ? path_1.default.join(destinationPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.ResponseTemplatesFolderName)
                : undefined;
            const specParser = new m365_spec_parser_1.SpecParser(getTemplateInfosState.url, (0, helper_1.getParserOptions)(getTemplateInfosState.type, isDeclarativeCopilot));
            const generateResult = await (0, helper_1.generateFromApiSpec)(specParser, manifestPath, inputs, context, this.componentName, getTemplateInfosState.type, {
                destinationApiSpecFilePath: openapiSpecPath,
                pluginManifestFilePath: pluginManifestPath,
                responseTemplateFolder,
            });
            if (generateResult.isErr()) {
                return (0, teamsfx_api_1.err)(generateResult.error);
            }
            else {
                warnings = generateResult.value.warnings;
            }
            if (isDeclarativeCopilot) {
                const gptManifestPath = path_1.default.join(path_1.default.dirname(manifestPath), defaultDeclarativeCopilotManifestFileName);
                const addAcionResult = await CopilotGptManifestUtils_1.copilotGptManifestUtils.addAction(gptManifestPath, defaultDeclarativeCopilotActionId, path_1.default.basename(pluginManifestPath));
                if (addAcionResult.isErr()) {
                    return (0, teamsfx_api_1.err)(addAcionResult.error);
                }
            }
            if (getTemplateInfosState.templateName === forCustomCopilotRagCustomApi) {
                const specs = await specParser.getFilteredSpecs(inputs[constants_1.QuestionNames.ApiOperation]);
                const spec = specs[1];
                try {
                    const language = inputs[constants_1.QuestionNames.ProgrammingLanguage];
                    const updateWarnings = await (0, helper_1.updateForCustomApi)(spec, language, destinationPath, openapiSpecFileName);
                    warnings.push(...updateWarnings);
                }
                catch (error) {
                    throw new teamsfx_api_1.SystemError(this.componentName, failedToUpdateCustomApiTemplateErrorName, error.message, error.message);
                }
            }
            const manifestRes = await ManifestUtils_1.manifestUtils._readAppManifest(manifestPath);
            if (manifestRes.isErr()) {
                return (0, teamsfx_api_1.err)(manifestRes.error);
            }
            const teamsManifest = manifestRes.value;
            // log warnings
            if (inputs.platform === teamsfx_api_1.Platform.CLI || inputs.platform === teamsfx_api_1.Platform.VS) {
                const warnSummary = await (0, helper_1.generateScaffoldingSummary)(warnings, teamsManifest, path_1.default.relative(destinationPath, openapiSpecPath), pluginManifestPath === undefined
                    ? undefined
                    : path_1.default.relative(destinationPath, pluginManifestPath), destinationPath);
                if (warnSummary) {
                    context.logProvider.info(warnSummary);
                }
            }
            if (inputs.platform === teamsfx_api_1.Platform.VSCode) {
                return (0, teamsfx_api_1.ok)({
                    warnings: warnings.map((warning) => {
                        return {
                            type: warning.type,
                            content: warning.content,
                            data: warning.data,
                        };
                    }),
                });
            }
            else {
                return (0, teamsfx_api_1.ok)({ warnings: undefined });
            }
        }
        catch (e) {
            let error;
            if (e instanceof m365_spec_parser_1.SpecParserError) {
                error = (0, helper_1.convertSpecParserErrorToFxError)(e);
            }
            else {
                error = (0, error_1.assembleError)(e);
            }
            return (0, teamsfx_api_1.err)(error);
        }
    }
}
exports.SpecGenerator = SpecGenerator;
//# sourceMappingURL=generator.js.map
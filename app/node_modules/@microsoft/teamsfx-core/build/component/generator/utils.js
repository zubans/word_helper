"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.isApiLimitError = exports.simplifyAxiosError = exports.convertToUrl = exports.convertToLangKey = exports.runWithLimitedConcurrency = exports.getSampleFileInfo = exports.downloadDirectory = exports.zipFolder = exports.getSampleInfoFromName = exports.renderTemplateFileName = exports.renderTemplateFileData = exports.unzip = exports.fetchZipFromUrl = exports.getTemplateZipUrlByVersion = exports.getTemplateLatestVersion = exports.getTemplateUrl = void 0;
const tslib_1 = require("tslib");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const axios_1 = tslib_1.__importDefault(require("axios"));
const fs = tslib_1.__importStar(require("fs-extra"));
const lodash_1 = require("lodash");
const mustache_1 = tslib_1.__importStar(require("mustache"));
const path_1 = tslib_1.__importDefault(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const requestUtils_1 = require("../../common/requestUtils");
const samples_1 = require("../../common/samples");
const templates_config_json_1 = tslib_1.__importDefault(require("../../common/templates-config.json"));
const error_1 = require("../../error");
const constants_1 = require("../../question/constants");
const constant_1 = require("./constant");
async function getTemplateUrl(name, getLatestVersion) {
    if (process.env.TEAMSFX_TEMPLATE_PRERELEASE) {
        return getTemplateZipUrlByVersion(name, `0.0.0-${process.env.TEAMSFX_TEMPLATE_PRERELEASE}`);
    }
    if (!templates_config_json_1.default.useLocalTemplate) {
        const latestVersion = await getLatestVersion();
        if (semver_1.default.gt(latestVersion, templates_config_json_1.default.localVersion)) {
            // Upstream latest version is higher than the local version, return upstream templates url for downloading.
            return getTemplateZipUrlByVersion(name, latestVersion);
        }
    }
}
exports.getTemplateUrl = getTemplateUrl;
async function selectTemplateVersion(getTags) {
    const templateTagPrefix = templates_config_json_1.default.tagPrefix;
    const versionPattern = templates_config_json_1.default.version;
    const versionList = (await getTags()).map((tag) => tag.replace(templateTagPrefix, ""));
    const selectedVersion = semver_1.default.maxSatisfying(versionList, versionPattern);
    return selectedVersion !== null && selectedVersion !== void 0 ? selectedVersion : undefined;
}
async function fetchTagList(url, tryLimits, timeoutInMs) {
    const res = await (0, requestUtils_1.sendRequestWithTimeout)(async (cancelToken) => {
        return await axios_1.default.get(url, {
            cancelToken: cancelToken,
        });
    }, timeoutInMs, tryLimits);
    return res.data;
}
async function getTemplateLatestVersion(tryLimits = constant_1.defaultTryLimits, timeoutInMs = constant_1.defaultTimeoutInMs) {
    const templateTagListURL = templates_config_json_1.default.tagListURL;
    const selectedVersion = await selectTemplateVersion(async () => (await fetchTagList(templateTagListURL, tryLimits, timeoutInMs)).replace(/\r/g, "").split("\n"));
    if (!selectedVersion) {
        throw new Error(`Failed to find valid template`);
    }
    return selectedVersion;
}
exports.getTemplateLatestVersion = getTemplateLatestVersion;
function getTemplateZipUrlByVersion(name, version) {
    return `${templates_config_json_1.default.templateDownloadBaseURL}/${templates_config_json_1.default.tagPrefix}${version}/${name}${templates_config_json_1.default.templateExt}`;
}
exports.getTemplateZipUrlByVersion = getTemplateZipUrlByVersion;
async function fetchZipFromUrl(url, tryLimits = constant_1.defaultTryLimits, timeoutInMs = constant_1.defaultTimeoutInMs) {
    const res = await (0, requestUtils_1.sendRequestWithRetry)(async () => {
        return await axios_1.default.get(url, {
            responseType: "arraybuffer",
            timeout: timeoutInMs,
        });
    }, tryLimits);
    const zip = new adm_zip_1.default(res.data);
    return zip;
}
exports.fetchZipFromUrl = fetchZipFromUrl;
/* The unzip used for scaffold which would drop the attr of the files and dirs. */
async function unzip(zip, dstPath, nameReplaceFn, dataReplaceFn, filterFn) {
    const output = [];
    let entries = zip.getEntries().filter((entry) => !entry.isDirectory);
    if (filterFn) {
        entries = entries.filter((entry) => filterFn(entry.entryName));
    }
    for (const entry of entries) {
        const rawEntryData = entry.getData();
        const entryName = nameReplaceFn
            ? nameReplaceFn(entry.entryName, rawEntryData)
            : entry.entryName;
        const entryData = dataReplaceFn
            ? dataReplaceFn(entry.name, rawEntryData)
            : rawEntryData;
        const filePath = path_1.default.join(dstPath, entryName);
        const dirPath = path_1.default.dirname(filePath);
        await fs.ensureDir(dirPath);
        await fs.writeFile(filePath, entryData);
        output.push(entryName);
    }
    return output;
}
exports.unzip = unzip;
function renderTemplateFileData(fileName, fileData, variables) {
    //only mustache files with name ending with .tpl
    if (path_1.default.extname(fileName) === constant_1.templateFileExt) {
        const token = escapeEmptyVariable(fileData.toString(), variables !== null && variables !== void 0 ? variables : {});
        const writer = new mustache_1.Writer();
        const result = writer.renderTokens(token, new mustache_1.Context(variables));
        // Be compatible with current stable templates, can be removed after new template released.
        return mustache_1.default.render(result, variables, {}, constant_1.oldPlaceholderDelimiters);
    }
    // Return Buffer instead of string if the file is not a template. Because `toString()` may break binary resources, like png files.
    return fileData;
}
exports.renderTemplateFileData = renderTemplateFileData;
function escapeEmptyVariable(template, view, tags = constant_1.placeholderDelimiters) {
    const parsed = mustache_1.default.parse(template, tags);
    const tokens = (0, lodash_1.cloneDeep)(parsed); // Mustache cache the parsed result. Modify the result in place may cause unexpected issue.
    updateTokens(tokens, view, tags, 0);
    return tokens;
}
function updateTokens(tokens, view, tags, accShift) {
    const shift = tags[0].length + tags[1].length;
    // token: [Type, Value, Start, End]
    for (const token of tokens) {
        token[2] += accShift;
        const value = token[1];
        if (token[0] === "name" && (view[value] === undefined || view[value] === null)) {
            token[0] = "text";
            token[1] = tags[0] + value + tags[1];
            accShift += shift;
        }
        else if (token[0] === "#" || token[0] === "^") {
            token[2] += accShift;
            token[3] += accShift;
            accShift += updateTokens(token[4], view, tags, accShift);
            token[5] += accShift;
        }
    }
    return accShift;
}
function renderTemplateFileName(fileName, fileData, variables) {
    return mustache_1.default.render(fileName, variables, {}, constant_1.placeholderDelimiters).replace(constant_1.templateFileExt, "");
}
exports.renderTemplateFileName = renderTemplateFileName;
async function getSampleInfoFromName(sampleName) {
    const sample = (await samples_1.sampleProvider.SampleCollection).samples.find((sample) => sample.id.toLowerCase() === sampleName.toLowerCase());
    if (!sample) {
        throw new error_1.InputValidationError(`sample '${sampleName}'`, "not found");
    }
    return sample;
}
exports.getSampleInfoFromName = getSampleInfoFromName;
function zipFolder(folderPath) {
    const zip = new adm_zip_1.default();
    zip.addLocalFolder(folderPath);
    return zip;
}
exports.zipFolder = zipFolder;
async function downloadDirectory(sampleInfo, dstPath, concurrencyLimits = constant_1.sampleConcurrencyLimits, retryLimits = constant_1.sampleDefaultRetryLimits) {
    const { samplePaths, fileUrlPrefix } = await getSampleFileInfo(sampleInfo, retryLimits);
    await downloadSampleFiles(sampleInfo, fileUrlPrefix, samplePaths, dstPath, sampleInfo.dir, retryLimits, concurrencyLimits);
    return samplePaths;
}
exports.downloadDirectory = downloadDirectory;
async function getSampleFileInfo(urlInfo, retryLimits) {
    var _a;
    const fileInfoUrl = `https://api.github.com/repos/${urlInfo.owner}/${urlInfo.repository}/git/trees/${urlInfo.ref}?recursive=1`;
    const fileInfo = (await (0, requestUtils_1.sendRequestWithRetry)(async () => {
        return await axios_1.default.get(fileInfoUrl);
    }, retryLimits)).data;
    const samplePaths = (_a = fileInfo === null || fileInfo === void 0 ? void 0 : fileInfo.tree) === null || _a === void 0 ? void 0 : _a.filter((node) => node.path.startsWith(`${urlInfo.dir}/`) && node.type !== "tree").map((node) => node.path);
    const fileUrlPrefix = `https://raw.githubusercontent.com/${urlInfo.owner}/${urlInfo.repository}/${fileInfo === null || fileInfo === void 0 ? void 0 : fileInfo.sha}/`;
    return { samplePaths, fileUrlPrefix };
}
exports.getSampleFileInfo = getSampleFileInfo;
async function downloadSampleFiles(sampleInfo, fileUrlPrefix, samplePaths, dstPath, relativePath, retryLimits, concurrencyLimits) {
    const downloadCallback = async (samplePath) => {
        const lfsRegex = /^.*oid sha256:[0-9a-f]+\nsize \d+/gm;
        const file = (await (0, requestUtils_1.sendRequestWithRetry)(async () => {
            const content = await axios_1.default.get(fileUrlPrefix + samplePath, { responseType: "arraybuffer" });
            if (lfsRegex.test(content.data.toString())) {
                return await axios_1.default.get(`https://media.githubusercontent.com/media/${sampleInfo.owner}/${sampleInfo.repository}/${sampleInfo.ref}/${samplePath}`, {
                    responseType: "arraybuffer",
                });
            }
            else {
                return content;
            }
        }, retryLimits));
        const filePath = path_1.default.join(dstPath, path_1.default.relative(`${relativePath}/`, samplePath));
        await fs.ensureFile(filePath);
        await fs.writeFile(filePath, Buffer.from(file.data));
    };
    await runWithLimitedConcurrency(samplePaths, downloadCallback, concurrencyLimits);
}
async function runWithLimitedConcurrency(items, callback, concurrencyLimit) {
    const queue = [];
    for (const item of items) {
        // fire the async function, add its promise to the queue, and remove
        // it from queue when complete
        const p = callback(item)
            .then((res) => {
            queue.splice(queue.indexOf(p), 1);
            return res;
        })
            .catch((err) => {
            throw err;
        });
        queue.push(p);
        // if max concurrent, wait for one to finish
        if (queue.length >= concurrencyLimit) {
            await Promise.race(queue);
        }
    }
    // wait for the rest of the calls to finish
    await Promise.all(queue);
}
exports.runWithLimitedConcurrency = runWithLimitedConcurrency;
function convertToLangKey(programmingLanguage) {
    switch (programmingLanguage) {
        case constants_1.ProgrammingLanguage.JS: {
            return "js";
        }
        case constants_1.ProgrammingLanguage.TS: {
            return "ts";
        }
        case constants_1.ProgrammingLanguage.CSharp: {
            return "csharp";
        }
        case constants_1.ProgrammingLanguage.PY: {
            return "python";
        }
        case constants_1.ProgrammingLanguage.None: {
            return "common";
        }
    }
    return programmingLanguage;
}
exports.convertToLangKey = convertToLangKey;
function convertToUrl(sampleInfo) {
    return `https://github.com/${sampleInfo.owner}/${sampleInfo.repository}/tree/${sampleInfo.ref}/${sampleInfo.dir}`;
}
exports.convertToUrl = convertToUrl;
function simplifyAxiosError(error) {
    var _a, _b, _c, _d;
    const simplifiedError = {
        message: error.message,
        name: error.name,
        config: error.config,
        code: error.code,
        stack: error.stack,
        status: (_a = error.response) === null || _a === void 0 ? void 0 : _a.status,
        statusText: (_b = error.response) === null || _b === void 0 ? void 0 : _b.statusText,
        headers: (_c = error.response) === null || _c === void 0 ? void 0 : _c.headers,
        data: (_d = error.response) === null || _d === void 0 ? void 0 : _d.data,
    };
    return simplifiedError;
}
exports.simplifyAxiosError = simplifyAxiosError;
function isApiLimitError(error) {
    var _a, _b, _c;
    //https://docs.github.com/en/rest/overview/rate-limits-for-the-rest-api?apiVersion=2022-11-28#exceeding-the-rate-limit
    return (axios_1.default.isAxiosError(error) &&
        ((_a = error.response) === null || _a === void 0 ? void 0 : _a.status) !== undefined &&
        [403, 429].includes(error.response.status) &&
        ((_c = (_b = error.response) === null || _b === void 0 ? void 0 : _b.headers) === null || _c === void 0 ? void 0 : _c["x-ratelimit-remaining"]) === "0");
}
exports.isApiLimitError = isApiLimitError;
//# sourceMappingURL=utils.js.map
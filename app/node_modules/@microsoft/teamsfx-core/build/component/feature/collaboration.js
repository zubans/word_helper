"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.TeamsCollaboration = exports.AadCollaboration = void 0;
const tslib_1 = require("tslib");
const lib_1 = require("@feathersjs/hooks/lib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const axios_1 = tslib_1.__importDefault(require("axios"));
const typedi_1 = require("typedi");
const teamsDevPortalClient_1 = require("../../client/teamsDevPortalClient");
const constants_1 = require("../../common/constants");
const globalVars_1 = require("../../common/globalVars");
const common_1 = require("../../error/common");
const teamsApp_1 = require("../../error/teamsApp");
const aadAppClient_1 = require("../driver/aad/utility/aadAppClient");
const constants_2 = require("../driver/aad/utility/constants");
const addStartAndEndTelemetry_1 = require("../driver/middleware/addStartAndEndTelemetry");
const constants_3 = require("../driver/teamsApp/constants");
const EventName = {
    grantPermission: "grant-permission",
    listCollaborator: "list-collaborator",
    checkPermission: "check-permission",
};
const componentNameAad = "fx-resource-aad-app-for-teams";
const componentNameTeams = "AppStudioPlugin";
let AadCollaboration = class AadCollaboration {
    constructor(m365TokenProvider, logProvider) {
        this.aadAppClient = new aadAppClient_1.AadAppClient(m365TokenProvider, logProvider);
    }
    async grantPermission(ctx, objectId, userObjectId) {
        try {
            await this.aadAppClient.addOwner(objectId, userObjectId);
            const result = [
                {
                    name: constants_2.permissionsKeys.name,
                    type: constants_2.permissionsKeys.type,
                    roles: [constants_2.permissionsKeys.owner],
                    resourceId: objectId,
                },
            ];
            return (0, teamsfx_api_1.ok)(result);
        }
        catch (error) {
            return (0, teamsfx_api_1.err)(this.handleError(error, ctx, objectId));
        }
    }
    async listCollaborator(ctx, objectId) {
        try {
            const owners = await this.aadAppClient.getOwners(objectId);
            return (0, teamsfx_api_1.ok)(owners !== null && owners !== void 0 ? owners : []);
        }
        catch (error) {
            return (0, teamsfx_api_1.err)(this.handleError(error, ctx, objectId));
        }
    }
    async checkPermission(ctx, objectId, userObjectId) {
        try {
            const owners = await this.aadAppClient.getOwners(objectId);
            const isAadOwner = owners === null || owners === void 0 ? void 0 : owners.find((owner) => owner.userObjectId === userObjectId);
            const result = [
                {
                    name: constants_2.permissionsKeys.name,
                    type: constants_2.permissionsKeys.type,
                    roles: isAadOwner ? [constants_2.permissionsKeys.owner] : [constants_2.permissionsKeys.noPermission],
                    resourceId: objectId,
                },
            ];
            return (0, teamsfx_api_1.ok)(result);
        }
        catch (error) {
            return (0, teamsfx_api_1.err)(this.handleError(error, ctx, objectId));
        }
    }
    handleError(error, ctx, appId) {
        var _a, _b;
        if (axios_1.default.isAxiosError(error)) {
            const message = JSON.stringify(error.response.data);
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(message);
            if (error.response.status === 404) {
                return new teamsApp_1.AppIdNotExist(appId);
            }
            else if (error.response.status >= 400 && error.response.status < 500) {
                return new common_1.HttpClientError(error, componentNameAad, message);
            }
            else {
                return new common_1.HttpServerError(error, componentNameAad, message);
            }
        }
        const message = JSON.stringify(error);
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error(message);
        return (0, common_1.assembleError)(error, componentNameAad);
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ source: "Graph", component: "AadCollaboration" }),
        (0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(EventName.grantPermission, componentNameAad),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AadCollaboration.prototype, "grantPermission", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ source: "Graph", component: "AadCollaboration" }),
        (0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(EventName.listCollaborator, componentNameAad),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AadCollaboration.prototype, "listCollaborator", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ source: "Graph", component: "AadCollaboration" }),
        (0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(EventName.checkPermission, componentNameAad),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], AadCollaboration.prototype, "checkPermission", null);
AadCollaboration = tslib_1.__decorate([
    (0, typedi_1.Service)("aad-collaboration"),
    tslib_1.__metadata("design:paramtypes", [Object, Object])
], AadCollaboration);
exports.AadCollaboration = AadCollaboration;
let TeamsCollaboration = class TeamsCollaboration {
    constructor(m365TokenProvider) {
        this.tokenProvider = m365TokenProvider;
    }
    async grantPermission(ctx, teamsAppId, userInfo) {
        try {
            const appStudioTokenRes = await this.tokenProvider.getAccessToken({
                scopes: constants_1.AppStudioScopes,
            });
            const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
            await teamsDevPortalClient_1.teamsDevPortalClient.grantPermission(appStudioToken, teamsAppId, userInfo);
            const result = [
                {
                    name: constants_3.Constants.PERMISSIONS.name,
                    roles: [constants_3.Constants.PERMISSIONS.admin],
                    type: constants_3.Constants.PERMISSIONS.type,
                    resourceId: teamsAppId,
                },
            ];
            return (0, teamsfx_api_1.ok)(result);
        }
        catch (error) {
            return (0, teamsfx_api_1.err)(this.handleError(error, ctx, teamsAppId));
        }
    }
    async listCollaborator(ctx, teamsAppId) {
        try {
            const appStudioTokenRes = await this.tokenProvider.getAccessToken({
                scopes: constants_1.AppStudioScopes,
            });
            const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
            const userLists = await teamsDevPortalClient_1.teamsDevPortalClient.getUserList(appStudioToken, teamsAppId);
            if (!userLists) {
                return (0, teamsfx_api_1.ok)([]);
            }
            const teamsAppAdmin = userLists
                .filter((userList) => {
                return userList.isAdministrator;
            })
                .map((userList) => {
                return {
                    userObjectId: userList.aadId,
                    displayName: userList.displayName,
                    userPrincipalName: userList.userPrincipalName,
                    resourceId: teamsAppId,
                };
            });
            return (0, teamsfx_api_1.ok)(teamsAppAdmin);
        }
        catch (error) {
            return (0, teamsfx_api_1.err)(this.handleError(error, ctx, teamsAppId));
        }
    }
    async checkPermission(ctx, teamsAppId, userInfo) {
        try {
            const appStudioTokenRes = await this.tokenProvider.getAccessToken({
                scopes: constants_1.AppStudioScopes,
            });
            const appStudioToken = appStudioTokenRes.isOk() ? appStudioTokenRes.value : undefined;
            const teamsAppRoles = await teamsDevPortalClient_1.teamsDevPortalClient.checkPermission(appStudioToken, teamsAppId, userInfo.aadId);
            const result = [
                {
                    name: constants_3.Constants.PERMISSIONS.name,
                    roles: [teamsAppRoles],
                    type: constants_3.Constants.PERMISSIONS.type,
                    resourceId: teamsAppId,
                },
            ];
            return (0, teamsfx_api_1.ok)(result);
        }
        catch (error) {
            return (0, teamsfx_api_1.err)(this.handleError(error, ctx, teamsAppId));
        }
    }
    handleError(error, ctx, appId) {
        var _a, _b;
        if (error.innerError) {
            const message = JSON.stringify(error.innerError.response.data);
            (_a = ctx.logProvider) === null || _a === void 0 ? void 0 : _a.error(message);
            if (error.innerError.response.status) {
                const statusCode = error.innerError.response.status;
                if (statusCode === 404) {
                    return new teamsApp_1.AppIdNotExist(appId);
                }
                else if (statusCode >= 400 && statusCode < 500) {
                    return new common_1.HttpClientError(error, componentNameTeams, message);
                }
                else {
                    return new common_1.HttpServerError(error, componentNameTeams, message);
                }
            }
        }
        const message = JSON.stringify(error);
        (_b = ctx.logProvider) === null || _b === void 0 ? void 0 : _b.error(message);
        return (0, common_1.assembleError)(error, componentNameTeams);
    }
};
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsCollaboration" }),
        (0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(EventName.grantPermission, componentNameTeams),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsCollaboration.prototype, "grantPermission", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsCollaboration" }),
        (0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(EventName.listCollaborator, componentNameTeams),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsCollaboration.prototype, "listCollaborator", null);
tslib_1.__decorate([
    (0, lib_1.hooks)([
        (0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsCollaboration" }),
        (0, addStartAndEndTelemetry_1.addStartAndEndTelemetry)(EventName.checkPermission, componentNameTeams),
    ]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsCollaboration.prototype, "checkPermission", null);
TeamsCollaboration = tslib_1.__decorate([
    (0, typedi_1.Service)("teams-collaboration"),
    tslib_1.__metadata("design:paramtypes", [Object])
], TeamsCollaboration);
exports.TeamsCollaboration = TeamsCollaboration;
//# sourceMappingURL=collaboration.js.map
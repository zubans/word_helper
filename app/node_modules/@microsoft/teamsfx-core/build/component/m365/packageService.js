"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.PackageService = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const adm_zip_1 = tslib_1.__importDefault(require("adm-zip"));
const form_data_1 = tslib_1.__importDefault(require("form-data"));
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const globalVars_1 = require("../../common/globalVars");
const common_1 = require("../../error/common");
const types_1 = require("../../error/types");
const telemetry_1 = require("../../common/telemetry");
const utils_1 = require("../../common/utils");
const wrappedAxiosClient_1 = require("../../common/wrappedAxiosClient");
const errors_1 = require("./errors");
const serviceConstant_1 = require("./serviceConstant");
const M365ErrorSource = "M365";
const M365ErrorComponent = "PackageService";
// Call m365 service for package CRUD
class PackageService {
    constructor(endpoint, logger) {
        this.axiosInstance = wrappedAxiosClient_1.WrappedAxiosClient.create({
            timeout: 30000,
        });
        this.initEndpoint = endpoint;
        this.logger = logger;
    }
    static GetSharedInstance() {
        var _a;
        if (!PackageService.sharedInstance) {
            PackageService.sharedInstance = new PackageService((_a = process.env.SIDELOADING_SERVICE_ENDPOINT) !== null && _a !== void 0 ? _a : serviceConstant_1.MosServiceEndpoint, globalVars_1.TOOLS.logProvider);
        }
        return PackageService.sharedInstance;
    }
    async getTitleServiceUrl(token) {
        var _a, _b;
        try {
            try {
                new URL(this.initEndpoint);
            }
            catch (_) {
                throw new Error("Invalid URL. Mis-configuration SIDELOADING_SERVICE_ENDPOINT.");
            }
            const envInfo = await this.axiosInstance.get("/config/v1/environment", {
                baseURL: this.initEndpoint,
                headers: {
                    Authorization: `Bearer ${token}`,
                },
            });
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(JSON.stringify(envInfo.data));
            new URL(envInfo.data.titlesServiceUrl);
            return envInfo.data.titlesServiceUrl;
        }
        catch (error) {
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.error(`Get ServiceUrl failed. ${error.message}`);
            throw error;
        }
    }
    async sideLoadXmlManifest(token, manifestPath) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        try {
            const data = await fs_extra_1.default.readFile(manifestPath);
            const content = new form_data_1.default();
            content.append("package", data);
            content.append("culture", "en-us");
            const serviceUrl = await this.getTitleServiceUrl(token);
            const uploadResponse = await this.axiosInstance.post("/dev/v1/users/packages/addins", content.getBuffer(), {
                baseURL: serviceUrl,
                headers: {
                    Authorization: `Bearer ${token}`,
                    "Content-Type": "application/xml",
                },
            });
            if (uploadResponse.status === 200) {
                const titleId = uploadResponse.data.titleId;
                const appId = uploadResponse.data.appId;
                (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(`TitleId: ${titleId}`);
                (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(`AppId: ${appId}`);
                (_c = this.logger) === null || _c === void 0 ? void 0 : _c.verbose("Sideloading done.");
                return [titleId, appId];
            }
            else if (uploadResponse.status === 202) {
                const statusId = uploadResponse.data.statusId;
                (_d = this.logger) === null || _d === void 0 ? void 0 : _d.debug(`Acquiring package with statusId: ${statusId} ...`);
                do {
                    const statusResponse = await this.axiosInstance.get(`/dev/v1/users/packages/status/${statusId}`, {
                        baseURL: serviceUrl,
                        headers: { Authorization: `Bearer ${token}` },
                    });
                    const resCode = statusResponse.status;
                    (_e = this.logger) === null || _e === void 0 ? void 0 : _e.debug(`Package status: ${resCode} ...`);
                    if (resCode === 200) {
                        const titleId = statusResponse.data.titleId;
                        const appId = statusResponse.data.appId;
                        (_f = this.logger) === null || _f === void 0 ? void 0 : _f.info(`TitleId: ${titleId}`);
                        (_g = this.logger) === null || _g === void 0 ? void 0 : _g.info(`AppId: ${appId}`);
                        (_h = this.logger) === null || _h === void 0 ? void 0 : _h.verbose("Sideloading done.");
                        return [titleId, appId];
                    }
                    else {
                        await (0, utils_1.waitSeconds)(2);
                    }
                } while (true);
            }
            else {
                throw new Error(`Unknown response code: ${uploadResponse.status}}`);
            }
        }
        catch (error) {
            // this.logger?.error("Sideloading failed.");
            if (error.response) {
                // this.logger?.error(JSON.stringify(error.response.data));
                error = this.traceError(error);
            }
            else {
                // this.logger?.error(error.message);
            }
            throw (0, common_1.assembleError)(error, M365ErrorSource);
        }
    }
    async sideLoading(token, manifestPath) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        try {
            this.checkZip(manifestPath);
            const data = await fs_extra_1.default.readFile(manifestPath);
            const content = new form_data_1.default();
            content.append("package", data);
            const serviceUrl = await this.getTitleServiceUrl(token);
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.verbose("Uploading package ...");
            const uploadHeaders = content.getHeaders();
            uploadHeaders["Authorization"] = `Bearer ${token}`;
            const uploadResponse = await this.axiosInstance.post("/dev/v1/users/packages", content.getBuffer(), {
                baseURL: serviceUrl,
                headers: uploadHeaders,
            });
            const operationId = uploadResponse.data.operationId;
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(`Package uploaded. OperationId: ${operationId}`);
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.verbose("Acquiring package ...");
            const acquireResponse = await this.axiosInstance.post("/dev/v1/users/packages/acquisitions", {
                operationId: operationId,
            }, {
                baseURL: serviceUrl,
                headers: {
                    Authorization: `Bearer ${token}`,
                },
            });
            const statusId = acquireResponse.data.statusId;
            (_d = this.logger) === null || _d === void 0 ? void 0 : _d.debug(`Acquiring package with statusId: ${statusId} ...`);
            do {
                const statusResponse = await this.axiosInstance.get(`/dev/v1/users/packages/status/${statusId}`, {
                    baseURL: serviceUrl,
                    headers: { Authorization: `Bearer ${token}` },
                });
                const resCode = statusResponse.status;
                (_e = this.logger) === null || _e === void 0 ? void 0 : _e.debug(`Package status: ${resCode} ...`);
                if (resCode === 200) {
                    const titleId = statusResponse.data.titleId;
                    const appId = statusResponse.data.appId;
                    (_f = this.logger) === null || _f === void 0 ? void 0 : _f.info(`TitleId: ${titleId}`);
                    (_g = this.logger) === null || _g === void 0 ? void 0 : _g.info(`AppId: ${appId}`);
                    (_h = this.logger) === null || _h === void 0 ? void 0 : _h.verbose("Sideloading done.");
                    return [titleId, appId];
                }
                else {
                    await (0, utils_1.waitSeconds)(2);
                }
            } while (true);
        }
        catch (error) {
            // this.logger?.error("Sideloading failed.");
            if (error.response) {
                // this.logger?.error(JSON.stringify(error.response.data));
                error = this.traceError(error);
            }
            else {
                // this.logger?.error(error.message);
            }
            throw (0, common_1.assembleError)(error, M365ErrorSource);
        }
    }
    async getLaunchInfoByManifestId(token, manifestId) {
        var _a, _b, _c;
        try {
            const serviceUrl = await this.getTitleServiceUrl(token);
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.verbose(`Getting LaunchInfo with ManifestId ${manifestId} ...`);
            const launchInfo = await this.axiosInstance.post("/catalog/v1/users/titles/launchInfo", {
                Id: manifestId,
                IdType: "ManifestId",
                Filter: {
                    SupportedElementTypes: [
                        // "Extensions", // Extensions require ClientDetails to be determined later
                        "OfficeAddIns",
                        "ExchangeAddIns",
                        "FirstPartyPages",
                        "Dynamics",
                        "AAD",
                        "LineOfBusiness",
                        "StaticTabs",
                        "ComposeExtensions",
                        "Bots",
                        "GraphConnector",
                        "ConfigurableTabs",
                        "Activities",
                        "MeetingExtensionDefinition",
                        "OpenAIPlugins",
                        "Gpts",
                        "DeclarativeCopilots",
                        "Plugins",
                    ],
                },
            }, {
                baseURL: serviceUrl,
                headers: {
                    Authorization: `Bearer ${token}`,
                },
            });
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(JSON.stringify(launchInfo.data));
            return launchInfo.data;
        }
        catch (error) {
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.error("Get LaunchInfo failed.");
            if (error.response) {
                if (error.response.status === 404) {
                    throw new errors_1.NotExtendedToM365Error(M365ErrorSource);
                }
                error = this.traceError(error);
            }
            throw (0, common_1.assembleError)(error, M365ErrorSource);
        }
    }
    async retrieveTitleId(token, manifestId) {
        var _a, _b, _c, _d, _e;
        const launchInfo = await this.getLaunchInfoByManifestId(token, manifestId);
        const titleId = (_c = (_b = (_a = launchInfo.acquisition) === null || _a === void 0 ? void 0 : _a.titleId) === null || _b === void 0 ? void 0 : _b.id) !== null && _c !== void 0 ? _c : (_d = launchInfo.acquisition) === null || _d === void 0 ? void 0 : _d.titleId;
        (_e = this.logger) === null || _e === void 0 ? void 0 : _e.debug(`TitleId: ${titleId}`);
        return titleId;
    }
    async retrieveAppId(token, manifestId) {
        var _a, _b;
        const launchInfo = await this.getLaunchInfoByManifestId(token, manifestId);
        const appId = (_a = launchInfo.acquisition) === null || _a === void 0 ? void 0 : _a.appId;
        (_b = this.logger) === null || _b === void 0 ? void 0 : _b.debug(`AppId: ${appId}`);
        return appId;
    }
    async unacquire(token, titleId) {
        var _a, _b;
        try {
            const serviceUrl = await this.getTitleServiceUrl(token);
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.verbose(`Unacquiring package with TitleId ${titleId} ...`);
            await this.axiosInstance.delete(`/catalog/v1/users/acquisitions/${titleId}`, {
                baseURL: serviceUrl,
                headers: {
                    Authorization: `Bearer ${token}`,
                },
            });
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.verbose("Unacquiring done.");
        }
        catch (error) {
            if (error.response) {
                error = this.traceError(error);
            }
            throw (0, common_1.assembleError)(error, M365ErrorSource);
        }
    }
    async getLaunchInfoByTitleId(token, titleId) {
        var _a, _b;
        try {
            const serviceUrl = await this.getTitleServiceUrl(token);
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.verbose(`Getting LaunchInfo with TitleId ${titleId} ...`);
            const launchInfo = await this.axiosInstance.get(`/catalog/v1/users/titles/${titleId}/launchInfo`, {
                baseURL: serviceUrl,
                params: {
                    SupportedElementTypes: 
                    // eslint-disable-next-line no-secrets/no-secrets
                    "Extensions,OfficeAddIns,ExchangeAddIns,FirstPartyPages,Dynamics,AAD,LineOfBusiness,StaticTabs,ComposeExtensions,Bots,GraphConnector,ConfigurableTabs,Activities,MeetingExtensionDefinition,OpenAIPlugins,Gpts,DeclarativeCopilots,Plugins",
                },
                headers: {
                    Authorization: `Bearer ${token}`,
                },
            });
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(JSON.stringify(launchInfo.data));
            return launchInfo.data;
        }
        catch (error) {
            if (error.response) {
                error = this.traceError(error);
            }
            throw (0, common_1.assembleError)(error, M365ErrorSource);
        }
    }
    async getActiveExperiences(token, ensureUpToDate = false) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        try {
            const serviceUrl = await this.getTitleServiceUrl(token);
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(`Get active experiences from service URL ${serviceUrl} ...`);
            // users/experiences is deprecating, using users/uitypes instead
            let response = await this.axiosInstance.get("/catalog/v1/users/uitypes", {
                baseURL: serviceUrl,
                headers: {
                    Authorization: `Bearer ${token}`,
                },
            });
            let status = response.status;
            let activeExperiences = (_b = response.data) === null || _b === void 0 ? void 0 : _b.activeExperiences;
            const nextInterval = (_d = (_c = response.data) === null || _c === void 0 ? void 0 : _c.nextInterval) !== null && _d !== void 0 ? _d : -1;
            (_e = this.logger) === null || _e === void 0 ? void 0 : _e.debug(`(${status}) Active experiences: ${JSON.stringify(activeExperiences)}`);
            // Short nextInterval means cache is refreshing
            if (ensureUpToDate && nextInterval > 0 && nextInterval < 10) {
                (_f = this.logger) === null || _f === void 0 ? void 0 : _f.debug(`Active experiences is refreshing, wait for ${nextInterval} seconds.`);
                await (0, utils_1.waitSeconds)(nextInterval);
                response = await this.axiosInstance.get("/catalog/v1/users/uitypes", {
                    baseURL: serviceUrl,
                    headers: {
                        Authorization: `Bearer ${token}`,
                    },
                });
                status = response.status;
                activeExperiences = (_g = response.data) === null || _g === void 0 ? void 0 : _g.activeExperiences;
                (_h = this.logger) === null || _h === void 0 ? void 0 : _h.debug(`(${status}) Active experiences: ${JSON.stringify(activeExperiences)}`);
            }
            return activeExperiences;
        }
        catch (error) {
            if (error.response) {
                error = this.traceError(error);
            }
            throw (0, common_1.assembleError)(error, M365ErrorSource);
        }
    }
    async getCopilotStatus(token, ensureUpToDate = false) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        try {
            const activeExperiences = await this.getActiveExperiences(token, ensureUpToDate);
            const copilotAllowed = activeExperiences == undefined ? undefined : activeExperiences.includes("CopilotTeams");
            (0, telemetry_1.sendTelemetryEvent)(telemetry_1.Component.core, telemetry_1.TelemetryEvent.CheckCopilot, {
                [telemetry_1.TelemetryProperty.IsCopilotAllowed]: (_a = copilotAllowed === null || copilotAllowed === void 0 ? void 0 : copilotAllowed.toString()) !== null && _a !== void 0 ? _a : "undefined",
            });
            return copilotAllowed;
        }
        catch (error) {
            (0, telemetry_1.sendTelemetryErrorEvent)(telemetry_1.Component.core, telemetry_1.TelemetryEvent.CheckCopilot, new teamsfx_api_1.SystemError({
                error,
                source: M365ErrorSource,
                message: (_b = error.message) !== null && _b !== void 0 ? _b : "Failed to get copilot status.",
                categories: [types_1.ErrorCategory.External],
            }), {
                [telemetry_1.TelemetryProperty.CheckCopilotTracingId]: `${
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                (_j = (_e = (_d = (_c = error.response) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d.traceresponse) !== null && _e !== void 0 ? _e : (_h = (_g = (_f = error.innerError) === null || _f === void 0 ? void 0 : _f.response) === null || _g === void 0 ? void 0 : _g.headers) === null || _h === void 0 ? void 0 : _h.traceresponse) !== null && _j !== void 0 ? _j : ""}`,
            });
            return undefined;
        }
    }
    traceError(error) {
        var _a, _b, _c, _d;
        // add error details and trace to message
        const tracingId = ((_b = (_a = error.response.headers) === null || _a === void 0 ? void 0 : _a.traceresponse) !== null && _b !== void 0 ? _b : "");
        const originalMessage = error.message;
        const innerError = ((_c = error.response.data) === null || _c === void 0 ? void 0 : _c.error) || { code: "", message: "" };
        const finalMessage = `${originalMessage} (tracingId: ${tracingId}) ${innerError.code}: ${innerError.message} `;
        error.message = finalMessage;
        // HTTP 400 as user error due to invalid input
        if (((_d = error.response) === null || _d === void 0 ? void 0 : _d.status) === 400) {
            error = new teamsfx_api_1.UserError({
                name: "PackageServiceError",
                error,
                source: M365ErrorSource,
                message: finalMessage,
            });
        }
        return error;
    }
    checkZip(path) {
        var _a, _b;
        try {
            const zip = new adm_zip_1.default(path, {});
            zip.getEntries();
        }
        catch (error) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug(`Invalid input zip ${path}. ${error.message}`);
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.warning(`Please make sure input path is a valid app package zip. ${path}`);
        }
    }
}
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: M365ErrorSource, component: M365ErrorComponent })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], PackageService.prototype, "getTitleServiceUrl", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: M365ErrorSource, component: M365ErrorComponent })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], PackageService.prototype, "sideLoadXmlManifest", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: M365ErrorSource, component: M365ErrorComponent })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], PackageService.prototype, "sideLoading", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: M365ErrorSource, component: M365ErrorComponent })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], PackageService.prototype, "getLaunchInfoByManifestId", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: M365ErrorSource, component: M365ErrorComponent })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], PackageService.prototype, "retrieveTitleId", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: M365ErrorSource, component: M365ErrorComponent })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], PackageService.prototype, "unacquire", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: M365ErrorSource, component: M365ErrorComponent })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], PackageService.prototype, "getLaunchInfoByTitleId", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: M365ErrorSource, component: M365ErrorComponent })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], PackageService.prototype, "getActiveExperiences", null);
exports.PackageService = PackageService;
//# sourceMappingURL=packageService.js.map
"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.LaunchHelper = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const hooks_1 = require("@feathersjs/hooks");
const constants_1 = require("../../common/constants");
const globalVars_1 = require("../../common/globalVars");
const error_1 = require("../../error");
const common_1 = require("../../error/common");
const constants_2 = require("../../question/constants");
const errors_1 = require("./errors");
const packageService_1 = require("./packageService");
const serviceConstant_1 = require("./serviceConstant");
const constants_3 = require("./constants");
class LaunchHelper {
    constructor(m365TokenProvider, logger) {
        this.m365TokenProvider = m365TokenProvider;
        this.logger = logger;
    }
    async getLaunchUrl(hub, teamsAppId, properties, withLoginHint = true) {
        var _a;
        const capabilities = properties.capabilities;
        const loginHint = withLoginHint
            ? (_a = (await this.getUpnFromToken())) !== null && _a !== void 0 ? _a : "login_your_m365_account" // a workaround that user has the chance to login
            : undefined;
        let url;
        const copilotCapabilities = ["plugin", "copilotGpt"];
        const hasCopilotExtensionOnly = capabilities.length > 0 &&
            capabilities.filter((capability) => !copilotCapabilities.includes(capability))
                .length === 0;
        switch (hub) {
            case constants_2.HubTypes.teams: {
                let installAppPackage = true;
                if (capabilities.length > 0 &&
                    (hasCopilotExtensionOnly ||
                        (!capabilities.includes("staticTab") &&
                            !capabilities.includes("Bot") &&
                            !capabilities.includes("configurableTab") &&
                            properties.isApiMeAAD))) {
                    installAppPackage = false;
                }
                const baseUrl = installAppPackage
                    ? `https://teams.microsoft.com/l/app/${teamsAppId}?installAppPackage=true&webjoin=true`
                    : "https://teams.microsoft.com";
                url = new URL(baseUrl);
                const tid = await this.getTidFromToken();
                if (tid) {
                    url.searchParams.append("appTenantId", tid);
                }
                break;
            }
            case constants_2.HubTypes.outlook: {
                const result = await this.getM365AppId(teamsAppId);
                if (result.isErr()) {
                    return (0, teamsfx_api_1.err)(result.error);
                }
                const baseUrl = hasCopilotExtensionOnly
                    ? `${constants_3.outlookBaseUrl}/host/${constants_3.outlookCopilotAppId}`
                    : capabilities.includes("staticTab")
                        ? `${constants_3.outlookBaseUrl}/host/${result.value}`
                        : `${constants_3.outlookBaseUrl}/mail`;
                url = new URL(baseUrl);
                break;
            }
            case constants_2.HubTypes.office:
                {
                    const result = await this.getM365AppId(teamsAppId);
                    if (result.isErr()) {
                        return (0, teamsfx_api_1.err)(result.error);
                    }
                    const baseUrl = hasCopilotExtensionOnly
                        ? `${constants_3.officeBaseUrl}/chat?auth=2`
                        : `${constants_3.officeBaseUrl}/m365apps/${result.value}?auth=2`;
                    url = new URL(baseUrl);
                }
                break;
        }
        if (loginHint) {
            url.searchParams.append("login_hint", loginHint);
        }
        return (0, teamsfx_api_1.ok)(url.toString());
    }
    async getM365AppId(teamsAppId) {
        var _a, _b;
        const sideloadingServiceEndpoint = (_a = process.env.SIDELOADING_SERVICE_ENDPOINT) !== null && _a !== void 0 ? _a : serviceConstant_1.MosServiceEndpoint;
        const sideloadingServiceScope = (_b = process.env.SIDELOADING_SERVICE_SCOPE) !== null && _b !== void 0 ? _b : serviceConstant_1.MosServiceScope;
        const packageService = new packageService_1.PackageService(sideloadingServiceEndpoint, this.logger);
        const sideloadingTokenRes = await this.m365TokenProvider.getAccessToken({
            scopes: [sideloadingServiceScope],
        });
        if (sideloadingTokenRes.isErr()) {
            return (0, teamsfx_api_1.err)(sideloadingTokenRes.error);
        }
        const sideloadingToken = sideloadingTokenRes.value;
        try {
            const m365AppId = await packageService.retrieveAppId(sideloadingToken, teamsAppId);
            if (!m365AppId) {
                return (0, teamsfx_api_1.err)(new errors_1.NotExtendedToM365Error(error_1.CoreSource));
            }
            return (0, teamsfx_api_1.ok)(m365AppId);
        }
        catch (error) {
            return (0, teamsfx_api_1.err)((0, common_1.assembleError)(error));
        }
    }
    async getTidFromToken() {
        try {
            const statusRes = await this.m365TokenProvider.getStatus({ scopes: constants_1.AppStudioScopes });
            const tokenObject = statusRes.isOk() ? statusRes.value.accountInfo : undefined;
            return tokenObject === null || tokenObject === void 0 ? void 0 : tokenObject.tid;
        }
        catch (_a) {
            return undefined;
        }
    }
    async getUpnFromToken() {
        try {
            const statusRes = await this.m365TokenProvider.getStatus({ scopes: constants_1.AppStudioScopes });
            const tokenObject = statusRes.isOk() ? statusRes.value.accountInfo : undefined;
            return tokenObject === null || tokenObject === void 0 ? void 0 : tokenObject.upn;
        }
        catch (_a) {
            return undefined;
        }
    }
}
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "LaunchHelper" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], LaunchHelper.prototype, "getLaunchUrl", null);
exports.LaunchHelper = LaunchHelper;
//# sourceMappingURL=launchHelper.js.map
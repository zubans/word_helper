"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendRequestWithTimeout = exports.sendRequestWithRetry = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
async function sendRequestWithRetry(requestFn, tryLimits) {
    var _a;
    // !status means network error, see https://github.com/axios/axios/issues/383
    const canTry = (status) => !status || (status >= 500 && status < 600);
    let status;
    let error;
    for (let i = 0; i < tryLimits && canTry(status); i++) {
        try {
            const res = await requestFn();
            if (res.status === 200 || res.status === 201) {
                return res;
            }
            else {
                error = new Error(`HTTP Request failed: ${JSON.stringify(res)}`);
            }
            status = res.status;
        }
        catch (e) {
            error = e;
            status = (_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status;
        }
    }
    error !== null && error !== void 0 ? error : (error = new Error(`RequestWithRetry got bad tryLimits: ${tryLimits}`));
    throw error;
}
exports.sendRequestWithRetry = sendRequestWithRetry;
async function sendRequestWithTimeout(requestFn, timeoutInMs, tryLimits = 1) {
    const source = axios_1.default.CancelToken.source();
    const timeout = setTimeout(() => {
        source.cancel();
    }, timeoutInMs);
    try {
        const res = await sendRequestWithRetry(() => requestFn(source.token), tryLimits);
        clearTimeout(timeout);
        return res;
    }
    catch (err) {
        if (axios_1.default.isCancel(err)) {
            throw new Error("Request timeout");
        }
        throw err;
    }
}
exports.sendRequestWithTimeout = sendRequestWithTimeout;
//# sourceMappingURL=requestUtils.js.map
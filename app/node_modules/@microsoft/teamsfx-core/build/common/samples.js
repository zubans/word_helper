"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.sampleProvider = exports.SampleConfigBranchForPrerelease = exports.SampleConfigTag = void 0;
const tslib_1 = require("tslib");
const axios_1 = tslib_1.__importDefault(require("axios"));
const hooks_1 = require("@feathersjs/hooks");
const globalVars_1 = require("./globalVars");
const common_1 = require("../error/common");
const featureFlags_1 = require("./featureFlags");
const requestUtils_1 = require("./requestUtils");
const packageJson = require("../../package.json");
const SampleConfigOwner = "OfficeDev";
const SampleConfigRepo = "TeamsFx-Samples";
const SampleConfigFile = ".config/samples-config-v3.json";
exports.SampleConfigTag = "v2.5.0";
// prerelease tag is always using a branch.
exports.SampleConfigBranchForPrerelease = "main";
class SampleProvider {
    get SampleCollection() {
        if (!this.sampleCollection) {
            return this.refreshSampleConfig();
        }
        return Promise.resolve(this.sampleCollection);
    }
    async refreshSampleConfig() {
        const { samplesConfig, ref } = await this.fetchOnlineSampleConfig();
        this.sampleCollection = this.parseOnlineSampleConfig(samplesConfig, ref);
        return this.sampleCollection;
    }
    async fetchOnlineSampleConfig() {
        const version = packageJson.version;
        const configBranchInEnv = process.env[featureFlags_1.FeatureFlagName.SampleConfigBranch];
        let samplesConfig;
        let ref = exports.SampleConfigTag;
        // Set default value for branchOrTag
        if (version.includes("alpha")) {
            // daily build version always use 'dev' branch
            ref = "dev";
        }
        else if (version.includes("beta")) {
            // prerelease build version always use branch head for prerelease.
            ref = exports.SampleConfigBranchForPrerelease;
        }
        else if (version.includes("rc")) {
            // if there is a breaking change, the tag is not used by any stable version.
            ref = exports.SampleConfigTag;
        }
        else {
            // stable version uses the head of branch defined by feature flag when available
            ref = exports.SampleConfigTag;
        }
        // Set branchOrTag value if branch in env is valid
        if (configBranchInEnv) {
            try {
                const data = await this.fetchRawFileContent(configBranchInEnv);
                ref = configBranchInEnv;
                samplesConfig = data;
            }
            catch (e) { }
        }
        if (samplesConfig === undefined) {
            samplesConfig = (await this.fetchRawFileContent(ref));
        }
        return { samplesConfig, ref };
    }
    parseOnlineSampleConfig(samplesConfig, ref) {
        const samples = (samplesConfig === null || samplesConfig === void 0 ? void 0 : samplesConfig.samples.map((sample) => {
            const isExternal = sample["downloadUrlInfo"] ? true : false;
            let gifUrl = sample["gifPath"] !== undefined
                ? `https://raw.githubusercontent.com/${SampleConfigOwner}/${SampleConfigRepo}/${ref}/${sample["id"]}/${sample["gifPath"]}`
                : undefined;
            if (isExternal) {
                const info = sample["downloadUrlInfo"];
                gifUrl =
                    sample["gifPath"] !== undefined
                        ? `https://raw.githubusercontent.com/${info.owner}/${info.repository}/${info.ref}/${info.dir}/${sample["gifPath"]}`
                        : undefined;
            }
            return Object.assign(Object.assign({}, sample), { onboardDate: new Date(sample["onboardDate"]), downloadUrlInfo: isExternal
                    ? sample["downloadUrlInfo"]
                    : {
                        owner: SampleConfigOwner,
                        repository: SampleConfigRepo,
                        ref: ref,
                        dir: sample["id"],
                    }, gifUrl: gifUrl });
        })) || [];
        return {
            samples,
            filterOptions: {
                capabilities: (samplesConfig === null || samplesConfig === void 0 ? void 0 : samplesConfig.filterOptions["capabilities"]) || [],
                languages: (samplesConfig === null || samplesConfig === void 0 ? void 0 : samplesConfig.filterOptions["languages"]) || [],
                technologies: (samplesConfig === null || samplesConfig === void 0 ? void 0 : samplesConfig.filterOptions["technologies"]) || [],
            },
        };
    }
    async getSampleReadmeHtml(sample) {
        const urlInfo = sample.downloadUrlInfo;
        const url = `https://api.github.com/repos/${urlInfo.owner}/${urlInfo.repository}/readme/${urlInfo.dir}/?ref=${urlInfo.ref}`;
        try {
            const readmeResponse = await (0, requestUtils_1.sendRequestWithTimeout)(async () => {
                return await axios_1.default.get(url, {
                    headers: {
                        Accept: "application/vnd.github.html",
                        "X-GitHub-Api-Version": "2022-11-28",
                    },
                });
            }, 1000, 3);
            if (readmeResponse && readmeResponse.data) {
                return readmeResponse.data;
            }
            else {
                return "";
            }
        }
        catch (e) {
            throw new common_1.AccessGithubError(url, "SampleProvider", e);
        }
    }
    async fetchRawFileContent(branchOrTag) {
        const url = `https://raw.githubusercontent.com/${SampleConfigOwner}/${SampleConfigRepo}/${branchOrTag}/${SampleConfigFile}`;
        try {
            const fileResponse = await (0, requestUtils_1.sendRequestWithTimeout)(async () => {
                return await axios_1.default.get(url, { responseType: "json" });
            }, 1000, 3);
            if (fileResponse && fileResponse.data) {
                return fileResponse.data;
            }
        }
        catch (e) {
            throw new common_1.AccessGithubError(url, "SampleProvider", e);
        }
    }
}
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ component: "SampleProvider" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [Object, String]),
    tslib_1.__metadata("design:returntype", Object)
], SampleProvider.prototype, "parseOnlineSampleConfig", null);
exports.sampleProvider = new SampleProvider();
//# sourceMappingURL=samples.js.map
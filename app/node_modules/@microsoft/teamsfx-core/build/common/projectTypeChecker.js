"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.projectTypeChecker = exports.getCapabilities = exports.TeamsfxVersionState = exports.SPFxKey = exports.TeamsJsModule = exports.TeamsfxConfigType = void 0;
const tslib_1 = require("tslib");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path_1 = tslib_1.__importDefault(require("path"));
const semver_1 = tslib_1.__importDefault(require("semver"));
const yaml_1 = require("yaml");
const versionMetadata_1 = require("./versionMetadata");
const projectSettingsHelper_1 = require("./projectSettingsHelper");
var TeamsfxConfigType;
(function (TeamsfxConfigType) {
    TeamsfxConfigType["projectSettingsJson"] = "projectSettings.json";
    TeamsfxConfigType["teamsappYml"] = "teamsapp.yml";
})(TeamsfxConfigType = exports.TeamsfxConfigType || (exports.TeamsfxConfigType = {}));
exports.TeamsJsModule = "@microsoft/teams-js";
exports.SPFxKey = "@microsoft/generator-sharepoint";
var TeamsfxVersionState;
(function (TeamsfxVersionState) {
    TeamsfxVersionState["Compatible"] = "compatible";
    TeamsfxVersionState["Upgradable"] = "upgradable";
    TeamsfxVersionState["Unsupported"] = "unsupported";
    TeamsfxVersionState["Invalid"] = "invalid";
})(TeamsfxVersionState = exports.TeamsfxVersionState || (exports.TeamsfxVersionState = {}));
class ProjectTypeChecker {
    async scanFolder(currentPath, ignoreFolderName, data, fileCallback, maxDepth, currentDepth = 0) {
        const fileName = path_1.default.parse(currentPath).base;
        if (ignoreFolderName.includes(fileName)) {
            return true;
        }
        const res = await fileCallback(currentPath, data);
        if (!res) {
            return false;
        }
        const stat = await fs_extra_1.default.stat(currentPath);
        if (stat.isDirectory()) {
            if (currentDepth < maxDepth) {
                const subFiles = await fs_extra_1.default.readdir(currentPath);
                for (const subFile of subFiles) {
                    const subFilePath = path_1.default.join(currentPath, subFile);
                    const res = await this.scanFolder(subFilePath, ignoreFolderName, data, fileCallback, maxDepth, currentDepth + 1);
                    if (!res) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    async findManifestCallback(filePath, data) {
        const fileName = path_1.default.parse(filePath).base;
        if (fileName.toLowerCase().includes("manifest") && fileName.toLowerCase().endsWith(".json")) {
            try {
                const manifestContent = await fs_extra_1.default.readFile(filePath, "utf-8");
                const manifestObject = JSON.parse(manifestContent);
                const schemaLink = manifestObject["$schema"];
                if (schemaLink && schemaLink.endsWith("/MicrosoftTeams.schema.json")) {
                    data.hasTeamsManifest = true;
                    data.manifestCapabilities = getCapabilities(manifestObject);
                    data.manifestAppId = manifestObject.id;
                    data.manifestVersion = manifestObject.manifestVersion;
                    return false;
                }
            }
            catch (error) { }
        }
        return true;
    }
    async findProjectLanguateCallback(filePath, data) {
        var _a;
        const parsed = path_1.default.parse(filePath);
        const fileName = parsed.base;
        if (fileName === "tsconfig.json") {
            data.lauguages.push("ts");
            return false;
        }
        else if (fileName === "package.json") {
            try {
                const content = await fs_extra_1.default.readFile(filePath, "utf-8");
                const json = JSON.parse(content);
                if ((_a = json === null || json === void 0 ? void 0 : json.dependencies) === null || _a === void 0 ? void 0 : _a[exports.TeamsJsModule]) {
                    data.dependsOnTeamsJs = true;
                }
                const tsconfigExist = await fs_extra_1.default.pathExists(path_1.default.join(parsed.dir, "tsconfig.json"));
                if (!tsconfigExist)
                    data.lauguages.push("js");
                else
                    data.lauguages.push("ts");
                return false;
            }
            catch (error) { }
        }
        else if (fileName.toLowerCase().endsWith(".csproj")) {
            data.lauguages.push("csharp");
            return false;
        }
        else if (fileName === "pom.xml" || fileName === "build.gradle") {
            data.lauguages.push("java");
            return false;
        }
        else if (fileName.toLowerCase() === "makefile") {
            data.lauguages.push("c");
            return false;
        }
        else if (fileName === "requirements.txt" || fileName === "pyproject.toml") {
            data.lauguages.push("python");
            return false;
        }
        return true;
    }
    async findTeamsFxCallback(filePath, data) {
        const parsed = path_1.default.parse(filePath);
        const fileName = parsed.base;
        if (fileName === ".fx") {
            const settingFile = path_1.default.join(filePath, "configs", "projectSettings.json");
            const exists = await fs_extra_1.default.pathExists(settingFile);
            if (exists) {
                data.isTeamsFx = true;
                data.teamsfxConfigType = TeamsfxConfigType.projectSettingsJson;
                const json = await fs_extra_1.default.readJson(settingFile);
                data.teamsfxConfigVersion = json.version;
                data.teamsfxProjectId = json.projectId;
                const solutionSettings = json.solutionSettings;
                if (!solutionSettings ||
                    !(solutionSettings === null || solutionSettings === void 0 ? void 0 : solutionSettings.activeResourcePlugins) ||
                    !data.teamsfxConfigVersion) {
                    data.teamsfxVersionState = TeamsfxVersionState.Invalid;
                }
                else if (data.teamsfxConfigVersion) {
                    if (semver_1.default.gte(data.teamsfxConfigVersion, versionMetadata_1.MetadataV2.projectVersion) &&
                        semver_1.default.lte(data.teamsfxConfigVersion, versionMetadata_1.MetadataV2.projectMaxVersion)) {
                        data.teamsfxVersionState = TeamsfxVersionState.Upgradable;
                    }
                    else {
                        data.teamsfxVersionState = TeamsfxVersionState.Unsupported;
                    }
                }
                return false;
            }
        }
        else if (fileName === versionMetadata_1.MetadataV3.configFile || fileName === versionMetadata_1.MetadataV3.localConfigFile) {
            data.isTeamsFx = true;
            data.teamsfxConfigType = TeamsfxConfigType.teamsappYml;
            if (fileName === versionMetadata_1.MetadataV3.configFile) {
                const yamlFileContent = await fs_extra_1.default.readFile(filePath, "utf8");
                const appYaml = (0, yaml_1.parseDocument)(yamlFileContent);
                data.teamsfxConfigVersion = appYaml.get("version");
                data.teamsfxProjectId = appYaml.get("projectId");
                if (!semver_1.default.valid(data.teamsfxConfigVersion) ||
                    semver_1.default.lt(data.teamsfxConfigVersion, versionMetadata_1.MetadataV3.unSupprotVersion)) {
                    data.teamsfxVersionState = TeamsfxVersionState.Compatible;
                }
                else {
                    data.teamsfxVersionState = TeamsfxVersionState.Unsupported;
                }
            }
            else {
                return true;
            }
            return false;
        }
        return true;
    }
    async findSPFxCallback(filePath, data) {
        const parsed = path_1.default.parse(filePath);
        const fileName = parsed.base;
        if (fileName === ".yo-rc.json") {
            const content = await fs_extra_1.default.readJson(filePath);
            if (content[exports.SPFxKey]) {
                data.isSPFx = true;
                return false;
            }
        }
        return true;
    }
    findOfficeAddinProject(filePath, data) {
        if ((0, projectSettingsHelper_1.isValidOfficeAddInProject)(filePath)) {
            data.officeAddinProjectType = "XML";
            data.isTeamsFx = false;
            return false;
        }
        return true;
    }
    async checkProjectType(projectPath) {
        const result = {
            isTeamsFx: false,
            hasTeamsManifest: false,
            dependsOnTeamsJs: false,
            lauguages: [],
        };
        try {
            await this.scanFolder(projectPath, ["node_modules", "bin", "build", "dist", ".vscode"], result, this.findManifestCallback, 2, 0);
            await this.scanFolder(projectPath, ["node_modules", "bin", "build", "dist", ".vscode"], result, this.findProjectLanguateCallback, 2, 0);
            //only scan direct sub folder
            await this.scanFolder(projectPath, ["node_modules", "bin", "build", "dist", ".vscode"], result, this.findTeamsFxCallback, 1, 0);
            await this.scanFolder(projectPath, ["node_modules", "bin", "build", "dist", ".vscode"], result, this.findSPFxCallback, 2, 0);
            this.findOfficeAddinProject(projectPath, result);
        }
        catch (e) { }
        return result;
    }
}
function getCapabilities(manifest) {
    var _a, _b, _c, _d;
    const capabilities = [];
    if (manifest.staticTabs && manifest.staticTabs.length > 0) {
        capabilities.push("staticTab");
    }
    if (manifest.configurableTabs && manifest.configurableTabs.length > 0) {
        capabilities.push("configurableTab");
    }
    if (manifest.bots && manifest.bots.length > 0) {
        capabilities.push("bot");
    }
    if (manifest.composeExtensions && manifest.composeExtensions.length > 0) {
        capabilities.push("composeExtension");
    }
    if (manifest.extensions && manifest.extensions.length > 0) {
        capabilities.push("extension");
    }
    if (((_a = manifest.copilotExtensions) === null || _a === void 0 ? void 0 : _a.plugins) && manifest.copilotExtensions.plugins.length > 0) {
        capabilities.push("plugin");
    }
    if (((_b = manifest.copilotExtensions) === null || _b === void 0 ? void 0 : _b.declarativeCopilots) &&
        manifest.copilotExtensions.declarativeCopilots.length > 0) {
        capabilities.push("copilotGpt");
    }
    if (((_c = manifest.copilotAgents) === null || _c === void 0 ? void 0 : _c.plugins) &&
        manifest.copilotAgents.plugins.length > 0 &&
        !capabilities.includes("plugin")) {
        capabilities.push("plugin");
    }
    if (((_d = manifest.copilotAgents) === null || _d === void 0 ? void 0 : _d.declarativeAgents) &&
        manifest.copilotAgents.declarativeAgents.length > 0 &&
        !capabilities.includes("copilotGpt")) {
        capabilities.push("copilotGpt");
    }
    return capabilities;
}
exports.getCapabilities = getCapabilities;
exports.projectTypeChecker = new ProjectTypeChecker();
//# sourceMappingURL=projectTypeChecker.js.map
"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncManifestQuestionNode = exports.uninstallQuestionNode = exports.oauthQuestion = exports.apiSpecApiKeyQuestion = exports.apiSpecApiKeyConfirmQestion = exports.addPluginQuestionNode = exports.createNewEnvQuestionNode = exports.selectSourceEnvQuestion = exports.newTargetEnvQuestion = exports.newEnvNameValidation = exports.envQuestionCondition = exports.selectAadManifestQuestion = exports.isAadMainifestContainsPlaceholder = exports.inputUserEmailQuestion = exports.selectTargetEnvQuestion = exports.previewWithTeamsAppManifestQuestionNode = exports.selectTeamsAppPackageQuestionNode = exports.copilotPluginAddAPIQuestionNode = exports.selectLocalTeamsAppManifestQuestion = exports.selectTeamsAppManifestQuestion = exports.addWebPartQuestionNode = exports.selectAadAppManifestQuestionNode = exports.selectTeamsAppManifestQuestionNode = exports.validateTeamsAppQuestionNode = exports.deployAadManifestQuestionNode = exports.grantPermissionQuestionNode = exports.listCollaboratorQuestionNode = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("../common/constants");
const featureFlags_1 = require("../common/featureFlags");
const localizeUtils_1 = require("../common/localizeUtils");
const constants_2 = require("../component/driver/add/utility/constants");
const envUtil_1 = require("../component/utils/envUtil");
const collaborator_1 = require("../core/collaborator");
const environmentName_1 = require("../core/environmentName");
const globalVars_1 = require("../common/globalVars");
const constants_3 = require("./constants");
const create_1 = require("./create");
const os = tslib_1.__importStar(require("os"));
function listCollaboratorQuestionNode() {
    const selectTeamsAppNode = selectTeamsAppManifestQuestionNode();
    selectTeamsAppNode.condition = { contains: collaborator_1.CollaborationConstants.TeamsAppQuestionId };
    selectTeamsAppNode.children.push({
        condition: envQuestionCondition,
        data: selectTargetEnvQuestion(constants_3.QuestionNames.Env, false, false, ""),
    });
    const selectAadAppNode = selectAadAppManifestQuestionNode();
    selectAadAppNode.condition = { contains: collaborator_1.CollaborationConstants.AadAppQuestionId };
    selectAadAppNode.children.push({
        condition: envQuestionCondition,
        data: selectTargetEnvQuestion(constants_3.QuestionNames.Env, false, false, ""),
    });
    return {
        data: { type: "group" },
        children: [
            {
                condition: (inputs) => teamsfx_api_1.DynamicPlatforms.includes(inputs.platform),
                data: selectAppTypeQuestion(),
                cliOptionDisabled: "self",
                inputsDisabled: "self",
                children: [selectTeamsAppNode, selectAadAppNode],
            },
        ],
    };
}
exports.listCollaboratorQuestionNode = listCollaboratorQuestionNode;
function grantPermissionQuestionNode() {
    const selectTeamsAppNode = selectTeamsAppManifestQuestionNode();
    selectTeamsAppNode.condition = { contains: collaborator_1.CollaborationConstants.TeamsAppQuestionId };
    selectTeamsAppNode.children.push({
        condition: envQuestionCondition,
        data: selectTargetEnvQuestion(constants_3.QuestionNames.Env, false, false, ""),
    });
    const selectAadAppNode = selectAadAppManifestQuestionNode();
    selectAadAppNode.condition = { contains: collaborator_1.CollaborationConstants.AadAppQuestionId };
    selectAadAppNode.children.push({
        condition: envQuestionCondition,
        data: selectTargetEnvQuestion(constants_3.QuestionNames.Env, false, false, ""),
    });
    return {
        data: { type: "group" },
        children: [
            {
                condition: (inputs) => teamsfx_api_1.DynamicPlatforms.includes(inputs.platform),
                data: selectAppTypeQuestion(),
                cliOptionDisabled: "self",
                inputsDisabled: "self",
                children: [
                    selectTeamsAppNode,
                    selectAadAppNode,
                    {
                        data: inputUserEmailQuestion(),
                    },
                ],
            },
        ],
    };
}
exports.grantPermissionQuestionNode = grantPermissionQuestionNode;
function deployAadManifestQuestionNode() {
    return {
        data: { type: "group" },
        children: [
            {
                condition: (inputs) => teamsfx_api_1.DynamicPlatforms.includes(inputs.platform),
                data: selectAadManifestQuestion(),
                children: [
                    {
                        condition: (inputs) => inputs.platform === teamsfx_api_1.Platform.VSCode && // confirm question only works for VSC
                            inputs.projectPath !== undefined &&
                            path.resolve(inputs[constants_3.QuestionNames.AadAppManifestFilePath]) !==
                                path.join(inputs.projectPath, "aad.manifest.json"),
                        data: confirmManifestQuestion(false, false),
                        cliOptionDisabled: "self",
                        inputsDisabled: "self",
                    },
                    {
                        condition: isAadMainifestContainsPlaceholder,
                        data: selectTargetEnvQuestion(constants_3.QuestionNames.Env, false, false, ""),
                    },
                ],
            },
        ],
    };
}
exports.deployAadManifestQuestionNode = deployAadManifestQuestionNode;
function validateTeamsAppQuestionNode() {
    return {
        data: selectTeamsAppValidationMethodQuestion(),
        cliOptionDisabled: "self",
        inputsDisabled: "self",
        children: [
            {
                condition: { equals: constants_3.TeamsAppValidationOptions.schema().id },
                data: selectTeamsAppManifestQuestion(),
            },
            {
                condition: { equals: constants_3.TeamsAppValidationOptions.package().id },
                data: selectTeamsAppPackageQuestion(),
            },
            {
                condition: { equals: constants_3.TeamsAppValidationOptions.testCases().id },
                data: selectTeamsAppPackageQuestion(),
            },
        ],
    };
}
exports.validateTeamsAppQuestionNode = validateTeamsAppQuestionNode;
function selectTeamsAppManifestQuestionNode() {
    return {
        data: selectTeamsAppManifestQuestion(),
        children: [
            {
                condition: (inputs) => confirmCondition(inputs, false),
                data: confirmManifestQuestion(true, false),
                cliOptionDisabled: "self",
                inputsDisabled: "self",
            },
        ],
    };
}
exports.selectTeamsAppManifestQuestionNode = selectTeamsAppManifestQuestionNode;
function selectAadAppManifestQuestionNode() {
    return {
        data: selectAadManifestQuestion(),
        children: [
            {
                condition: (inputs) => inputs.platform === teamsfx_api_1.Platform.VSCode && // confirm question only works for VSC
                    inputs.projectPath &&
                    inputs[constants_3.QuestionNames.AadAppManifestFilePath] &&
                    path.resolve(inputs[constants_3.QuestionNames.AadAppManifestFilePath]) !==
                        path.join(inputs.projectPath, "aad.manifest.json"),
                data: confirmManifestQuestion(false, false),
                cliOptionDisabled: "self",
                inputsDisabled: "self",
            },
        ],
    };
}
exports.selectAadAppManifestQuestionNode = selectAadAppManifestQuestionNode;
function confirmCondition(inputs, isLocal) {
    return (inputs.platform === teamsfx_api_1.Platform.VSCode && // confirm question only works for VSC
        inputs.projectPath &&
        inputs[isLocal ? constants_3.QuestionNames.LocalTeamsAppManifestFilePath : constants_3.QuestionNames.TeamsAppManifestFilePath] &&
        path.resolve(inputs[isLocal
            ? constants_3.QuestionNames.LocalTeamsAppManifestFilePath
            : constants_3.QuestionNames.TeamsAppManifestFilePath]) !==
            path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, isLocal ? "manifest.local.json" : "manifest.json"));
}
async function spfxFrameworkExist(inputs) {
    if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
        return false;
    }
    const yorcPath = path.join(inputs[constants_3.QuestionNames.SPFxFolder], constants_2.Constants.YO_RC_FILE);
    if (!(await fs_extra_1.default.pathExists(yorcPath))) {
        return false;
    }
    const yorcJson = (await fs_extra_1.default.readJson(yorcPath));
    if (!yorcJson["@microsoft/generator-sharepoint"]) {
        return false;
    }
    return yorcJson["@microsoft/generator-sharepoint"]["template"];
}
function addWebPartQuestionNode() {
    return {
        data: (0, create_1.SPFxImportFolderQuestion)(true),
        children: [
            {
                data: (0, create_1.SPFxWebpartNameQuestion)(),
                children: [
                    {
                        data: (0, create_1.SPFxFrameworkQuestion)(),
                        condition: async (inputs) => {
                            return !(await spfxFrameworkExist(inputs));
                        },
                    },
                    {
                        data: selectTeamsAppManifestQuestion(),
                        children: [
                            {
                                condition: (inputs) => confirmCondition(inputs, false),
                                data: confirmManifestQuestion(true, false),
                                cliOptionDisabled: "self",
                                inputsDisabled: "self",
                            },
                            {
                                data: selectLocalTeamsAppManifestQuestion(),
                                children: [
                                    {
                                        condition: (inputs) => confirmCondition(inputs, true),
                                        data: confirmManifestQuestion(true, true),
                                        cliOptionDisabled: "self",
                                        inputsDisabled: "self",
                                    },
                                ],
                            },
                        ],
                    },
                ],
            },
        ],
    };
}
exports.addWebPartQuestionNode = addWebPartQuestionNode;
function selectTeamsAppManifestQuestion() {
    return {
        name: constants_3.QuestionNames.TeamsAppManifestFilePath,
        cliName: "teams-manifest-file",
        cliShortName: "t",
        cliDescription: "Specify the path for Teams app manifest template. It can be either absolute path or relative path to the project root folder, with default at './appPackage/manifest.json'",
        title: (0, localizeUtils_1.getLocalizedString)("core.selectTeamsAppManifestQuestion.title"),
        type: "singleFile",
        default: (inputs) => {
            if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
                return "./appPackage/manifest.json";
            }
            else {
                if (!inputs.projectPath)
                    return undefined;
                const manifestPath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, "manifest.json");
                if (fs_extra_1.default.pathExistsSync(manifestPath)) {
                    return manifestPath;
                }
                else {
                    return undefined;
                }
            }
        },
    };
}
exports.selectTeamsAppManifestQuestion = selectTeamsAppManifestQuestion;
function selectLocalTeamsAppManifestQuestion() {
    return {
        name: constants_3.QuestionNames.LocalTeamsAppManifestFilePath,
        cliName: "local-teams-manifest-file",
        cliShortName: "l",
        cliDescription: "Specifies the Microsoft Teams app manifest template file path for local environment, it can be either absolute path or relative path to project root folder.",
        title: (0, localizeUtils_1.getLocalizedString)("core.selectLocalTeamsAppManifestQuestion.title"),
        type: "singleFile",
        default: (inputs) => {
            if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
                return "./appPackage/manifest.local.json";
            }
            else {
                if (!inputs.projectPath)
                    return undefined;
                const manifestPath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, "manifest.local.json");
                if (fs_extra_1.default.pathExistsSync(manifestPath)) {
                    return manifestPath;
                }
                else {
                    return undefined;
                }
            }
        },
    };
}
exports.selectLocalTeamsAppManifestQuestion = selectLocalTeamsAppManifestQuestion;
function confirmManifestQuestion(isTeamsApp = true, isLocal = false) {
    const map = {
        true_true: constants_3.QuestionNames.ConfirmLocalManifest,
        true_false: constants_3.QuestionNames.ConfirmManifest,
        false_true: constants_3.QuestionNames.ConfirmAadManifest,
        false_false: constants_3.QuestionNames.ConfirmAadManifest,
    };
    const name = map[`${isTeamsApp.toString()}_${isLocal.toString()}`];
    return {
        name: name,
        title: isTeamsApp
            ? (0, localizeUtils_1.getLocalizedString)(isLocal
                ? "core.selectLocalTeamsAppManifestQuestion.title"
                : "core.selectTeamsAppManifestQuestion.title")
            : (0, localizeUtils_1.getLocalizedString)("core.selectAadAppManifestQuestion.title"),
        type: "singleSelect",
        staticOptions: [],
        skipSingleOption: false,
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.confirmManifestQuestion.placeholder"),
        dynamicOptions: (inputs) => {
            return [
                {
                    id: "manifest",
                    label: `$(file) ${path.basename(isTeamsApp
                        ? inputs[isLocal
                            ? constants_3.QuestionNames.LocalTeamsAppManifestFilePath
                            : constants_3.QuestionNames.TeamsAppManifestFilePath]
                        : inputs[constants_3.QuestionNames.AadAppManifestFilePath])}`,
                    description: path.dirname(isTeamsApp
                        ? inputs[isLocal
                            ? constants_3.QuestionNames.LocalTeamsAppManifestFilePath
                            : constants_3.QuestionNames.TeamsAppManifestFilePath]
                        : inputs[constants_3.QuestionNames.AadAppManifestFilePath]),
                },
            ];
        },
    };
}
function selectTeamsAppValidationMethodQuestion() {
    const options = [constants_3.TeamsAppValidationOptions.schema(), constants_3.TeamsAppValidationOptions.package()];
    if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.AsyncAppValidation)) {
        options.push(constants_3.TeamsAppValidationOptions.testCases());
    }
    return {
        name: constants_3.QuestionNames.ValidateMethod,
        title: (0, localizeUtils_1.getLocalizedString)("core.selectValidateMethodQuestion.validate.selectTitle"),
        staticOptions: options,
        type: "singleSelect",
    };
}
function copilotPluginAddAPIQuestionNode() {
    return {
        data: (0, create_1.apiSpecLocationQuestion)(false),
        children: [
            {
                data: (0, create_1.apiOperationQuestion)(false),
            },
        ],
    };
}
exports.copilotPluginAddAPIQuestionNode = copilotPluginAddAPIQuestionNode;
function selectTeamsAppPackageQuestion() {
    return {
        name: constants_3.QuestionNames.TeamsAppPackageFilePath,
        title: (0, localizeUtils_1.getLocalizedString)("core.selectTeamsAppPackageQuestion.title"),
        cliDescription: "Specifies the zipped Microsoft Teams app package path, it's a relative path to project root folder, defaults to '${folder}/appPackage/build/appPackage.${env}.zip'",
        cliName: "app-package-file",
        cliShortName: "p",
        type: "singleFile",
        default: (inputs) => {
            if (!inputs.projectPath)
                return undefined;
            const appPackagePath = path.join(inputs.projectPath, teamsfx_api_1.AppPackageFolderName, teamsfx_api_1.BuildFolderName, "appPackage.dev.zip");
            if (fs_extra_1.default.pathExistsSync(appPackagePath)) {
                return appPackagePath;
            }
            else {
                return undefined;
            }
        },
    };
}
function selectTeamsAppPackageQuestionNode() {
    return {
        data: selectTeamsAppPackageQuestion(),
    };
}
exports.selectTeamsAppPackageQuestionNode = selectTeamsAppPackageQuestionNode;
function selectM365HostQuestion() {
    return {
        name: constants_3.QuestionNames.M365Host,
        cliShortName: "m",
        cliDescription: "Preview the application in Teams, Outlook or the Microsoft 365 app.",
        title: (0, localizeUtils_1.getLocalizedString)("core.M365HostQuestion.title"),
        default: constants_3.HubOptions.teams().id,
        type: "singleSelect",
        staticOptions: constants_3.HubOptions.all(),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.M365HostQuestion.placeholder"),
    };
}
function previewWithTeamsAppManifestQuestionNode() {
    return {
        data: { type: "group" },
        children: [
            {
                data: selectM365HostQuestion(),
            },
            selectTeamsAppManifestQuestionNode(),
        ],
    };
}
exports.previewWithTeamsAppManifestQuestionNode = previewWithTeamsAppManifestQuestionNode;
function selectTargetEnvQuestion(questionName = constants_3.QuestionNames.TargetEnvName, remoteOnly = true, throwErrorIfNoEnv = false, defaultValueIfNoEnv = environmentName_1.environmentNameManager.getDefaultEnvName()) {
    return {
        type: "singleSelect",
        name: questionName,
        title: (0, localizeUtils_1.getLocalizedString)("core.QuestionSelectTargetEnvironment.title"),
        cliName: "env",
        cliDescription: "Specifies the environment name for the project.",
        staticOptions: [],
        dynamicOptions: async (inputs) => {
            if (!inputs.projectPath)
                return [];
            const res = await envUtil_1.envUtil.listEnv(inputs.projectPath, remoteOnly);
            if (res.isErr()) {
                if (throwErrorIfNoEnv)
                    throw res.error;
                return [defaultValueIfNoEnv];
            }
            // "testtool" env is a pure local env and doesn't have manifest
            return res.value.filter((env) => env !== environmentName_1.environmentNameManager.getTestToolEnvName());
        },
        skipSingleOption: true,
        forgetLastValue: true,
    };
}
exports.selectTargetEnvQuestion = selectTargetEnvQuestion;
async function getDefaultUserEmail() {
    if (!(globalVars_1.TOOLS === null || globalVars_1.TOOLS === void 0 ? void 0 : globalVars_1.TOOLS.tokenProvider.m365TokenProvider))
        return undefined;
    const jsonObjectRes = await globalVars_1.TOOLS.tokenProvider.m365TokenProvider.getJsonObject({
        scopes: constants_1.AppStudioScopes,
    });
    if (jsonObjectRes.isErr()) {
        throw jsonObjectRes.error;
    }
    const jsonObject = jsonObjectRes.value;
    const currentUserEmail = jsonObject.upn;
    let defaultUserEmail = "";
    if (currentUserEmail && currentUserEmail.indexOf("@") > 0) {
        defaultUserEmail = "[UserName]@" + currentUserEmail.split("@")[1];
    }
    return defaultUserEmail;
}
function inputUserEmailQuestion() {
    return {
        name: constants_3.QuestionNames.UserEmail,
        type: "text",
        title: (0, localizeUtils_1.getLocalizedString)("core.getUserEmailQuestion.title"),
        cliDescription: "Email address of the collaborator.",
        default: getDefaultUserEmail,
        validation: {
            validFunc: async (input, previousInputs) => {
                if (!input || input.trim() === "") {
                    return (0, localizeUtils_1.getLocalizedString)("core.getUserEmailQuestion.validation1");
                }
                input = input.trim();
                const defaultUserEmail = await getDefaultUserEmail();
                if (input === defaultUserEmail) {
                    return (0, localizeUtils_1.getLocalizedString)("core.getUserEmailQuestion.validation2");
                }
                const re = /\S+@\S+\.\S+/;
                if (!re.test(input)) {
                    return (0, localizeUtils_1.getLocalizedString)("core.getUserEmailQuestion.validation3");
                }
                return undefined;
            },
        },
    };
}
exports.inputUserEmailQuestion = inputUserEmailQuestion;
async function isAadMainifestContainsPlaceholder(inputs) {
    const aadManifestPath = inputs === null || inputs === void 0 ? void 0 : inputs[constants_3.QuestionNames.AadAppManifestFilePath];
    const placeholderRegex = /\$\{\{ *[a-zA-Z0-9_.-]* *\}\}/g;
    const regexObj = new RegExp(placeholderRegex);
    try {
        if (!aadManifestPath || !(await fs_extra_1.default.pathExists(aadManifestPath))) {
            return false;
        }
        const manifest = await fs_extra_1.default.readFile(aadManifestPath, constants_1.ConstantString.UTF8Encoding);
        if (regexObj.test(manifest)) {
            return true;
        }
    }
    catch (e) {
        return false;
    }
    return false;
}
exports.isAadMainifestContainsPlaceholder = isAadMainifestContainsPlaceholder;
function selectAadManifestQuestion() {
    return {
        name: constants_3.QuestionNames.AadAppManifestFilePath,
        cliName: "entra-app-manifest-file",
        cliShortName: "a",
        cliDescription: "Specifies the Microsoft Entra app manifest file path, can be either absolute path or relative path to project root folder.",
        title: (0, localizeUtils_1.getLocalizedString)("core.selectAadAppManifestQuestion.title"),
        type: "singleFile",
        default: (inputs) => {
            if (inputs.platform === teamsfx_api_1.Platform.CLI_HELP) {
                return "./aad.manifest.json";
            }
            else {
                if (!inputs.projectPath)
                    return undefined;
                const manifestPath = path.join(inputs.projectPath, "aad.manifest.json");
                if (fs_extra_1.default.pathExistsSync(manifestPath)) {
                    return manifestPath;
                }
                else {
                    return undefined;
                }
            }
        },
    };
}
exports.selectAadManifestQuestion = selectAadManifestQuestion;
function selectAppTypeQuestion() {
    return {
        name: constants_3.QuestionNames.collaborationAppType,
        title: (0, localizeUtils_1.getLocalizedString)("core.selectCollaborationAppTypeQuestion.title"),
        type: "multiSelect",
        staticOptions: [
            {
                id: collaborator_1.CollaborationConstants.AadAppQuestionId,
                label: (0, localizeUtils_1.getLocalizedString)("core.aadAppQuestion.label"),
                description: (0, localizeUtils_1.getLocalizedString)("core.aadAppQuestion.description"),
            },
            {
                id: collaborator_1.CollaborationConstants.TeamsAppQuestionId,
                label: (0, localizeUtils_1.getLocalizedString)("core.teamsAppQuestion.label"),
                description: (0, localizeUtils_1.getLocalizedString)("core.teamsAppQuestion.description"),
            },
        ],
        validation: { minItems: 1 },
        validationHelp: "Please select at least one app type.",
    };
}
async function envQuestionCondition(inputs) {
    const appType = inputs[collaborator_1.CollaborationConstants.AppType];
    const requireAad = appType === null || appType === void 0 ? void 0 : appType.includes(collaborator_1.CollaborationConstants.AadAppQuestionId);
    const requireTeams = appType === null || appType === void 0 ? void 0 : appType.includes(collaborator_1.CollaborationConstants.TeamsAppQuestionId);
    const aadManifestPath = inputs[constants_3.QuestionNames.AadAppManifestFilePath];
    const teamsManifestPath = inputs[constants_3.QuestionNames.TeamsAppManifestFilePath];
    // When both is selected, only show the question once at the end
    if ((requireAad && !aadManifestPath) || (requireTeams && !teamsManifestPath)) {
        return false;
    }
    // Only show env question when manifest id is referencing value from .env file
    let requireEnv = false;
    if (requireTeams && teamsManifestPath) {
        const teamsAppIdRes = await collaborator_1.CollaborationUtil.loadManifestId(teamsManifestPath);
        if (teamsAppIdRes.isOk()) {
            requireEnv = collaborator_1.CollaborationUtil.requireEnvQuestion(teamsAppIdRes.value);
            if (requireEnv) {
                return true;
            }
        }
        else {
            return false;
        }
    }
    if (requireAad && aadManifestPath) {
        const aadAppIdRes = await collaborator_1.CollaborationUtil.loadManifestId(aadManifestPath);
        if (aadAppIdRes.isOk()) {
            requireEnv = collaborator_1.CollaborationUtil.requireEnvQuestion(aadAppIdRes.value);
            if (requireEnv) {
                return true;
            }
        }
        else {
            return false;
        }
    }
    return false;
}
exports.envQuestionCondition = envQuestionCondition;
async function newEnvNameValidation(input, inputs) {
    const targetEnvName = input;
    const match = targetEnvName.match(environmentName_1.environmentNameManager.envNameRegex);
    if (!match) {
        return (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.validation1");
    }
    if (!environmentName_1.environmentNameManager.isRemoteEnvironment(targetEnvName)) {
        return (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.validation3", targetEnvName);
    }
    if (!(inputs === null || inputs === void 0 ? void 0 : inputs.projectPath))
        return "Project path is not defined";
    const envListRes = await envUtil_1.envUtil.listEnv(inputs.projectPath, true);
    if (envListRes.isErr()) {
        return (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.validation4");
    }
    inputs.existingEnvNames = envListRes.value; //cache existing env names
    const found = envListRes.value.find((env) => env.localeCompare(targetEnvName, undefined, { sensitivity: "base" }) === 0) !== undefined;
    if (found) {
        return (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.validation5", targetEnvName);
    }
    else {
        return undefined;
    }
}
exports.newEnvNameValidation = newEnvNameValidation;
function newTargetEnvQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.NewTargetEnvName,
        cliName: "name",
        cliDescription: "Specifies the new environment name.",
        cliType: "argument",
        title: (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.title"),
        validation: {
            validFunc: newEnvNameValidation,
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.getQuestionNewTargetEnvironmentName.placeholder"),
    };
}
exports.newTargetEnvQuestion = newTargetEnvQuestion;
// export const lastUsedMark = " (last used)";
// let lastUsedEnv: string | undefined;
// export function reOrderEnvironments(environments: Array<string>): Array<string> {
//   if (!lastUsedEnv) {
//     return environments;
//   }
//   const index = environments.indexOf(lastUsedEnv);
//   if (index === -1) {
//     return environments;
//   }
//   return [lastUsedEnv + lastUsedMark]
//     .concat(environments.slice(0, index))
//     .concat(environments.slice(index + 1));
// }
function selectSourceEnvQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SourceEnvName,
        cliName: "env",
        title: (0, localizeUtils_1.getLocalizedString)("core.QuestionSelectSourceEnvironment.title"),
        cliDescription: "Specifies an existing environment name to copy from.",
        staticOptions: [],
        dynamicOptions: async (inputs) => {
            if (inputs.existingEnvNames) {
                const envList = inputs.existingEnvNames;
                return envList;
            }
            else if (inputs.projectPath) {
                const envListRes = await envUtil_1.envUtil.listEnv(inputs.projectPath, true);
                if (envListRes.isErr()) {
                    throw envListRes.error;
                }
                return envListRes.value;
            }
            return [];
        },
        skipSingleOption: true,
        forgetLastValue: true,
    };
}
exports.selectSourceEnvQuestion = selectSourceEnvQuestion;
function createNewEnvQuestionNode() {
    return {
        data: newTargetEnvQuestion(),
        children: [
            {
                data: selectSourceEnvQuestion(),
            },
        ],
    };
}
exports.createNewEnvQuestionNode = createNewEnvQuestionNode;
// add Plugin to a declarative Copilot project
function addPluginQuestionNode() {
    return {
        data: (0, create_1.apiPluginStartQuestion)(true),
        children: [
            {
                data: (0, create_1.pluginManifestQuestion)(),
                condition: {
                    equals: constants_3.ApiPluginStartOptions.existingPlugin().id,
                },
            },
            {
                data: (0, create_1.pluginApiSpecQuestion)(),
                condition: {
                    equals: constants_3.ApiPluginStartOptions.existingPlugin().id,
                },
            },
            {
                data: (0, create_1.apiSpecLocationQuestion)(),
                condition: (inputs) => {
                    return (!featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
                        inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id);
                },
            },
            {
                data: (0, create_1.apiOperationQuestion)(true, true),
                condition: (inputs) => {
                    return (!featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
                        inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id);
                },
            },
            {
                data: selectTeamsAppManifestQuestion(),
            },
        ],
    };
}
exports.addPluginQuestionNode = addPluginQuestionNode;
function apiSpecApiKeyConfirmQestion() {
    return {
        name: constants_3.QuestionNames.ApiSpecApiKeyConfirm,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.ApiKeyConfirm"),
        type: "confirm",
        default: true,
    };
}
exports.apiSpecApiKeyConfirmQestion = apiSpecApiKeyConfirmQestion;
function apiSpecApiKeyQuestion() {
    return {
        data: {
            type: "text",
            name: constants_3.QuestionNames.ApiSpecApiKey,
            cliShortName: "k",
            password: true,
            title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.ApiKey"),
            cliDescription: "Api key for OpenAPI spec.",
            forgetLastValue: true,
            validation: {
                validFunc: (input) => {
                    if (input.length < 10 || input.length > 512) {
                        return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.invalidApiKey.message");
                    }
                    return undefined;
                },
            },
            additionalValidationOnAccept: {
                validFunc: (input, inputs) => {
                    if (!inputs) {
                        throw new Error("inputs is undefined"); // should never happen
                    }
                    process.env[constants_3.QuestionNames.ApiSpecApiKey] = input;
                    return;
                },
            },
        },
        condition: (inputs) => {
            return (inputs.outputEnvVarNames &&
                !process.env[inputs.outputEnvVarNames.get("registrationId")] &&
                !inputs.primaryClientSecret &&
                !inputs.secondaryClientSecret);
        },
        children: [
            {
                data: apiSpecApiKeyConfirmQestion(),
            },
        ],
    };
}
exports.apiSpecApiKeyQuestion = apiSpecApiKeyQuestion;
function oauthQuestion() {
    return {
        data: { type: "group" },
        condition: (inputs) => {
            return (inputs.outputEnvVarNames && !process.env[inputs.outputEnvVarNames.get("configurationId")]);
        },
        children: [
            {
                data: oauthClientIdQuestion(),
                condition: (inputs) => {
                    return !inputs.clientId;
                },
            },
            {
                data: oauthClientSecretQuestion(),
                condition: (inputs) => {
                    return (!inputs.isPKCEEnabled &&
                        !inputs.clientSecret &&
                        (!inputs.identityProvider || inputs.identityProvider === "Custom"));
                },
            },
            {
                data: oauthConfirmQestion(),
                condition: (inputs) => {
                    return (!inputs.isPKCEEnabled &&
                        (!inputs.clientSecret || !inputs.clientId) &&
                        (!inputs.identityProvider || inputs.identityProvider === "Custom"));
                },
            },
        ],
    };
}
exports.oauthQuestion = oauthQuestion;
function uninstallQuestionNode() {
    return {
        data: {
            type: "group",
        },
        children: [
            {
                data: uninstallModeQuestion(),
                condition: () => {
                    return true;
                },
                children: [
                    {
                        data: {
                            type: "text",
                            name: constants_3.QuestionNames.ManifestId,
                            title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.manifestId"),
                        },
                        condition: (input) => {
                            return input[constants_3.QuestionNames.UninstallMode] === constants_3.QuestionNames.UninstallModeManifestId;
                        },
                    },
                    {
                        data: {
                            type: "text",
                            name: constants_3.QuestionNames.Env,
                            title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.env"),
                        },
                        condition: (input) => {
                            return input[constants_3.QuestionNames.UninstallMode] === constants_3.QuestionNames.UninstallModeEnv;
                        },
                        children: [
                            {
                                data: uninstallProjectPathQuestion(),
                                condition: () => {
                                    return true;
                                },
                            },
                        ],
                    },
                    {
                        data: uninstallOptionQuestion(),
                        condition: (input) => {
                            return (input[constants_3.QuestionNames.UninstallMode] === constants_3.QuestionNames.UninstallModeManifestId ||
                                input[constants_3.QuestionNames.UninstallMode] === constants_3.QuestionNames.UninstallModeEnv);
                        },
                    },
                    {
                        data: {
                            type: "text",
                            name: constants_3.QuestionNames.TitleId,
                            title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.titleId"),
                        },
                        condition: (input) => {
                            return input[constants_3.QuestionNames.UninstallMode] === constants_3.QuestionNames.UninstallModeTitleId;
                        },
                    },
                ],
            },
        ],
    };
}
exports.uninstallQuestionNode = uninstallQuestionNode;
function uninstallModeQuestion() {
    return {
        name: constants_3.QuestionNames.UninstallMode,
        title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.chooseMode"),
        type: "singleSelect",
        staticOptions: [
            {
                id: constants_3.QuestionNames.UninstallModeManifestId,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.manifestIdMode"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.manifestIdMode.detail"),
            },
            {
                id: constants_3.QuestionNames.UninstallModeEnv,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.envMode"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.envMode.detail"),
            },
            {
                id: constants_3.QuestionNames.UninstallModeTitleId,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.titleIdMode"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.titleIdMode.detail"),
            },
        ],
        default: constants_3.QuestionNames.UninstallModeManifestId,
    };
}
function uninstallOptionQuestion() {
    return {
        name: constants_3.QuestionNames.UninstallOptions,
        title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.chooseOption"),
        type: "multiSelect",
        staticOptions: [
            {
                id: constants_3.QuestionNames.UninstallOptionM365,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.m365Option"),
            },
            {
                id: constants_3.QuestionNames.UninstallOptionTDP,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.tdpOption"),
            },
            {
                id: constants_3.QuestionNames.UninstallOptionBot,
                label: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.botOption"),
            },
        ],
    };
}
function uninstallProjectPathQuestion() {
    return {
        type: "folder",
        name: constants_3.QuestionNames.ProjectPath,
        title: (0, localizeUtils_1.getLocalizedString)("core.uninstallQuestion.projectPath"),
        cliDescription: "Project Path for uninstall",
        placeholder: "./",
        default: "./",
    };
}
function oauthClientIdQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.OauthClientId,
        cliShortName: "i",
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.OauthClientId"),
        cliDescription: "Oauth client id for OpenAPI spec.",
        forgetLastValue: true,
        additionalValidationOnAccept: {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                process.env[constants_3.QuestionNames.OauthClientId] = input;
                return;
            },
        },
    };
}
function oauthConfirmQestion() {
    return {
        name: constants_3.QuestionNames.OauthConfirm,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.OauthClientSecretConfirm"),
        type: "confirm",
        default: true,
    };
}
function oauthClientSecretQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.OauthClientSecret,
        cliShortName: "c",
        password: true,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.OauthClientSecret"),
        cliDescription: "Oauth client secret for OpenAPI spec.",
        forgetLastValue: true,
        validation: {
            validFunc: (input) => {
                if (input.length < 10 || input.length > 512) {
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.invalidApiKey.message");
                }
                return undefined;
            },
        },
        additionalValidationOnAccept: {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                process.env[constants_3.QuestionNames.OauthClientSecret] = input;
                return;
            },
        },
    };
}
function syncManifestQuestionNode() {
    return {
        data: {
            type: "group",
        },
        children: [
            {
                data: {
                    type: "folder",
                    name: constants_3.QuestionNames.ProjectPath,
                    title: (0, localizeUtils_1.getLocalizedString)("core.syncManifest.projectPath"),
                    cliDescription: "Project Path",
                    placeholder: "./",
                    default: (inputs) => teamsfx_api_1.CLIPlatforms.includes(inputs.platform)
                        ? "./"
                        : path.join(os.homedir(), constants_1.ConstantString.RootFolder),
                },
            },
            {
                data: {
                    type: "text",
                    name: constants_3.QuestionNames.Env,
                    title: (0, localizeUtils_1.getLocalizedString)("core.syncManifest.env"),
                    cliDescription: "Target Teams Toolkit Environment",
                },
            },
            {
                data: {
                    type: "text",
                    name: constants_3.QuestionNames.TeamsAppId,
                    title: (0, localizeUtils_1.getLocalizedString)("core.syncManifest.teamsAppId"),
                    cliDescription: "Teams App ID (optional)",
                },
            },
        ],
    };
}
exports.syncManifestQuestionNode = syncManifestQuestionNode;
//# sourceMappingURL=other.js.map
"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProjectCliHelpNode = exports.createSampleProjectQuestionNode = exports.createProjectQuestionNode = exports.capabilitySubTree = exports.pluginApiSpecQuestion = exports.pluginManifestQuestion = exports.apiPluginStartQuestion = exports.apiOperationQuestion = exports.apiAuthQuestion = exports.apiSpecLocationQuestion = exports.appNameQuestion = exports.getSolutionName = exports.folderQuestion = exports.programmingLanguageQuestion = exports.getLanguageOptions = exports.getOfficeAddinTemplateConfig = exports.getOfficeAddinFramework = exports.getAddinFrameworkOptions = exports.officeAddinFrameworkQuestion = exports.SPFxImportFolderQuestion = exports.SPFxWebpartNameQuestion = exports.SPFxFrameworkQuestion = exports.SPFxPackageSelectQuestion = exports.meArchitectureQuestion = exports.capabilityQuestion = exports.isFromDevPortal = exports.getProjectTypeAndCapability = exports.projectTypeQuestion = void 0;
const tslib_1 = require("tslib");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const fs_extra_1 = tslib_1.__importDefault(require("fs-extra"));
const jsonschema = tslib_1.__importStar(require("jsonschema"));
const lodash_1 = require("lodash");
const os = tslib_1.__importStar(require("os"));
const path = tslib_1.__importStar(require("path"));
const constants_1 = require("../common/constants");
const correlator_1 = require("../common/correlator");
const featureFlags_1 = require("../common/featureFlags");
const globalVars_1 = require("../common/globalVars");
const localizeUtils_1 = require("../common/localizeUtils");
const samples_1 = require("../common/samples");
const stringUtils_1 = require("../common/stringUtils");
const utils_1 = require("../component/driver/teamsApp/utils/utils");
const helper_1 = require("../component/generator/apiSpec/helper");
const projectConfig_1 = require("../component/generator/officeXMLAddin/projectConfig");
const error_1 = require("../component/generator/spfx/error");
const constants_2 = require("../component/generator/spfx/utils/constants");
const utils_2 = require("../component/generator/spfx/utils/utils");
const error_2 = require("../error");
const constants_3 = require("./constants");
const m365_spec_parser_1 = require("@microsoft/m365-spec-parser");
const PluginManifestUtils_1 = require("../component/driver/teamsApp/utils/PluginManifestUtils");
const helper_2 = require("../component/generator/copilotExtension/helper");
const telemetry_1 = require("../common/telemetry");
function projectTypeQuestion() {
    const staticOptions = [
        constants_3.ProjectTypeOptions.bot(teamsfx_api_1.Platform.CLI),
        constants_3.ProjectTypeOptions.tab(teamsfx_api_1.Platform.CLI),
        constants_3.ProjectTypeOptions.me(teamsfx_api_1.Platform.CLI),
        constants_3.ProjectTypeOptions.officeAddin(teamsfx_api_1.Platform.CLI),
        constants_3.ProjectTypeOptions.outlookAddin(teamsfx_api_1.Platform.CLI),
    ];
    return {
        name: constants_3.QuestionNames.ProjectType,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.title"),
        type: "singleSelect",
        staticOptions: staticOptions,
        dynamicOptions: (inputs) => {
            var _a;
            const staticOptions = [];
            staticOptions.push(constants_3.ProjectTypeOptions.copilotExtension(inputs.platform));
            if ((0, constants_3.getRuntime)(inputs) === constants_3.RuntimeOptions.NodeJS().id) {
                staticOptions.push(constants_3.ProjectTypeOptions.customCopilot(inputs.platform));
            }
            staticOptions.push(constants_3.ProjectTypeOptions.bot(inputs.platform), constants_3.ProjectTypeOptions.tab(inputs.platform), constants_3.ProjectTypeOptions.me(inputs.platform));
            if (isFromDevPortal(inputs)) {
                const projectType = (_a = getProjectTypeAndCapability(inputs.teamsAppFromTdp)) === null || _a === void 0 ? void 0 : _a.projectType;
                if (projectType) {
                    return [projectType];
                }
            }
            else if ((0, constants_3.getRuntime)(inputs) === constants_3.RuntimeOptions.NodeJS().id) {
                if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.OfficeMetaOS)) {
                    staticOptions.push(constants_3.ProjectTypeOptions.officeMetaOS(inputs.platform));
                }
                else if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.OfficeAddin)) {
                    staticOptions.push(constants_3.ProjectTypeOptions.officeAddin(inputs.platform));
                }
                else {
                    staticOptions.push(constants_3.ProjectTypeOptions.outlookAddin(inputs.platform));
                }
            }
            if (inputs.platform === teamsfx_api_1.Platform.VSCode &&
                featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.ChatParticipantUIEntries) &&
                !inputs.teamsAppFromTdp) {
                staticOptions.push(constants_3.ProjectTypeOptions.startWithGithubCopilot());
            }
            return staticOptions;
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.getCreateNewOrFromSampleQuestion.placeholder"),
        forgetLastValue: true,
        skipSingleOption: true,
    };
}
exports.projectTypeQuestion = projectTypeQuestion;
function getProjectTypeAndCapability(teamsApp) {
    // tab with bot, tab with message extension, tab with bot and message extension
    if ((0, utils_1.needTabAndBotCode)(teamsApp)) {
        return { projectType: "tab-bot-type", templateId: constants_3.CapabilityOptions.nonSsoTabAndBot().id };
    }
    // tab only
    if ((0, utils_1.needTabCode)(teamsApp)) {
        return { projectType: "tab-type", templateId: constants_3.CapabilityOptions.nonSsoTab().id };
    }
    // bot and message extension
    if ((0, utils_1.isBotAndBotBasedMessageExtension)(teamsApp)) {
        return { projectType: "bot-me-type", templateId: constants_3.CapabilityOptions.botAndMe().id };
    }
    // bot based message extension
    if ((0, utils_1.isBotBasedMessageExtension)(teamsApp)) {
        return { projectType: "me-type", templateId: constants_3.CapabilityOptions.me().id };
    }
    // bot
    if ((0, utils_1.isBot)(teamsApp)) {
        return { projectType: "bot-type", templateId: constants_3.CapabilityOptions.basicBot().id };
    }
    return undefined;
}
exports.getProjectTypeAndCapability = getProjectTypeAndCapability;
function isFromDevPortal(inputs) {
    return !!(inputs === null || inputs === void 0 ? void 0 : inputs.teamsAppFromTdp);
}
exports.isFromDevPortal = isFromDevPortal;
function capabilityQuestion() {
    return {
        name: constants_3.QuestionNames.Capabilities,
        title: (inputs) => {
            const projectType = inputs[constants_3.QuestionNames.ProjectType];
            switch (projectType) {
                case constants_3.ProjectTypeOptions.bot().id:
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.bot.title");
                case constants_3.ProjectTypeOptions.tab().id:
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.tab.title");
                case constants_3.ProjectTypeOptions.me().id:
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.messageExtension.title");
                case constants_3.ProjectTypeOptions.outlookAddin().id:
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.outlookAddin.title");
                case constants_3.ProjectTypeOptions.officeMetaOS().id:
                case constants_3.ProjectTypeOptions.officeAddin().id:
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.officeAddin.title");
                case constants_3.ProjectTypeOptions.copilotExtension().id:
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.copilotExtension.title");
                case constants_3.ProjectTypeOptions.customCopilot().id:
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.customCopilot.title");
                default:
                    return (0, localizeUtils_1.getLocalizedString)("core.createCapabilityQuestion.titleNew");
            }
        },
        cliDescription: "Specifies the Microsoft Teams App capability.",
        cliName: constants_3.CliQuestionName.Capability,
        cliShortName: "c",
        cliChoiceListCommand: "teamsapp list templates",
        type: "singleSelect",
        staticOptions: constants_3.CapabilityOptions.staticAll(),
        dynamicOptions: (inputs) => {
            var _a;
            // from dev portal
            if (isFromDevPortal(inputs)) {
                const capability = (_a = getProjectTypeAndCapability(inputs.teamsAppFromTdp)) === null || _a === void 0 ? void 0 : _a.templateId;
                if (capability) {
                    return [capability];
                }
            }
            // dotnet capabilities
            if (inputs.platform === teamsfx_api_1.Platform.VS) {
                return constants_3.CapabilityOptions.dotnetCaps(inputs);
            }
            if (inputs.nonInteractive && inputs.platform === teamsfx_api_1.Platform.CLI) {
                //cli non-interactive mode the choice list is the same as staticOptions
                return constants_3.CapabilityOptions.all(inputs);
            }
            // capabilities if VSC or CLI interactive mode
            const projectType = inputs[constants_3.QuestionNames.ProjectType];
            if (projectType === constants_3.ProjectTypeOptions.bot().id) {
                return constants_3.CapabilityOptions.bots(inputs);
            }
            else if (projectType === constants_3.ProjectTypeOptions.tab().id) {
                return constants_3.CapabilityOptions.tabs();
            }
            else if (projectType === constants_3.ProjectTypeOptions.me().id) {
                return constants_3.CapabilityOptions.mes();
            }
            else if (constants_3.ProjectTypeOptions.officeAddinAllIds().includes(projectType)) {
                return constants_3.CapabilityOptions.officeAddinDynamicCapabilities(projectType, inputs[constants_3.QuestionNames.OfficeAddinHost]);
            }
            else if (projectType === constants_3.ProjectTypeOptions.copilotExtension().id) {
                return constants_3.CapabilityOptions.copilotExtensions();
            }
            else if (projectType === constants_3.ProjectTypeOptions.customCopilot().id) {
                return constants_3.CapabilityOptions.customCopilots();
            }
            else {
                return constants_3.CapabilityOptions.all(inputs);
            }
        },
        placeholder: (inputs) => {
            if (inputs[constants_3.QuestionNames.ProjectType] === constants_3.ProjectTypeOptions.copilotExtension().id) {
                return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.copilotExtension.placeholder");
            }
            else if (inputs[constants_3.QuestionNames.ProjectType] === constants_3.ProjectTypeOptions.customCopilot().id) {
                return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.customCopilot.placeholder");
            }
            return (0, localizeUtils_1.getLocalizedString)("core.createCapabilityQuestion.placeholder");
        },
        forgetLastValue: true,
        skipSingleOption: (inputs) => {
            return isFromDevPortal(inputs);
        },
    };
}
exports.capabilityQuestion = capabilityQuestion;
function meArchitectureQuestion() {
    return {
        name: constants_3.QuestionNames.MeArchitectureType,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.meArchitecture.title"),
        cliDescription: "Architecture of Search Based Message Extension.",
        cliShortName: "m",
        type: "singleSelect",
        staticOptions: constants_3.MeArchitectureOptions.staticAll(),
        dynamicOptions: (inputs) => {
            return constants_3.MeArchitectureOptions.all();
        },
        default: constants_3.MeArchitectureOptions.newApi().id,
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.copilotExtension.placeholder"),
        forgetLastValue: true,
        skipSingleOption: true,
    };
}
exports.meArchitectureQuestion = meArchitectureQuestion;
function botTriggerQuestion() {
    return {
        name: constants_3.QuestionNames.BotTrigger,
        title: (0, localizeUtils_1.getLocalizedString)("plugins.bot.questionHostTypeTrigger.title"),
        cliDescription: "Specifies the trigger for `Chat Notification Message` app template.",
        cliShortName: "t",
        type: "singleSelect",
        staticOptions: constants_3.NotificationTriggerOptions.all(),
        dynamicOptions: (inputs) => {
            const runtime = (0, constants_3.getRuntime)(inputs);
            return [
                runtime === constants_3.RuntimeOptions.DotNet().id
                    ? constants_3.NotificationTriggerOptions.appServiceForVS()
                    : constants_3.NotificationTriggerOptions.appService(),
                ...constants_3.NotificationTriggerOptions.functionsTriggers(),
            ];
        },
        default: (inputs) => {
            const runtime = (0, constants_3.getRuntime)(inputs);
            return runtime === constants_3.RuntimeOptions.DotNet().id
                ? constants_3.NotificationTriggerOptions.appServiceForVS().id
                : constants_3.NotificationTriggerOptions.appService().id;
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("plugins.bot.questionHostTypeTrigger.placeholder"),
    };
}
function SPFxSolutionQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SPFxSolution,
        title: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.spfxSolution.title"),
        cliDescription: "Create a new or import an existing SharePoint Framework solution.",
        cliShortName: "s",
        staticOptions: [
            {
                id: "new",
                label: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.spfxSolution.createNew"),
                detail: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.spfxSolution.createNew.detail"),
            },
            {
                id: "import",
                label: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.spfxSolution.importExisting"),
                detail: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.spfxSolution.importExisting.detail"),
            },
        ],
        default: "new",
    };
}
function SPFxPackageSelectQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SPFxInstallPackage,
        title: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.title"),
        cliDescription: "Install the latest version of SharePoint Framework.",
        staticOptions: [],
        placeholder: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.placeholder"),
        dynamicOptions: async (inputs) => {
            const versions = await Promise.all([
                utils_2.Utils.findGloballyInstalledVersion(undefined, constants_2.Constants.GeneratorPackageName, 0, false),
                utils_2.Utils.findLatestVersion(undefined, constants_2.Constants.GeneratorPackageName, 5),
                utils_2.Utils.findGloballyInstalledVersion(undefined, constants_2.Constants.YeomanPackageName, 0, false),
            ]);
            inputs.globalSpfxPackageVersion = versions[0];
            inputs.latestSpfxPackageVersion = versions[1];
            inputs.globalYeomanPackageVersion = versions[2];
            return [
                {
                    id: constants_3.SPFxVersionOptionIds.installLocally,
                    label: versions[1] !== undefined
                        ? (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.installLocally.withVersion.label", "v" + versions[1])
                        : (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.installLocally.noVersion.label"),
                },
                {
                    id: constants_3.SPFxVersionOptionIds.globalPackage,
                    label: versions[0] !== undefined
                        ? (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.useGlobalPackage.withVersion.label", "v" + versions[0])
                        : (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.useGlobalPackage.noVersion.label"),
                    description: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.packageSelect.useGlobalPackage.detail", constants_2.Constants.RecommendedLowestSpfxVersion),
                },
            ];
        },
        default: constants_3.SPFxVersionOptionIds.installLocally,
        validation: {
            validFunc: (input, previousInputs) => {
                if (input === constants_3.SPFxVersionOptionIds.globalPackage) {
                    const hasPackagesInstalled = !!previousInputs &&
                        !!previousInputs.globalSpfxPackageVersion &&
                        !!previousInputs.globalYeomanPackageVersion;
                    if (!hasPackagesInstalled) {
                        return Promise.reject((0, error_1.DevEnvironmentSetupError)());
                    }
                }
                return Promise.resolve(undefined);
            },
        },
        isBoolean: true,
    };
}
exports.SPFxPackageSelectQuestion = SPFxPackageSelectQuestion;
function SPFxFrameworkQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.SPFxFramework,
        cliShortName: "k",
        cliDescription: "Framework.",
        title: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.framework.title"),
        staticOptions: [
            { id: "react", label: "React" },
            { id: "minimal", label: "Minimal" },
            { id: "none", label: "None" },
        ],
        placeholder: "Select an option",
        default: "react",
    };
}
exports.SPFxFrameworkQuestion = SPFxFrameworkQuestion;
function SPFxWebpartNameQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.SPFxWebpartName,
        cliShortName: "w",
        cliDescription: "Name for SharePoint Framework Web Part.",
        title: (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.webpartName"),
        default: constants_2.Constants.DEFAULT_WEBPART_NAME,
        validation: {
            validFunc: async (input, previousInputs) => {
                const schema = {
                    pattern: "^[a-zA-Z_][a-zA-Z0-9_]*$",
                };
                const validateRes = jsonschema.validate(input, schema);
                if (validateRes.errors && validateRes.errors.length > 0) {
                    return (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.webpartName.error.notMatch", input, schema.pattern);
                }
                if (previousInputs &&
                    ((previousInputs.stage === teamsfx_api_1.Stage.addWebpart &&
                        previousInputs[constants_3.QuestionNames.SPFxFolder]) ||
                        ((previousInputs === null || previousInputs === void 0 ? void 0 : previousInputs.stage) === teamsfx_api_1.Stage.addFeature && (previousInputs === null || previousInputs === void 0 ? void 0 : previousInputs.projectPath)))) {
                    const webpartFolder = path.join(previousInputs[constants_3.QuestionNames.SPFxFolder], "src", "webparts", input);
                    if (await fs_extra_1.default.pathExists(webpartFolder)) {
                        return (0, localizeUtils_1.getLocalizedString)("plugins.spfx.questions.webpartName.error.duplicate", webpartFolder);
                    }
                }
                return undefined;
            },
        },
    };
}
exports.SPFxWebpartNameQuestion = SPFxWebpartNameQuestion;
function SPFxImportFolderQuestion(hasDefaultFunc = false) {
    return {
        type: "folder",
        name: constants_3.QuestionNames.SPFxFolder,
        title: (0, localizeUtils_1.getLocalizedString)("core.spfxFolder.title"),
        cliDescription: "Directory or Path that contains the existing SharePoint Framework solution.",
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.spfxFolder.placeholder"),
        default: hasDefaultFunc
            ? (inputs) => {
                if (inputs.projectPath)
                    return path.join(inputs.projectPath, "src");
                return undefined;
            }
            : undefined,
    };
}
exports.SPFxImportFolderQuestion = SPFxImportFolderQuestion;
function officeAddinFrameworkQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.OfficeAddinFramework,
        cliShortName: "f",
        cliDescription: "Framework for WXP extension.",
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.officeAddin.framework.title"),
        dynamicOptions: getAddinFrameworkOptions,
        staticOptions: [
            { id: "default", label: "Default" },
            { id: "react", label: "React" },
        ],
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.officeAddin.framework.placeholder"),
        skipSingleOption: true,
    };
}
exports.officeAddinFrameworkQuestion = officeAddinFrameworkQuestion;
function getAddinFrameworkOptions(inputs) {
    const projectType = inputs[constants_3.QuestionNames.ProjectType];
    const capabilities = inputs[constants_3.QuestionNames.Capabilities];
    if (projectType === constants_3.ProjectTypeOptions.outlookAddin().id) {
        return [{ id: "default", label: "Default" }];
    }
    else if ((projectType === constants_3.ProjectTypeOptions.officeAddin().id &&
        capabilities === constants_3.CapabilityOptions.officeContentAddin().id) ||
        capabilities === constants_3.CapabilityOptions.officeAddinImport().id) {
        return [{ id: "default", label: "Default" }];
    }
    else {
        return [
            { id: "default", label: "Default" },
            { id: "react", label: "React" },
        ];
    }
}
exports.getAddinFrameworkOptions = getAddinFrameworkOptions;
/**
 * when project-type=office-addin-type(office-addin-framework-type=default or react), use selected value;
 * when project-type=outlook-addin-type, no framework to select, office-addin-framework-type=default_old
 * when project-type=office-xml-addin-type, no framework to select, office-addin-framework-type=default_old
 */
function getOfficeAddinFramework(inputs) {
    const projectType = inputs[constants_3.QuestionNames.ProjectType];
    if (projectType === constants_3.ProjectTypeOptions.officeAddin().id &&
        inputs[constants_3.QuestionNames.OfficeAddinFramework]) {
        return inputs[constants_3.QuestionNames.OfficeAddinFramework];
    }
    else if (projectType === constants_3.ProjectTypeOptions.outlookAddin().id) {
        return "default_old";
    }
    else {
        return "default";
    }
}
exports.getOfficeAddinFramework = getOfficeAddinFramework;
function getOfficeAddinTemplateConfig() {
    return projectConfig_1.OfficeAddinProjectConfig["json"];
}
exports.getOfficeAddinTemplateConfig = getOfficeAddinTemplateConfig;
function getLanguageOptions(inputs) {
    const runtime = (0, constants_3.getRuntime)(inputs);
    // dotnet runtime only supports C#
    if (runtime === constants_3.RuntimeOptions.DotNet().id) {
        return [{ id: constants_3.ProgrammingLanguage.CSharp, label: "C#" }];
    }
    const capabilities = inputs[constants_3.QuestionNames.Capabilities];
    // office addin supports language defined in officeAddinJsonData
    const projectType = inputs[constants_3.QuestionNames.ProjectType];
    if (constants_3.ProjectTypeOptions.officeAddinAllIds().includes(projectType)) {
        if (projectType === constants_3.ProjectTypeOptions.officeMetaOS().id) {
            return [{ id: constants_3.ProgrammingLanguage.JS, label: "JavaScript" }];
        }
        if (capabilities.endsWith("-manifest")) {
            return [{ id: constants_3.ProgrammingLanguage.JS, label: "JavaScript" }];
        }
        if (projectType === constants_3.ProjectTypeOptions.outlookAddin().id) {
            return [{ id: constants_3.ProgrammingLanguage.TS, label: "TypeScript" }];
        }
        const officeAddinLangConfig = getOfficeAddinTemplateConfig()[capabilities].framework["default"];
        const officeXMLAddinLangOptions = [];
        if (!!officeAddinLangConfig.typescript)
            officeXMLAddinLangOptions.push({ id: constants_3.ProgrammingLanguage.TS, label: "TypeScript" });
        if (!!officeAddinLangConfig.javascript)
            officeXMLAddinLangOptions.push({ id: constants_3.ProgrammingLanguage.JS, label: "JavaScript" });
        return officeXMLAddinLangOptions;
    }
    if (capabilities === constants_3.CapabilityOptions.SPFxTab().id) {
        // SPFx only supports typescript
        return [{ id: constants_3.ProgrammingLanguage.TS, label: "TypeScript" }];
    }
    else if (constants_3.capabilitiesHavePythonOption.includes(inputs[capabilities] ? inputs[capabilities] : capabilities) &&
        !(capabilities == constants_3.CapabilityOptions.customCopilotRag().id &&
            inputs[constants_3.CapabilityOptions.customCopilotRag().id] == constants_3.CustomCopilotRagOptions.microsoft365().id)) {
        // support python language
        return [
            { id: constants_3.ProgrammingLanguage.JS, label: "JavaScript" },
            { id: constants_3.ProgrammingLanguage.TS, label: "TypeScript" },
            { id: constants_3.ProgrammingLanguage.PY, label: "Python" },
        ];
    }
    else {
        // other cases
        return [
            { id: constants_3.ProgrammingLanguage.JS, label: "JavaScript" },
            { id: constants_3.ProgrammingLanguage.TS, label: "TypeScript" },
        ];
    }
}
exports.getLanguageOptions = getLanguageOptions;
function programmingLanguageQuestion() {
    const programmingLanguageQuestion = {
        name: constants_3.QuestionNames.ProgrammingLanguage,
        cliShortName: "l",
        title: (0, localizeUtils_1.getLocalizedString)("core.ProgrammingLanguageQuestion.title"),
        type: "singleSelect",
        staticOptions: [
            { id: constants_3.ProgrammingLanguage.JS, label: "JavaScript" },
            { id: constants_3.ProgrammingLanguage.TS, label: "TypeScript" },
            { id: constants_3.ProgrammingLanguage.CSharp, label: "C#" },
            { id: constants_3.ProgrammingLanguage.PY, label: "Python" },
        ],
        dynamicOptions: getLanguageOptions,
        default: (inputs) => {
            return getLanguageOptions(inputs)[0].id;
        },
        placeholder: (inputs) => {
            const runtime = (0, constants_3.getRuntime)(inputs);
            // dotnet
            if (runtime === constants_3.RuntimeOptions.DotNet().id) {
                return "";
            }
            const capabilities = inputs[constants_3.QuestionNames.Capabilities];
            // // office addin
            // const projectType = inputs[QuestionNames.ProjectType];
            // if (projectType === ProjectTypeOptions.outlookAddin().id) {
            //   const template = getTemplate(inputs);
            //   const options = officeAddinJsonData.getSupportedScriptTypesNew(template);
            //   return options[0] || "No Options";
            // }
            // SPFx
            if (capabilities === constants_3.CapabilityOptions.SPFxTab().id) {
                return (0, localizeUtils_1.getLocalizedString)("core.ProgrammingLanguageQuestion.placeholder.spfx");
            }
            // other
            return (0, localizeUtils_1.getLocalizedString)("core.ProgrammingLanguageQuestion.placeholder");
        },
        skipSingleOption: true,
    };
    return programmingLanguageQuestion;
}
exports.programmingLanguageQuestion = programmingLanguageQuestion;
function folderQuestion() {
    return {
        type: "folder",
        name: constants_3.QuestionNames.Folder,
        cliShortName: "f",
        title: (inputs) => teamsfx_api_1.CLIPlatforms.includes(inputs.platform)
            ? "Directory where the project folder will be created in"
            : (0, localizeUtils_1.getLocalizedString)("core.question.workspaceFolder.title"),
        cliDescription: "Directory where the project folder will be created in.",
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.question.workspaceFolder.placeholder"),
        default: (inputs) => teamsfx_api_1.CLIPlatforms.includes(inputs.platform)
            ? "./"
            : path.join(os.homedir(), constants_1.ConstantString.RootFolder),
    };
}
exports.folderQuestion = folderQuestion;
async function getSolutionName(spfxFolder) {
    const yoInfoPath = path.join(spfxFolder, constants_2.Constants.YO_RC_FILE);
    if (await fs_extra_1.default.pathExists(yoInfoPath)) {
        const yoInfo = await fs_extra_1.default.readJson(yoInfoPath);
        if (yoInfo["@microsoft/generator-sharepoint"]) {
            return yoInfo["@microsoft/generator-sharepoint"][constants_2.Constants.YO_RC_SOLUTION_NAME];
        }
        else {
            return undefined;
        }
    }
    else {
        throw new error_2.FileNotFoundError(constants_2.Constants.PLUGIN_NAME, yoInfoPath, constants_2.Constants.IMPORT_HELP_LINK);
    }
}
exports.getSolutionName = getSolutionName;
function appNameQuestion() {
    const question = {
        type: "text",
        name: constants_3.QuestionNames.AppName,
        cliShortName: "n",
        title: (0, localizeUtils_1.getLocalizedString)("core.question.appName.title"),
        required: true,
        default: async (inputs) => {
            var _a, _b;
            let defaultName = undefined;
            if ((_a = inputs.teamsAppFromTdp) === null || _a === void 0 ? void 0 : _a.appName) {
                defaultName = (0, stringUtils_1.convertToAlphanumericOnly)((_b = inputs.teamsAppFromTdp) === null || _b === void 0 ? void 0 : _b.appName);
            }
            else if (inputs[constants_3.QuestionNames.SPFxSolution] == "import") {
                defaultName = await getSolutionName(inputs[constants_3.QuestionNames.SPFxFolder]);
            }
            return defaultName;
        },
        validation: {
            validFunc: async (input, previousInputs) => {
                const schema = {
                    pattern: constants_3.AppNamePattern,
                    maxLength: 30,
                };
                if (input.length === 25) {
                    // show warning notification because it may exceed the Teams app name max length after appending suffix
                    const context = (0, globalVars_1.createContext)();
                    if ((previousInputs === null || previousInputs === void 0 ? void 0 : previousInputs.platform) === teamsfx_api_1.Platform.VSCode) {
                        void context.userInteraction.showMessage("warn", (0, localizeUtils_1.getLocalizedString)("core.QuestionAppName.validation.lengthWarning"), false);
                    }
                    else {
                        context.logProvider.warning((0, localizeUtils_1.getLocalizedString)("core.QuestionAppName.validation.lengthWarning"));
                    }
                }
                const appName = input;
                const validateResult = jsonschema.validate(appName, schema);
                if (validateResult.errors && validateResult.errors.length > 0) {
                    if (validateResult.errors[0].name === "pattern") {
                        return (0, localizeUtils_1.getLocalizedString)("core.QuestionAppName.validation.pattern");
                    }
                    if (validateResult.errors[0].name === "maxLength") {
                        return (0, localizeUtils_1.getLocalizedString)("core.QuestionAppName.validation.maxlength");
                    }
                }
                if (previousInputs && previousInputs.folder) {
                    const folder = previousInputs.folder;
                    if (folder) {
                        const projectPath = path.resolve(folder, appName);
                        const exists = await fs_extra_1.default.pathExists(projectPath);
                        if (exists)
                            return (0, localizeUtils_1.getLocalizedString)("core.QuestionAppName.validation.pathExist", projectPath);
                    }
                }
                return undefined;
            },
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.question.appName.placeholder"),
    };
    return question;
}
exports.appNameQuestion = appNameQuestion;
function sampleSelectQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.Samples,
        cliName: "sample-name",
        cliDescription: "Specifies the Microsoft Teams App sample name.",
        cliChoiceListCommand: "teamsapp list samples",
        skipValidation: true,
        cliType: "argument",
        title: (0, localizeUtils_1.getLocalizedString)("core.SampleSelect.title"),
        staticOptions: [
            "hello-world-tab-with-backend",
            "graph-toolkit-contact-exporter",
            "bot-sso",
            "todo-list-SPFx",
            "hello-world-in-meeting",
            "todo-list-with-Azure-backend-M365",
            "NPM-search-connector-M365",
            "bot-proactive-messaging-teamsfx",
            "adaptive-card-notification",
            "incoming-webhook-notification",
            "stocks-update-notification-bot",
            "query-org-user-with-message-extension-sso",
            "team-central-dashboard",
            "graph-connector-app",
            "graph-toolkit-one-productivity-hub",
            "todo-list-with-Azure-backend",
            "share-now",
            "hello-world-teams-tab-and-outlook-add-in",
            "outlook-add-in-set-signature",
            "developer-assist-dashboard",
            "live-share-dice-roller",
            "teams-chef-bot",
            "spfx-productivity-dashboard",
            "react-retail-dashboard",
            "sso-enabled-tab-via-apim-proxy",
            "large-scale-notification",
            "graph-connector-bot",
        ],
        dynamicOptions: async () => {
            return (await samples_1.sampleProvider.SampleCollection).samples.map((sample) => {
                return {
                    id: sample.id,
                    label: sample.title,
                    description: `${sample.time} â€¢ ${sample.configuration}`,
                    detail: sample.shortDescription,
                };
            });
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.SampleSelect.placeholder"),
        buttons: [
            {
                icon: "library",
                tooltip: (0, localizeUtils_1.getLocalizedString)("core.SampleSelect.buttons.viewSamples"),
                command: "fx-extension.openSamples",
            },
        ],
    };
}
function runtimeQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.Runtime,
        title: (0, localizeUtils_1.getLocalizedString)("core.getRuntimeQuestion.title"),
        staticOptions: [constants_3.RuntimeOptions.NodeJS(), constants_3.RuntimeOptions.DotNet()],
        default: constants_3.RuntimeOptions.NodeJS().id,
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.getRuntimeQuestion.placeholder"),
        cliHidden: true,
    };
}
const defaultTabLocalHostUrl = "https://localhost:53000/index.html#/tab";
const tabContentUrlOptionItem = (tab) => {
    return {
        id: tab.name,
        label: tab.name,
        detail: (0, localizeUtils_1.getLocalizedString)("core.updateContentUrlOption.description", tab.contentUrl, defaultTabLocalHostUrl),
    };
};
const tabWebsiteUrlOptionItem = (tab) => {
    return {
        id: tab.name,
        label: tab.name,
        detail: (0, localizeUtils_1.getLocalizedString)("core.updateWebsiteUrlOption.description", tab.websiteUrl, defaultTabLocalHostUrl),
    };
};
function getTabWebsiteOptions(inputs) {
    const appDefinition = inputs.teamsAppFromTdp;
    if (appDefinition === null || appDefinition === void 0 ? void 0 : appDefinition.staticTabs) {
        const tabsWithWebsiteUrls = appDefinition.staticTabs.filter((o) => !!o.websiteUrl);
        if (tabsWithWebsiteUrls.length > 0) {
            return tabsWithWebsiteUrls.map((o) => tabWebsiteUrlOptionItem(o));
        }
    }
    return [];
}
function selectTabWebsiteUrlQuestion() {
    return {
        type: "multiSelect",
        name: constants_3.QuestionNames.ReplaceWebsiteUrl,
        title: (0, localizeUtils_1.getLocalizedString)("core.updateWebsiteUrlQuestion.title"),
        staticOptions: [],
        dynamicOptions: getTabWebsiteOptions,
        default: (inputs) => {
            const options = getTabWebsiteOptions(inputs);
            return options.map((o) => o.id);
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.updateUrlQuestion.placeholder"),
        forgetLastValue: true,
    };
}
function getTabContentUrlOptions(inputs) {
    const appDefinition = inputs.teamsAppFromTdp;
    if (appDefinition === null || appDefinition === void 0 ? void 0 : appDefinition.staticTabs) {
        const tabsWithContentUrls = appDefinition.staticTabs.filter((o) => !!o.contentUrl);
        if (tabsWithContentUrls.length > 0) {
            return tabsWithContentUrls.map((o) => tabContentUrlOptionItem(o));
        }
    }
    return [];
}
const selectTabsContentUrlQuestion = () => {
    return {
        type: "multiSelect",
        name: constants_3.QuestionNames.ReplaceContentUrl,
        title: (0, localizeUtils_1.getLocalizedString)("core.updateContentUrlQuestion.title"),
        staticOptions: [],
        dynamicOptions: getTabContentUrlOptions,
        default: (inputs) => {
            const options = getTabContentUrlOptions(inputs);
            return options.map((o) => o.id);
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.updateUrlQuestion.placeholder"),
        forgetLastValue: true,
    };
};
const answerToRepaceBotId = "bot";
const answerToReplaceMessageExtensionBotId = "messageExtension";
const botOptionItem = (isMessageExtension, botId) => {
    return {
        id: isMessageExtension ? answerToReplaceMessageExtensionBotId : answerToRepaceBotId,
        label: isMessageExtension
            ? (0, localizeUtils_1.getLocalizedString)("core.updateBotIdForMessageExtension.label")
            : (0, localizeUtils_1.getLocalizedString)("core.updateBotIdForBot.label"),
        detail: isMessageExtension
            ? (0, localizeUtils_1.getLocalizedString)("core.updateBotIdForMessageExtension.description", botId)
            : (0, localizeUtils_1.getLocalizedString)("core.updateBotIdForBot.description", botId),
    };
};
function getBotIdAndMeId(appDefinition) {
    const bots = appDefinition.bots;
    const messageExtensions = appDefinition.messagingExtensions;
    // can add only one bot. If existing, the length is 1.
    const botId = !!bots && bots.length > 0 ? bots[0].botId : undefined;
    // can add only one message extension. If existing, the length is 1.
    const messageExtensionId = !!messageExtensions && messageExtensions.length > 0 ? messageExtensions[0].botId : undefined;
    return [botId, messageExtensionId];
}
function getBotOptions(inputs) {
    const appDefinition = inputs.teamsAppFromTdp;
    if (!appDefinition)
        return [];
    const [botId, messageExtensionId] = getBotIdAndMeId(appDefinition);
    const options = [];
    if (botId) {
        options.push(botOptionItem(false, botId));
    }
    if (messageExtensionId) {
        options.push(botOptionItem(true, messageExtensionId));
    }
    return options;
}
function selectBotIdsQuestion() {
    // const statcOptions: OptionItem[] = [];
    // statcOptions.push(botOptionItem(false, "000000-0000-0000"));
    // statcOptions.push(botOptionItem(true, "000000-0000-0000"));
    return {
        type: "multiSelect",
        name: constants_3.QuestionNames.ReplaceBotIds,
        title: (0, localizeUtils_1.getLocalizedString)("core.updateBotIdsQuestion.title"),
        staticOptions: [],
        dynamicOptions: getBotOptions,
        default: (inputs) => {
            const options = getBotOptions(inputs);
            return options.map((o) => o.id);
        },
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.updateBotIdsQuestion.placeholder"),
        forgetLastValue: true,
    };
}
const maximumLengthOfDetailsErrorMessageInInputBox = 90;
function apiSpecLocationQuestion(includeExistingAPIs = true) {
    const correlationId = correlator_1.Correlator.getId(); // This is a workaround for VSCode which will lose correlation id when user accepts the value.
    const validationOnAccept = async (input, inputs) => {
        try {
            if (!inputs) {
                throw new Error("inputs is undefined"); // should never happen
            }
            const context = (0, globalVars_1.createContext)();
            const res = await (0, helper_1.listOperations)(context, input.trim(), inputs, includeExistingAPIs, false, inputs.platform === teamsfx_api_1.Platform.VSCode ? correlationId : undefined);
            if (res.isOk()) {
                inputs.supportedApisFromApiSpec = res.value;
            }
            else {
                const errors = res.error;
                if (inputs.platform === teamsfx_api_1.Platform.CLI) {
                    return errors.map((e) => e.content).join("\n");
                }
                if (errors.length === 1 &&
                    errors[0].content.length <= maximumLengthOfDetailsErrorMessageInInputBox) {
                    return errors[0].content;
                }
                else {
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.multipleValidationErrors.vscode.message");
                }
            }
        }
        catch (e) {
            const error = (0, error_2.assembleError)(e);
            throw error;
        }
    };
    return {
        type: "singleFileOrText",
        name: constants_3.QuestionNames.ApiSpecLocation,
        cliShortName: "a",
        cliDescription: "OpenAPI description document location.",
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.title"),
        forgetLastValue: true,
        inputBoxConfig: {
            type: "innerText",
            title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.title"),
            placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.placeholder"),
            name: "input-api-spec-url",
            step: 2,
            validation: {
                validFunc: (input, inputs) => {
                    const result = (0, stringUtils_1.isValidHttpUrl)(input.trim())
                        ? undefined
                        : (inputs === null || inputs === void 0 ? void 0 : inputs.platform) === teamsfx_api_1.Platform.CLI
                            ? "Please enter a valid HTTP URL to access your OpenAPI description document or enter a file path of your local OpenAPI description document."
                            : (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.invalidUrl.message");
                    return Promise.resolve(result);
                },
            },
        },
        inputOptionItem: {
            id: "input",
            label: `$(cloud) ` + (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpecInputUrl.label"),
        },
        filters: {
            files: ["json", "yml", "yaml"],
        },
        validation: {
            validFunc: async (input, inputs) => {
                if (!(0, stringUtils_1.isValidHttpUrl)(input.trim()) && !(await fs_extra_1.default.pathExists(input.trim()))) {
                    return "Please enter a valid HTTP URL without authentication to access your OpenAPI description document or enter a file path of your local OpenAPI description document.";
                }
                return await validationOnAccept(input, inputs);
            },
        },
    };
}
exports.apiSpecLocationQuestion = apiSpecLocationQuestion;
function apiAuthQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.ApiAuth,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiMessageExtensionAuth.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiMessageExtensionAuth.placeholder"),
        cliDescription: "The authentication type for the API.",
        staticOptions: constants_3.ApiAuthOptions.all(),
        dynamicOptions: (inputs) => {
            const options = [constants_3.ApiAuthOptions.none()];
            if (inputs[constants_3.QuestionNames.MeArchitectureType] === constants_3.MeArchitectureOptions.newApi().id) {
                options.push(constants_3.ApiAuthOptions.apiKey(), constants_3.ApiAuthOptions.microsoftEntra());
            }
            else if (inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.newApi().id) {
                options.push(constants_3.ApiAuthOptions.apiKey());
                if (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.ApiPluginAAD)) {
                    options.push(constants_3.ApiAuthOptions.microsoftEntra());
                }
                options.push(constants_3.ApiAuthOptions.oauth());
            }
            return options;
        },
        default: constants_3.ApiAuthOptions.none().id,
    };
}
exports.apiAuthQuestion = apiAuthQuestion;
function apiOperationQuestion(includeExistingAPIs = true, isAddPlugin = false) {
    // export for unit test
    let placeholder = "";
    const isPlugin = (inputs) => {
        return (isAddPlugin ||
            (!!inputs && inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id));
    };
    return {
        type: "multiSelect",
        name: constants_3.QuestionNames.ApiOperation,
        title: (inputs) => {
            return isPlugin(inputs)
                ? (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.copilotOperation.title")
                : (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.title");
        },
        cliDescription: isAddPlugin
            ? "Select operation(s) Copilot can interact with."
            : "Select operation(s) Teams can interact with.",
        cliShortName: "o",
        placeholder: (inputs) => {
            const isPlugin = inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id;
            if (!includeExistingAPIs) {
                placeholder = (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.placeholder.skipExisting");
            }
            else if (isPlugin) {
                placeholder = (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.plugin.placeholder");
            }
            else {
                placeholder = (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.apikey.placeholder");
            }
            return placeholder;
        },
        forgetLastValue: true,
        staticOptions: [],
        validation: {
            validFunc: (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                if (input.length < 1 ||
                    (input.length > 10 &&
                        inputs[constants_3.QuestionNames.CustomCopilotRag] !== constants_3.CustomCopilotRagOptions.customApi().id &&
                        inputs[constants_3.QuestionNames.ProjectType] !== constants_3.ProjectTypeOptions.copilotExtension().id)) {
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.invalidMessage", input.length, 10);
                }
                const operations = inputs.supportedApisFromApiSpec;
                const authNames = new Set();
                const serverUrls = new Set();
                for (const inputItem of input) {
                    const operation = operations.find((op) => op.id === inputItem);
                    if (operation) {
                        if (operation.data.authName) {
                            authNames.add(operation.data.authName);
                            serverUrls.add(operation.data.serverUrl);
                        }
                    }
                }
                if (authNames.size > 1) {
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.multipleAuth", Array.from(authNames).join(", "));
                }
                if (serverUrls.size > 1) {
                    return (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.apiSpec.operation.multipleServer", Array.from(serverUrls).join(", "));
                }
                const authApi = operations.find((api) => !!api.data.authName && input.includes(api.id));
                if (authApi) {
                    inputs.apiAuthData = authApi.data;
                }
            },
        },
        dynamicOptions: (inputs) => {
            if (!inputs.supportedApisFromApiSpec) {
                throw new error_2.EmptyOptionError(constants_3.QuestionNames.ApiOperation, "question");
            }
            const operations = inputs.supportedApisFromApiSpec;
            return operations;
        },
    };
}
exports.apiOperationQuestion = apiOperationQuestion;
function customCopilotRagQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.CustomCopilotRag,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.customCopilotRag.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.customCopilotRag.placeholder"),
        staticOptions: constants_3.CustomCopilotRagOptions.all(),
        dynamicOptions: () => constants_3.CustomCopilotRagOptions.all(),
        default: constants_3.CustomCopilotRagOptions.customize().id,
    };
}
function customCopilotAssistantQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.CustomCopilotAssistant,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.customCopilotAssistant.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.capability.customCopilotAssistant.placeholder"),
        staticOptions: constants_3.CustomCopilotAssistantOptions.all(),
        dynamicOptions: () => constants_3.CustomCopilotAssistantOptions.all(),
        default: constants_3.CustomCopilotAssistantOptions.new().id,
    };
}
function llmServiceQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.LLMService,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.placeholder"),
        staticOptions: [
            {
                id: "llm-service-azure-openai",
                cliName: "azure-openai",
                label: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceAzureOpenAIOption.label"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceAzureOpenAIOption.detail"),
            },
            {
                id: "llm-service-openai",
                label: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceOpenAIOption.label"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceOpenAIOption.detail"),
            },
        ],
        dynamicOptions: (inputs) => {
            const options = [];
            options.push({
                id: "llm-service-azure-openai",
                label: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceAzureOpenAIOption.label"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceAzureOpenAIOption.detail"),
            }, {
                id: "llm-service-openai",
                label: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceOpenAIOption.label"),
                detail: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmServiceOpenAIOption.detail"),
            });
            return options;
        },
        skipSingleOption: true,
        default: "llm-service-azure-openai",
    };
}
function openAIKeyQuestion() {
    return {
        type: "text",
        password: true,
        name: constants_3.QuestionNames.OpenAIKey,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.openAIKey.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.openAIKey.placeholder"),
    };
}
function azureOpenAIKeyQuestion() {
    return {
        type: "text",
        password: true,
        name: constants_3.QuestionNames.AzureOpenAIKey,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIKey.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIKey.placeholder"),
    };
}
function azureOpenAIEndpointQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.AzureOpenAIEndpoint,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIEndpoint.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIEndpoint.placeholder"),
    };
}
function azureOpenAIDeploymentNameQuestion() {
    return {
        type: "text",
        name: constants_3.QuestionNames.AzureOpenAIDeploymentName,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIDeploymentName.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.llmService.azureOpenAIDeploymentName.placeholder"),
    };
}
function declarativeCopilotPluginQuestion() {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.WithPlugin,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.declarativeCopilot.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.declarativeCopilot.placeholder"),
        cliDescription: "Whether to add API plugin for your declarative Copilot.",
        staticOptions: constants_3.DeclarativeCopilotTypeOptions.all(),
        default: constants_3.DeclarativeCopilotTypeOptions.noPlugin().id,
    };
}
function apiPluginStartQuestion(doesProjectExists) {
    return {
        type: "singleSelect",
        name: constants_3.QuestionNames.ApiPluginType,
        title: (inputs) => {
            return inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.declarativeCopilot().id ||
                doesProjectExists
                ? (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addApiPlugin.title")
                : (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.createApiPlugin.title");
        },
        placeholder: (inputs) => {
            return inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.declarativeCopilot().id ||
                doesProjectExists
                ? (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addApiPlugin.placeholder")
                : (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.projectType.copilotExtension.placeholder");
        },
        cliDescription: "API plugin type.",
        staticOptions: constants_3.ApiPluginStartOptions.staticAll(doesProjectExists),
        dynamicOptions: (inputs) => {
            return constants_3.ApiPluginStartOptions.all(inputs, doesProjectExists);
        },
        default: constants_3.ApiPluginStartOptions.newApi().id,
    };
}
exports.apiPluginStartQuestion = apiPluginStartQuestion;
function pluginManifestQuestion() {
    const correlationId = correlator_1.Correlator.getId();
    return {
        type: "singleFile",
        name: constants_3.QuestionNames.PluginManifestFilePath,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addExistingPlugin.pluginManifest.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addExistingPlugin.pluginManifest.placeholder"),
        cliDescription: "Plugin manifest path.",
        filters: {
            files: ["json"],
        },
        defaultFolder: (inputs) => teamsfx_api_1.CLIPlatforms.includes(inputs.platform) ? "./" : os.homedir(),
        validation: {
            validFunc: async (input) => {
                const manifestRes = await PluginManifestUtils_1.pluginManifestUtils.readPluginManifestFile(input.trim());
                if (manifestRes.isErr()) {
                    (0, telemetry_1.sendTelemetryErrorEvent)(error_2.CoreSource, (0, telemetry_1.getQuestionValidationErrorEventName)(constants_3.QuestionNames.PluginManifestFilePath), manifestRes.error, {
                        "correlation-id": correlationId,
                    });
                    return manifestRes.error.displayMessage;
                }
                else {
                    const manifest = manifestRes.value;
                    const checkRes = (0, helper_2.validateSourcePluginManifest)(manifest, constants_3.QuestionNames.PluginManifestFilePath);
                    if (checkRes.isErr()) {
                        (0, telemetry_1.sendTelemetryErrorEvent)(error_2.CoreSource, (0, telemetry_1.getQuestionValidationErrorEventName)(constants_3.QuestionNames.PluginManifestFilePath), checkRes.error, {
                            "correlation-id": correlationId,
                        });
                        return checkRes.error.displayMessage;
                    }
                }
            },
        },
    };
}
exports.pluginManifestQuestion = pluginManifestQuestion;
function pluginApiSpecQuestion() {
    const correlationId = correlator_1.Correlator.getId();
    return {
        type: "singleFile",
        name: constants_3.QuestionNames.PluginOpenApiSpecFilePath,
        title: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addExistingPlugin.apiSpec.title"),
        placeholder: (0, localizeUtils_1.getLocalizedString)("core.createProjectQuestion.addExistingPlugin.openApiSpec.placeholder"),
        cliDescription: "OpenAPI description document used for your API plugin.",
        filters: {
            files: ["json", "yml", "yaml"],
        },
        defaultFolder: (inputs) => teamsfx_api_1.CLIPlatforms.includes(inputs.platform)
            ? "./"
            : path.dirname(inputs[constants_3.QuestionNames.PluginManifestFilePath]),
        validation: {
            validFunc: async (input, inputs) => {
                if (!inputs) {
                    throw new Error("inputs is undefined"); // should never happen
                }
                const filePath = input.trim();
                const ext = path.extname(filePath).toLowerCase();
                if (![".json", ".yml", ".yaml"].includes(ext)) {
                    const error = new error_2.FileNotSupportError(error_2.CoreSource, ["json", "yml", "yaml"].join(", "));
                    (0, telemetry_1.sendTelemetryErrorEvent)(error_2.CoreSource, (0, telemetry_1.getQuestionValidationErrorEventName)(constants_3.QuestionNames.PluginOpenApiSpecFilePath), error, {
                        "correlation-id": correlationId,
                    });
                    return error.displayMessage;
                }
                const specParser = new m365_spec_parser_1.SpecParser(filePath, (0, helper_1.getParserOptions)(m365_spec_parser_1.ProjectType.Copilot));
                const validationRes = await specParser.validate();
                const invalidSpecError = validationRes.errors.find((o) => o.type === m365_spec_parser_1.ErrorType.SpecNotValid);
                if (invalidSpecError) {
                    const error = new teamsfx_api_1.UserError(constants_1.SpecParserSource, telemetry_1.ApiSpecTelemetryPropertis.InvalidApiSpec, invalidSpecError.content, invalidSpecError.content);
                    (0, telemetry_1.sendTelemetryErrorEvent)(error_2.CoreSource, (0, telemetry_1.getQuestionValidationErrorEventName)(constants_3.QuestionNames.PluginOpenApiSpecFilePath), error, {
                        "correlation-id": correlationId,
                        [telemetry_1.ApiSpecTelemetryPropertis.SpecNotValidDetails]: invalidSpecError.content,
                    });
                }
                return invalidSpecError === null || invalidSpecError === void 0 ? void 0 : invalidSpecError.content;
            },
        },
    };
}
exports.pluginApiSpecQuestion = pluginApiSpecQuestion;
function capabilitySubTree() {
    const node = {
        data: capabilityQuestion(),
        children: [
            {
                // Notification bot trigger sub-tree
                condition: { equals: constants_3.CapabilityOptions.notificationBot().id },
                data: botTriggerQuestion(),
            },
            {
                // SPFx sub-tree
                condition: { equals: constants_3.CapabilityOptions.SPFxTab().id },
                data: SPFxSolutionQuestion(),
                children: [
                    {
                        data: { type: "group" },
                        children: [
                            { data: SPFxPackageSelectQuestion() },
                            { data: SPFxFrameworkQuestion() },
                            { data: SPFxWebpartNameQuestion() },
                        ],
                        condition: { equals: "new" },
                    },
                    {
                        data: SPFxImportFolderQuestion(),
                        condition: { equals: "import" },
                    },
                ],
            },
            {
                // office addin import sub-tree (capabilities=office-addin-import | outlook-addin-import)
                condition: {
                    enum: [
                        constants_3.CapabilityOptions.outlookAddinImport().id,
                        constants_3.CapabilityOptions.officeAddinImport().id,
                    ],
                },
                data: { type: "group", name: constants_3.QuestionNames.OfficeAddinImport },
                children: [
                    {
                        data: {
                            type: "folder",
                            name: constants_3.QuestionNames.OfficeAddinFolder,
                            title: "Existing add-in project folder",
                        },
                    },
                    {
                        data: {
                            type: "singleFile",
                            name: constants_3.QuestionNames.OfficeAddinManifest,
                            title: "Select import project manifest file",
                        },
                    },
                ],
            },
            {
                // Search ME sub-tree
                condition: { equals: constants_3.CapabilityOptions.m365SearchMe().id },
                data: meArchitectureQuestion(),
            },
            {
                condition: { equals: constants_3.CapabilityOptions.declarativeCopilot().id },
                data: declarativeCopilotPluginQuestion(),
            },
            {
                condition: (inputs) => {
                    return (inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.apiPlugin().id ||
                        inputs[constants_3.QuestionNames.WithPlugin] === constants_3.DeclarativeCopilotTypeOptions.withPlugin().id);
                },
                data: apiPluginStartQuestion(),
            },
            {
                condition: (inputs) => {
                    return inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.existingPlugin().id;
                },
                data: { type: "group", name: constants_3.QuestionNames.ImportPlugin },
                children: [
                    {
                        data: pluginManifestQuestion(),
                    },
                    {
                        data: pluginApiSpecQuestion(),
                    },
                ],
            },
            {
                condition: (inputs) => {
                    return (inputs[constants_3.QuestionNames.MeArchitectureType] == constants_3.MeArchitectureOptions.newApi().id ||
                        inputs[constants_3.QuestionNames.ApiPluginType] == constants_3.ApiPluginStartOptions.newApi().id);
                },
                data: apiAuthQuestion(),
            },
            {
                condition: (inputs) => {
                    return inputs[constants_3.QuestionNames.Capabilities] == constants_3.CapabilityOptions.customCopilotRag().id;
                },
                data: customCopilotRagQuestion(),
            },
            {
                // from API spec
                condition: (inputs) => {
                    return ((inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id ||
                        inputs[constants_3.QuestionNames.MeArchitectureType] === constants_3.MeArchitectureOptions.apiSpec().id ||
                        inputs[constants_3.QuestionNames.CustomCopilotRag] === constants_3.CustomCopilotRagOptions.customApi().id) &&
                        !(
                        // Only skip this project when need to rediect to Kiota: 1. Feature flag enabled 2. Creating plugin/declarative copilot from existing spec
                        (featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
                            inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id &&
                            (inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.apiPlugin().id ||
                                inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.declarativeCopilot().id))));
                },
                data: { type: "group", name: constants_3.QuestionNames.FromExistingApi },
                children: [
                    {
                        data: apiSpecLocationQuestion(),
                    },
                    {
                        data: apiOperationQuestion(),
                        condition: (inputs) => {
                            return !inputs[constants_3.QuestionNames.ApiPluginManifestPath];
                        },
                    },
                ],
            },
            {
                condition: (inputs) => {
                    return (inputs[constants_3.QuestionNames.Capabilities] == constants_3.CapabilityOptions.customCopilotAssistant().id);
                },
                data: customCopilotAssistantQuestion(),
            },
            {
                // programming language
                data: programmingLanguageQuestion(),
                condition: (inputs) => {
                    return ((!!inputs[constants_3.QuestionNames.Capabilities] &&
                        inputs[constants_3.QuestionNames.WithPlugin] !== constants_3.DeclarativeCopilotTypeOptions.noPlugin().id &&
                        inputs[constants_3.QuestionNames.ApiPluginType] !== constants_3.ApiPluginStartOptions.apiSpec().id &&
                        inputs[constants_3.QuestionNames.ApiPluginType] !== constants_3.ApiPluginStartOptions.existingPlugin().id &&
                        inputs[constants_3.QuestionNames.MeArchitectureType] !== constants_3.MeArchitectureOptions.apiSpec().id &&
                        inputs[constants_3.QuestionNames.Capabilities] !== constants_3.CapabilityOptions.officeAddinImport().id &&
                        inputs[constants_3.QuestionNames.Capabilities] !== constants_3.CapabilityOptions.outlookAddinImport().id) ||
                        (0, constants_3.getRuntime)(inputs) === constants_3.RuntimeOptions.DotNet().id);
                },
            },
            {
                condition: (inputs) => {
                    return (inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.customCopilotBasic().id ||
                        inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.customCopilotRag().id ||
                        inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.customCopilotAssistant().id);
                },
                data: llmServiceQuestion(),
                children: [
                    {
                        condition: { equals: "llm-service-azure-openai" },
                        data: azureOpenAIKeyQuestion(),
                        children: [
                            {
                                condition: (inputs) => {
                                    var _a;
                                    return ((_a = inputs[constants_3.QuestionNames.AzureOpenAIKey]) === null || _a === void 0 ? void 0 : _a.length) > 0;
                                },
                                data: azureOpenAIEndpointQuestion(),
                                children: [
                                    {
                                        condition: (inputs) => {
                                            var _a;
                                            return ((_a = inputs[constants_3.QuestionNames.AzureOpenAIEndpoint]) === null || _a === void 0 ? void 0 : _a.length) > 0;
                                        },
                                        data: azureOpenAIDeploymentNameQuestion(),
                                    },
                                ],
                            },
                        ],
                    },
                    {
                        condition: { equals: "llm-service-openai" },
                        data: openAIKeyQuestion(),
                    },
                ],
            },
            {
                // Office addin framework for json manifest
                data: officeAddinFrameworkQuestion(),
                condition: (inputs) => {
                    return (inputs[constants_3.QuestionNames.ProjectType] === constants_3.ProjectTypeOptions.officeAddin().id &&
                        inputs[constants_3.QuestionNames.Capabilities] !== constants_3.CapabilityOptions.officeAddinImport().id);
                },
            },
            {
                // root folder
                data: folderQuestion(),
                condition: (inputs) => {
                    // Only skip this project when need to rediect to Kiota: 1. Feature flag enabled 2. Creating plugin/declarative copilot from existing spec 3. No plugin manifest path
                    return !(featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
                        inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id &&
                        (inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.apiPlugin().id ||
                            inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.declarativeCopilot().id) &&
                        !inputs[constants_3.QuestionNames.ApiPluginManifestPath]);
                },
            },
            {
                // app name
                data: appNameQuestion(),
                condition: (inputs) => {
                    // Only skip this project when need to rediect to Kiota: 1. Feature flag enabled 2. Creating plugin/declarative copilot from existing spec 3. No plugin manifest path
                    return !(featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.KiotaIntegration) &&
                        inputs[constants_3.QuestionNames.ApiPluginType] === constants_3.ApiPluginStartOptions.apiSpec().id &&
                        (inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.apiPlugin().id ||
                            inputs[constants_3.QuestionNames.Capabilities] === constants_3.CapabilityOptions.declarativeCopilot().id) &&
                        !inputs[constants_3.QuestionNames.ApiPluginManifestPath]);
                },
            },
        ],
        condition: (inputs) => {
            return inputs[constants_3.QuestionNames.ProjectType] !== constants_3.ProjectTypeOptions.startWithGithubCopilot().id;
        },
    };
    return node;
}
exports.capabilitySubTree = capabilitySubTree;
function createProjectQuestionNode() {
    const createProjectQuestion = {
        data: { type: "group" },
        children: [
            {
                condition: (inputs) => featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.CLIDotNet) &&
                    teamsfx_api_1.CLIPlatforms.includes(inputs.platform),
                data: runtimeQuestion(),
            },
            {
                condition: (inputs) => inputs.platform === teamsfx_api_1.Platform.VSCode || inputs.platform === teamsfx_api_1.Platform.CLI,
                data: projectTypeQuestion(),
                cliOptionDisabled: "self",
            },
            capabilitySubTree(),
            {
                condition: (inputs) => inputs.teamsAppFromTdp && (0, utils_1.isPersonalApp)(inputs.teamsAppFromTdp),
                data: { type: "group", name: constants_3.QuestionNames.RepalceTabUrl },
                cliOptionDisabled: "all",
                inputsDisabled: "all",
                children: [
                    {
                        condition: (inputs) => {
                            var _a;
                            return (((_a = inputs.teamsAppFromTdp) === null || _a === void 0 ? void 0 : _a.staticTabs.filter((o) => !!o.websiteUrl)) || []).length >
                                0;
                        },
                        data: selectTabWebsiteUrlQuestion(),
                    },
                    {
                        condition: (inputs) => {
                            var _a;
                            return (((_a = inputs.teamsAppFromTdp) === null || _a === void 0 ? void 0 : _a.staticTabs.filter((o) => !!o.contentUrl)) || []).length >
                                0;
                        },
                        data: selectTabsContentUrlQuestion(),
                    },
                ],
            },
            {
                condition: (inputs) => {
                    const appDef = inputs.teamsAppFromTdp;
                    return appDef && (0, utils_1.needBotCode)(appDef);
                },
                data: selectBotIdsQuestion(),
                cliOptionDisabled: "all",
                inputsDisabled: "all",
            },
        ],
    };
    return createProjectQuestion;
}
exports.createProjectQuestionNode = createProjectQuestionNode;
function createSampleProjectQuestionNode() {
    return {
        data: sampleSelectQuestion(),
        children: [
            {
                data: folderQuestion(),
            },
        ],
    };
}
exports.createSampleProjectQuestionNode = createSampleProjectQuestionNode;
function createProjectCliHelpNode() {
    const node = (0, lodash_1.cloneDeep)(createProjectQuestionNode());
    const deleteNames = [
        constants_3.QuestionNames.ProjectType,
        constants_3.QuestionNames.OfficeAddinImport,
        constants_3.QuestionNames.OfficeAddinHost,
        constants_3.QuestionNames.RepalceTabUrl,
        constants_3.QuestionNames.ReplaceBotIds,
        constants_3.QuestionNames.Samples,
    ];
    if (!featureFlags_1.featureFlagManager.getBooleanValue(featureFlags_1.FeatureFlags.CLIDotNet)) {
        deleteNames.push(constants_3.QuestionNames.Runtime);
    }
    trimQuestionTreeForCliHelp(node, deleteNames);
    return node;
}
exports.createProjectCliHelpNode = createProjectCliHelpNode;
function trimQuestionTreeForCliHelp(node, deleteNames) {
    if (node.children) {
        node.children = node.children.filter((child) => !child.data.name || !deleteNames.includes(child.data.name));
        for (const child of node.children) {
            trimQuestionTreeForCliHelp(child, deleteNames);
        }
    }
}
function pickSubTree(node, name) {
    if (node.data.name === name) {
        return node;
    }
    let found;
    if (node.children) {
        for (const child of node.children) {
            found = pickSubTree(child, name);
            if (found)
                return found;
        }
    }
    return undefined;
}
//# sourceMappingURL=create.js.map
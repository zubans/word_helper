"use strict";
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
Object.defineProperty(exports, "__esModule", { value: true });
exports.teamsDevPortalClient = exports.TeamsDevPortalClient = exports.RetryHandler = void 0;
const tslib_1 = require("tslib");
const hooks_1 = require("@feathersjs/hooks");
const teamsfx_api_1 = require("@microsoft/teamsfx-api");
const constants_1 = require("../common/constants");
const globalVars_1 = require("../common/globalVars");
const localizeUtils_1 = require("../common/localizeUtils");
const telemetry_1 = require("../common/telemetry");
const wrappedAxiosClient_1 = require("../common/wrappedAxiosClient");
const commonConstant_1 = require("../component/constant/commonConstant");
const constants_2 = require("../component/driver/teamsApp/constants");
const errors_1 = require("../component/driver/teamsApp/errors");
const ManifestUtils_1 = require("../component/driver/teamsApp/utils/ManifestUtils");
const IBotRegistration_1 = require("../component/resource/botService/appStudio/interfaces/IBotRegistration");
const common_1 = require("../component/resource/botService/common");
const constants_3 = require("../component/resource/botService/constants");
const errors_2 = require("../component/resource/botService/errors");
const messages_1 = require("../component/resource/botService/messages");
const strings_1 = require("../component/resource/botService/strings");
const teamsApp_1 = require("../error/teamsApp");
class RetryHandler {
    static async Retry(fn) {
        var _a, _b;
        let retries = this.RETRIES;
        let response;
        while (retries > 0) {
            retries = retries - 1;
            try {
                response = await fn();
                return response;
            }
            catch (e) {
                // Directly throw 404 error, keep trying for other status code e.g. 503 400
                if (retries <= 0 || ((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) == 404 || ((_b = e.response) === null || _b === void 0 ? void 0 : _b.status) == 409) {
                    throw e;
                }
                else {
                    await new Promise((resolve) => setTimeout(resolve, 5000));
                }
            }
        }
    }
}
exports.RetryHandler = RetryHandler;
RetryHandler.RETRIES = 6;
class TeamsDevPortalClient {
    getGlobalEndpoint() {
        if (process.env.APP_STUDIO_ENV && process.env.APP_STUDIO_ENV === "int") {
            return "https://dev-int.teams.microsoft.com";
        }
        else {
            return "https://dev.teams.microsoft.com";
        }
    }
    setRegionEndpoint(regionEndpoint) {
        this.regionEndpoint = regionEndpoint;
    }
    async setRegionEndpointByToken(authSvcToken) {
        var _a, _b;
        if (this.getGlobalEndpoint() === "https://dev-int.teams.microsoft.com") {
            // Do not set region for INT env
            return;
        }
        const requester = wrappedAxiosClient_1.WrappedAxiosClient.create({
            baseURL: "https://authsvc.teams.microsoft.com",
        });
        requester.defaults.headers.common["Authorization"] = `Bearer ${authSvcToken}`;
        requester.defaults.headers.common["Client-Source"] = "teamstoolkit";
        const response = await RetryHandler.Retry(() => requester.post("/v1.0/users/region"));
        this.regionEndpoint = (_b = (_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a.regionGtms) === null || _b === void 0 ? void 0 : _b.teamsDevPortal;
    }
    getEndpoint() {
        return this.regionEndpoint || this.getGlobalEndpoint();
    }
    /**
     * Creates a new axios instance to call app studio to prevent setting the accessToken on global instance.
     * @param {string}  token
     * @returns {AxiosInstance}
     */
    createRequesterWithToken(token) {
        const instance = wrappedAxiosClient_1.WrappedAxiosClient.create({
            baseURL: this.getEndpoint(),
        });
        instance.defaults.headers.common["Authorization"] = `Bearer ${token}`;
        instance.defaults.headers.common["Client-Source"] = "teamstoolkit";
        return instance;
    }
    /**
     * Import an app registration in app studio with the given archived file and returns the app definition.
     * @param {string}  token - access token
     * @param {Buffer}  file - Zip file with manifest.json and two icons
     * @param {boolean} overwrite - whether to overrite the app if it already exists
     * @returns {Promise<AppDefinition>}
     */
    async importApp(token, file, overwrite = false) {
        var _a, _b, _c, _d, _e;
        try {
            const requester = this.createRequesterWithToken(token);
            globalVars_1.TOOLS.logProvider.debug(`Sent API Request: ${this.getEndpoint()}/api/appdefinitions/v2/import`);
            const response = await RetryHandler.Retry(() => requester.post(`/api/appdefinitions/v2/import`, file, {
                headers: { "Content-Type": "application/zip" },
                params: {
                    overwriteIfAppAlreadyExists: overwrite,
                },
            }));
            if (response && response.data) {
                const app = response.data;
                globalVars_1.TOOLS.logProvider.debug(`Received data from Teams Developer Portal: ${JSON.stringify(app)}`);
                return app;
            }
            else {
                throw this.wrapException(new Error("cannot create teams app"), constants_2.APP_STUDIO_API_NAMES.CREATE_APP);
            }
        }
        catch (e) {
            if (((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) === 409) {
                throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.CREATE_APP, errors_1.AppStudioError.TeamsAppCreateConflictError.name, errors_1.AppStudioError.TeamsAppCreateConflictError.message()[0], errors_1.AppStudioError.TeamsAppCreateConflictError.message()[1], true, constants_1.HelpLinks.SwitchTenant);
            }
            // Corner case: The provided app ID conflict with an existing published app
            // See Developer Portal PR: 507264
            if (((_b = e.response) === null || _b === void 0 ? void 0 : _b.status) == 422 &&
                ((_c = e.response) === null || _c === void 0 ? void 0 : _c.data.includes("App already exists and published"))) {
                throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.CREATE_APP, errors_1.AppStudioError.TeamsAppCreateConflictWithPublishedAppError.name, errors_1.AppStudioError.TeamsAppCreateConflictWithPublishedAppError.message()[0], errors_1.AppStudioError.TeamsAppCreateConflictWithPublishedAppError.message()[1], true);
            }
            // Corner case: App Id must be a GUID
            if (((_d = e.response) === null || _d === void 0 ? void 0 : _d.status) === commonConstant_1.HttpStatusCode.BAD_REQUEST &&
                ((_e = e.response) === null || _e === void 0 ? void 0 : _e.data.includes("App Id must be a GUID"))) {
                const manifest = ManifestUtils_1.manifestUtils.extractManifestFromArchivedFile(file);
                if (manifest.isErr()) {
                    throw manifest.error;
                }
                else {
                    const teamsAppId = manifest.value.id;
                    throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.CREATE_APP, errors_1.AppStudioError.InvalidTeamsAppIdError.name, errors_1.AppStudioError.InvalidTeamsAppIdError.message(teamsAppId)[0], errors_1.AppStudioError.InvalidTeamsAppIdError.message(teamsAppId)[1], true);
                }
            }
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.CREATE_APP);
        }
    }
    async listApps(token) {
        if (!this.regionEndpoint)
            throw new Error("Failed to get region");
        let requester;
        try {
            requester = this.createRequesterWithToken(token);
            globalVars_1.TOOLS.logProvider.debug(`Sent API Request: GET ${this.regionEndpoint}/api/appdefinitions`);
            const response = await RetryHandler.Retry(() => requester.get(`/api/appdefinitions`));
            const apps = response === null || response === void 0 ? void 0 : response.data;
            if (apps) {
                return apps;
            }
            else {
                globalVars_1.TOOLS.logProvider.error("Cannot get the app definitions");
            }
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.LIST_APPS);
        }
        throw this.wrapException(new Error("cannot get the app definitions"), constants_2.APP_STUDIO_API_NAMES.LIST_APPS);
    }
    async deleteApp(appStudioToken, teamsAppId) {
        var _a;
        if (!this.regionEndpoint)
            throw new Error("Failed to get region");
        let requester;
        try {
            requester = this.createRequesterWithToken(appStudioToken);
            globalVars_1.TOOLS.logProvider.debug(`Sent API Request: DELETE ${this.getEndpoint()}/api/appdefinitions/${teamsAppId}`);
            const response = await RetryHandler.Retry(() => requester.delete(`/api/appdefinitions/${teamsAppId}`));
            if (response && response.data) {
                const success = response.data;
                if (success) {
                    return success;
                }
                else {
                    (_a = globalVars_1.TOOLS.logProvider) === null || _a === void 0 ? void 0 : _a.error("Cannot get the app definitions");
                }
            }
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.DELETE_APP);
        }
        throw this.wrapException(new Error("cannot delete the app: " + teamsAppId), constants_2.APP_STUDIO_API_NAMES.DELETE_APP);
    }
    async getApp(token, teamsAppId) {
        var _a;
        let requester;
        try {
            requester = this.createRequesterWithToken(token);
            globalVars_1.TOOLS.logProvider.debug(`Sent API Request: GET ${this.getEndpoint()}/api/appdefinitions/${teamsAppId}`);
            const response = await RetryHandler.Retry(() => requester.get(`/api/appdefinitions/${teamsAppId}`));
            if (response && response.data) {
                const app = response.data;
                if (app && app.teamsAppId && app.teamsAppId === teamsAppId) {
                    return app;
                }
                else {
                    (_a = globalVars_1.TOOLS.logProvider) === null || _a === void 0 ? void 0 : _a.error(`teamsAppId mismatch. Input: ${teamsAppId}. Got: ${app.teamsAppId}`);
                }
            }
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.GET_APP);
        }
        throw this.wrapException(new Error(`cannot get the app definition with app ID ${teamsAppId}`), constants_2.APP_STUDIO_API_NAMES.GET_APP);
    }
    async getBotId(token, teamsAppId) {
        var _a, _b;
        const app = await this.getApp(token, teamsAppId);
        if (((_a = app === null || app === void 0 ? void 0 : app.bots) === null || _a === void 0 ? void 0 : _a.length) && app.bots.length > 0) {
            return app.bots[0].botId;
        }
        (_b = globalVars_1.TOOLS.logProvider) === null || _b === void 0 ? void 0 : _b.error(`botId not found. Input: ${teamsAppId}`);
        return undefined;
    }
    async getAppPackage(token, teamsAppId) {
        var _a, _b;
        (_a = globalVars_1.TOOLS.logProvider) === null || _a === void 0 ? void 0 : _a.info("Downloading app package for app " + teamsAppId);
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.get(`/api/appdefinitions/${teamsAppId}/manifest`));
            if (response && response.data) {
                (_b = globalVars_1.TOOLS.logProvider) === null || _b === void 0 ? void 0 : _b.info("Download app package successfully");
                return response.data;
            }
            else {
                throw this.wrapException(new Error((0, localizeUtils_1.getLocalizedString)("plugins.appstudio.emptyAppPackage", teamsAppId)), constants_2.APP_STUDIO_API_NAMES.GET_APP_PACKAGE);
            }
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.GET_APP_PACKAGE);
        }
    }
    /**
     * Check if app exists in the user's organization by the Teams app id
     * @param teamsAppId
     * @param token
     * @param logProvider
     * @returns
     */
    async checkExistsInTenant(token, teamsAppId) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.get(`/api/appdefinitions/manifest/${teamsAppId}`));
            if (response && response.data) {
                return response.data;
            }
            else {
                return false;
            }
        }
        catch (e) {
            return false;
        }
    }
    /**
     * Publish Teams app to Teams App Catalog
     */
    async publishTeamsApp(token, teamsAppId, file) {
        var _a;
        try {
            const requester = this.createRequesterWithToken(token);
            const response = await RetryHandler.Retry(() => requester.post("/api/publishing", file, {
                headers: { "Content-Type": "application/zip" },
            }));
            if (response && response.data) {
                if (response.data.error) {
                    // To avoid App Studio BadGateway error
                    // The app is actually published to app catalog.
                    if (response.data.error.code === "BadGateway") {
                        const appDefinition = await this.getStaggedApp(token, teamsAppId);
                        if (appDefinition) {
                            return appDefinition.teamsAppId;
                        }
                    }
                    // Corner case
                    // Fail if an app with the same external.id exists in the staged app entitlements
                    // App with same id already exists in the staged apps, Invoke UpdateAPI instead.
                    if (response.data.error.code == "Conflict" &&
                        ((_a = response.data.error.innerError) === null || _a === void 0 ? void 0 : _a.code) == "AppDefinitionAlreadyExists") {
                        try {
                            return await this.publishTeamsAppUpdate(token, teamsAppId, file);
                        }
                        catch (e) {
                            if (e instanceof teamsApp_1.DeveloperPortalAPIFailedSystemError) {
                                throw this.wrapException(this.wrapResponse(undefined, response), constants_2.APP_STUDIO_API_NAMES.PUBLISH_APP, errors_1.AppStudioError.TeamsAppPublishConflictError.name, errors_1.AppStudioError.TeamsAppPublishConflictError.message(teamsAppId)[0], errors_1.AppStudioError.TeamsAppPublishConflictError.message(teamsAppId)[1]);
                            }
                            else {
                                throw e;
                            }
                        }
                    }
                    throw this.wrapException(this.wrapResponse(undefined, response), constants_2.APP_STUDIO_API_NAMES.PUBLISH_APP);
                }
                else {
                    return response.data.id;
                }
            }
            else {
                throw this.wrapException(this.wrapResponse(new Error("empty response"), response), constants_2.APP_STUDIO_API_NAMES.PUBLISH_APP, errors_1.AppStudioError.TeamsAppPublishFailedError.name, errors_1.AppStudioError.TeamsAppPublishFailedError.message(teamsAppId, "POST /api/publishing")[0], errors_1.AppStudioError.TeamsAppPublishFailedError.message(teamsAppId, "POST /api/publishing")[1]);
            }
        }
        catch (e) {
            if (e instanceof teamsfx_api_1.SystemError) {
                throw e;
            }
            else {
                throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.PUBLISH_APP);
            }
        }
    }
    /**
     * Update existed publish request
     * @param teamsAppId
     * @param file
     * @param token
     * @returns
     */
    async publishTeamsAppUpdate(token, teamsAppId, file) {
        var _a, _b;
        try {
            // Get App Definition from Teams App Catalog
            const appDefinition = await this.getStaggedApp(token, teamsAppId);
            const requester = this.createRequesterWithToken(token);
            let response = null;
            if (appDefinition) {
                // update the existing app
                response = await RetryHandler.Retry(() => requester.post(`/api/publishing/${appDefinition.teamsAppId}/appdefinitions`, file, {
                    headers: { "Content-Type": "application/zip" },
                }));
            }
            else {
                throw this.wrapException(new Error("API failed"), constants_2.APP_STUDIO_API_NAMES.GET_PUBLISHED_APP, errors_1.AppStudioError.TeamsAppPublishFailedError.name, errors_1.AppStudioError.TeamsAppPublishFailedError.message(teamsAppId, `GET /api/publishing/${teamsAppId}`)[0], errors_1.AppStudioError.TeamsAppPublishFailedError.message(teamsAppId, `GET /api/publishing/${teamsAppId}`)[1]);
            }
            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
            const requestPath = `${(_a = response === null || response === void 0 ? void 0 : response.request) === null || _a === void 0 ? void 0 : _a.method} ${(_b = response === null || response === void 0 ? void 0 : response.request) === null || _b === void 0 ? void 0 : _b.path}`;
            if (response && response.data) {
                if (response.data.error || response.data.errorMessage) {
                    throw this.wrapException(this.wrapResponse(undefined, response), constants_2.APP_STUDIO_API_NAMES.UPDATE_PUBLISHED_APP);
                }
                else {
                    return response.data.teamsAppId;
                }
            }
            else {
                throw this.wrapException(new Error("empty response"), constants_2.APP_STUDIO_API_NAMES.UPDATE_PUBLISHED_APP, errors_1.AppStudioError.TeamsAppPublishFailedError.name, errors_1.AppStudioError.TeamsAppPublishFailedError.message(teamsAppId, requestPath)[0], errors_1.AppStudioError.TeamsAppPublishFailedError.message(teamsAppId, requestPath)[1]);
            }
        }
        catch (error) {
            if (error instanceof teamsApp_1.DeveloperPortalAPIFailedSystemError) {
                throw error;
            }
            else {
                throw this.wrapException(error, constants_2.APP_STUDIO_API_NAMES.UPDATE_PUBLISHED_APP);
            }
        }
    }
    /**
     * Get Stagged Teams app from tenant app catalog
     * @param teamsAppId manifest.id, which is externalId in app catalog.
     * @param token
     * @returns
     */
    async getStaggedApp(token, teamsAppId) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.get(`/api/publishing/${teamsAppId}`));
            if (response && response.data && response.data.value && response.data.value.length > 0) {
                const appdefinitions = response.data.value[0].appDefinitions.map((item) => {
                    return {
                        lastModifiedDateTime: item.lastModifiedDateTime
                            ? new Date(item.lastModifiedDateTime)
                            : null,
                        publishingState: item.publishingState,
                        teamsAppId: item.teamsAppId,
                        displayName: item.displayName,
                    };
                });
                return appdefinitions[appdefinitions.length - 1];
            }
            else {
                return undefined;
            }
        }
        catch (e) {
            return undefined;
        }
    }
    async getUserList(token, teamsAppId) {
        const app = await this.getApp(token, teamsAppId);
        return app.userList;
    }
    async checkPermission(token, teamsAppId, userObjectId) {
        let userList;
        try {
            userList = await this.getUserList(token, teamsAppId);
        }
        catch (error) {
            return constants_2.Constants.PERMISSIONS.noPermission;
        }
        const findUser = userList === null || userList === void 0 ? void 0 : userList.find((user) => user.aadId === userObjectId);
        if (!findUser) {
            return constants_2.Constants.PERMISSIONS.noPermission;
        }
        if (findUser.isAdministrator) {
            return constants_2.Constants.PERMISSIONS.admin;
        }
        else {
            return constants_2.Constants.PERMISSIONS.operative;
        }
    }
    async grantPermission(token, teamsAppId, newUser) {
        var _a;
        const app = await this.getApp(token, teamsAppId);
        if (this.checkUser(app, newUser)) {
            return;
        }
        (_a = app.userList) === null || _a === void 0 ? void 0 : _a.push(newUser);
        let requester;
        try {
            globalVars_1.TOOLS.logProvider.debug((0, localizeUtils_1.getLocalizedString)("core.common.SendingApiRequest", `${this.getEndpoint()}/api/appdefinitions/{teamsAppId}/owner`, JSON.stringify(app)));
            requester = this.createRequesterWithToken(token);
            const response = await RetryHandler.Retry(() => requester.post(`/api/appdefinitions/${teamsAppId}/owner`, app));
            globalVars_1.TOOLS.logProvider.debug((0, localizeUtils_1.getLocalizedString)("core.common.ReceiveApiResponse", JSON.stringify(response === null || response === void 0 ? void 0 : response.data)));
            if (!response || !response.data || !this.checkUser(response.data, newUser)) {
                throw new Error(constants_2.ErrorMessages.GrantPermissionFailed);
            }
        }
        catch (err) {
            throw this.wrapException(err, constants_2.APP_STUDIO_API_NAMES.UPDATE_OWNER);
        }
    }
    /**
     * Send the app package for partner center validation
     * @param file
     * @param token
     * @returns
     */
    async partnerCenterAppPackageValidation(token, file) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.post("/api/appdefinitions/partnerCenterAppPackageValidation", file, {
                headers: { "Content-Type": "application/zip" },
            }));
            return response === null || response === void 0 ? void 0 : response.data;
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.VALIDATE_APP_PACKAGE);
        }
    }
    checkUser(app, newUser) {
        var _a;
        const findUser = (_a = app.userList) === null || _a === void 0 ? void 0 : _a.findIndex((user) => user["aadId"] === newUser.aadId);
        if (findUser != undefined && findUser >= 0) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Submit App Validation Request (In-App) for which App Definitions are stored at TDP.
     * @param teamsAppId
     * @param token
     * @param timeoutSeconds
     * @returns
     */
    async submitAppValidationRequest(token, teamsAppId) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.post(`/api/v1.0/appvalidations/appdefinition/validate`, {
                AppEnvironmentId: null,
                appDefinitionId: teamsAppId,
            }));
            return response === null || response === void 0 ? void 0 : response.data;
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.SUBMIT_APP_VALIDATION);
        }
    }
    /**
     * Get App validation requests sumitted by the user
     */
    async getAppValidationRequestList(token, teamsAppId) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.get(`/api/v1.0/appvalidations/appdefinitions/${teamsAppId}`));
            return response === null || response === void 0 ? void 0 : response.data;
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.GET_APP_VALIDATION_REQUESTS);
        }
    }
    /**
     * Get App validation results by provided app validation id
     * @param appValidationId
     * @param token
     * @param timeoutSeconds
     * @returns
     */
    async getAppValidationById(token, appValidationId) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.get(`/api/v1.0/appvalidations/${appValidationId}`));
            return response === null || response === void 0 ? void 0 : response.data;
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.GET_APP_VALIDATION_RESULT);
        }
    }
    async getSideloadingStatus(token) {
        var _a, _b, _c, _d, _e, _f, _g;
        const apiName = "<check-sideloading-status>";
        const apiPath = "/api/usersettings/mtUserAppPolicy";
        const requester = this.createRequesterWithToken(token);
        let response = undefined;
        try {
            response = (await RetryHandler.Retry(() => requester.get(apiPath)));
            let result;
            if (response.status >= 400) {
                result = undefined;
            }
            else {
                result = (_b = (_a = response.data) === null || _a === void 0 ? void 0 : _a.value) === null || _b === void 0 ? void 0 : _b.isSideloadingAllowed;
            }
            if (result !== undefined) {
                (0, telemetry_1.sendTelemetryEvent)("TeamsDevPortalClient", telemetry_1.TelemetryEvent.CheckSideloading, {
                    [telemetry_1.TelemetryProperty.IsSideloadingAllowed]: result.toString() + "",
                });
            }
            else {
                (0, telemetry_1.sendTelemetryErrorEvent)("TeamsDevPortalClient", telemetry_1.TelemetryEvent.CheckSideloading, new teamsfx_api_1.SystemError("M365Account", "UnknownValue", 
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                `AppStudio response code: ${response.status}, body: ${response.data}`), {
                    [telemetry_1.TelemetryProperty.CheckSideloadingStatusCode]: `${response.status}`,
                    [telemetry_1.TelemetryProperty.CheckSideloadingMethod]: "get",
                    [telemetry_1.TelemetryProperty.CheckSideloadingUrl]: apiName,
                });
            }
            return result;
        }
        catch (error) {
            (0, telemetry_1.sendTelemetryErrorEvent)("TeamsDevPortalClient", telemetry_1.TelemetryEvent.CheckSideloading, new teamsApp_1.CheckSideloadingPermissionFailedError(error, (_e = (_d = (_c = error.response) === null || _c === void 0 ? void 0 : _c.headers) === null || _d === void 0 ? void 0 : _d[constants_2.Constants.CORRELATION_ID]) !== null && _e !== void 0 ? _e : "", apiName, (0, localizeUtils_1.getDefaultString)("error.appstudio.apiFailed.reason.common", ((_f = error.response) === null || _f === void 0 ? void 0 : _f.data) ? `data: ${JSON.stringify(error.response.data)}` : "")), {
                // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
                [telemetry_1.TelemetryProperty.CheckSideloadingStatusCode]: `${(_g = error === null || error === void 0 ? void 0 : error.response) === null || _g === void 0 ? void 0 : _g.status}`,
                [telemetry_1.TelemetryProperty.CheckSideloadingMethod]: "get",
                [telemetry_1.TelemetryProperty.CheckSideloadingUrl]: apiName,
            });
        }
        return undefined;
    }
    /**
     * Create the Api Key registration.
     * @param token
     * @param apiKeyRegistration
     */
    async createApiKeyRegistration(token, apiKeyRegistration) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.post("/api/v1.0/apiSecretRegistrations", apiKeyRegistration));
            return response === null || response === void 0 ? void 0 : response.data;
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.CREATE_API_KEY);
        }
    }
    /**
     * Get the Api Key registration by Id.
     * @param token
     * @param apiSecretRegistrationId
     */
    async getApiKeyRegistrationById(token, apiSecretRegistrationId) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.get(`/api/v1.0/apiSecretRegistrations/${apiSecretRegistrationId}`));
            return response === null || response === void 0 ? void 0 : response.data;
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.GET_API_KEY);
        }
    }
    async updateApiKeyRegistration(token, apiKeyRegistration, apiKeyRegistrationId) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.patch(`/api/v1.0/apiSecretRegistrations/${apiKeyRegistrationId}`, apiKeyRegistration));
            return response === null || response === void 0 ? void 0 : response.data;
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.UPDATE_API_KEY);
        }
    }
    async getOauthRegistrationById(token, oauthRegistrationId) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.get(`/api/v1.0/oAuthConfigurations/${oauthRegistrationId}`));
            return response === null || response === void 0 ? void 0 : response.data;
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.GET_OAUTH);
        }
    }
    async createOauthRegistration(token, oauthRegistration) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.post("/api/v1.0/oAuthConfigurations", oauthRegistration));
            return response === null || response === void 0 ? void 0 : response.data;
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.CREATE_OAUTH);
        }
    }
    async updateOauthRegistration(token, oauthRegistration, oauthRegistrationId) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.patch(`/api/v1.0/oAuthConfigurations/${oauthRegistrationId}`, oauthRegistration));
            return response === null || response === void 0 ? void 0 : response.data;
        }
        catch (e) {
            throw this.wrapException(e, constants_2.APP_STUDIO_API_NAMES.UPDATE_OAUTH);
        }
    }
    async getBotRegistration(token, botId) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.get(`/api/botframework/${botId}`));
            if ((0, common_1.isHappyResponse)(response)) {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                return response.data; // response cannot be undefined as it's checked in isHappyResponse.
            }
            else {
                // Defensive code and it should never reach here.
                throw this.wrapException(this.wrapResponse(undefined, response), constants_2.APP_STUDIO_API_NAMES.GET_BOT, (0, localizeUtils_1.getDefaultString)("error.appstudio.apiFailed.name.common"), "Failed to get data");
            }
        }
        catch (e) {
            this.handleBotFrameworkError(e, constants_2.APP_STUDIO_API_NAMES.GET_BOT);
        }
    }
    async listBots(token) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.get("/api/botframework"));
            if ((0, common_1.isHappyResponse)(response)) {
                return response.data; // response cannot be undefined as it's checked in isHappyResponse.
            }
            else {
                // Defensive code and it should never reach here.
                throw this.wrapException(this.wrapResponse(undefined, response), constants_2.APP_STUDIO_API_NAMES.LIST_BOT, (0, localizeUtils_1.getDefaultString)("error.appstudio.apiFailed.name.common"), "Failed to get data");
            }
        }
        catch (e) {
            this.handleBotFrameworkError(e, constants_2.APP_STUDIO_API_NAMES.LIST_BOT);
        }
    }
    async deleteBot(token, botId) {
        const requester = this.createRequesterWithToken(token);
        try {
            await RetryHandler.Retry(() => requester.delete(`/api/botframework/${botId}`));
        }
        catch (e) {
            this.handleBotFrameworkError(e, constants_2.APP_STUDIO_API_NAMES.DELETE_BOT);
        }
    }
    async createBotRegistration(token, registration, checkExistence = true) {
        if (registration.botId && checkExistence) {
            const botReg = await this.getBotRegistration(token, registration.botId);
            if (botReg) {
                globalVars_1.TOOLS.logProvider.info(messages_1.Messages.BotResourceExist("Appstudio"));
                return;
            }
        }
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.post(`/api/botframework`, registration));
            if (!(0, common_1.isHappyResponse)(response)) {
                throw new errors_2.ProvisionError(strings_1.CommonStrings.APP_STUDIO_BOT_REGISTRATION);
            }
        }
        catch (e) {
            this.handleBotFrameworkError(e, constants_2.APP_STUDIO_API_NAMES.CREATE_BOT);
        }
    }
    async updateMessageEndpoint(token, botId, endpoint) {
        const botReg = await this.getBotRegistration(token, botId);
        if (!botReg) {
            throw new errors_2.BotRegistrationNotFoundError(botId);
        }
        botReg.messagingEndpoint = endpoint;
        if (botReg.configuredChannels === undefined || botReg.configuredChannels.length === 0) {
            botReg.configuredChannels = [IBotRegistration_1.BotChannelType.MicrosoftTeams];
        }
        await this.updateBotRegistration(token, botReg);
    }
    async updateBotRegistration(token, botReg) {
        const requester = this.createRequesterWithToken(token);
        try {
            const response = await RetryHandler.Retry(() => requester.post(`/api/botframework/${botReg.botId}`, botReg));
            if (!(0, common_1.isHappyResponse)(response)) {
                throw new errors_2.ConfigUpdatingError(strings_1.ConfigNames.MESSAGE_ENDPOINT);
            }
        }
        catch (e) {
            this.handleBotFrameworkError(e, constants_2.APP_STUDIO_API_NAMES.UPDATE_BOT);
        }
    }
    handleBotFrameworkError(e, apiName) {
        var _a, _b, _c, _d;
        if (((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) === commonConstant_1.HttpStatusCode.NOTFOUND) {
            return undefined; // Stands for NotFound.
        }
        else if (((_b = e.response) === null || _b === void 0 ? void 0 : _b.status) === commonConstant_1.HttpStatusCode.UNAUTHORIZED) {
            throw new errors_2.BotFrameworkNotAllowedToAcquireTokenError();
        }
        else if (((_c = e.response) === null || _c === void 0 ? void 0 : _c.status) === commonConstant_1.HttpStatusCode.FORBIDDEN) {
            throw new errors_2.BotFrameworkForbiddenResultError();
        }
        else if (((_d = e.response) === null || _d === void 0 ? void 0 : _d.status) === commonConstant_1.HttpStatusCode.TOOMANYREQS) {
            throw new errors_2.BotFrameworkConflictResultError();
        }
        else {
            e.teamsfxUrlName = constants_3.TeamsFxUrlNames[apiName];
            throw this.wrapException(e, apiName);
        }
    }
    wrapResponse(e, response) {
        var _a;
        const error = new Error((e === null || e === void 0 ? void 0 : e.message) || ((_a = response === null || response === void 0 ? void 0 : response.data.error) === null || _a === void 0 ? void 0 : _a.message) || (response === null || response === void 0 ? void 0 : response.data.errorMessage));
        error.response = response;
        error.request = response === null || response === void 0 ? void 0 : response.request;
        return error;
    }
    wrapException(e, apiName, name = (0, localizeUtils_1.getDefaultString)("error.appstudio.apiFailed.name.common"), potentialReason = (0, localizeUtils_1.getDefaultString)("error.appstudio.apiFailed.reason.common"), disPlayMessage, isUserError = false, helpLink) {
        var _a, _b, _c, _d, _e;
        e.name = name;
        const correlationId = (_b = (_a = e.response) === null || _a === void 0 ? void 0 : _a.headers) === null || _b === void 0 ? void 0 : _b[constants_2.Constants.CORRELATION_ID];
        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions
        let extraData = `${potentialReason} ${((_c = e.response) === null || _c === void 0 ? void 0 : _c.data) ? `data: ${JSON.stringify(e.response.data)}` : ""}`;
        // add status code in extra data if the message does not have it.
        if (!((_d = e.message) === null || _d === void 0 ? void 0 : _d.toLowerCase().includes("status code")) && ((_e = e.response) === null || _e === void 0 ? void 0 : _e.status)) {
            extraData = `Status code: ${e.response.status}. ${extraData}`;
        }
        let error;
        if (isUserError) {
            error = new teamsApp_1.DeveloperPortalAPIFailedUserError(e, correlationId, apiName, extraData, disPlayMessage, helpLink);
        }
        else {
            error = new teamsApp_1.DeveloperPortalAPIFailedSystemError(e, correlationId, apiName, extraData, disPlayMessage);
        }
        return error;
    }
}
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Buffer, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "importApp", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "listApps", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "deleteApp", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getApp", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getBotId", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getAppPackage", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "checkExistsInTenant", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, Buffer]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "publishTeamsApp", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, Buffer]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "publishTeamsAppUpdate", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getStaggedApp", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getUserList", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "checkPermission", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "grantPermission", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Buffer]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "partnerCenterAppPackageValidation", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "submitAppValidationRequest", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getAppValidationRequestList", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getAppValidationById", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getSideloadingStatus", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "createApiKeyRegistration", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getApiKeyRegistrationById", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "updateApiKeyRegistration", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getOauthRegistrationById", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "createOauthRegistration", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "updateOauthRegistration", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "getBotRegistration", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "listBots", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "deleteBot", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "createBotRegistration", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, String, String]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "updateMessageEndpoint", null);
tslib_1.__decorate([
    (0, hooks_1.hooks)([(0, globalVars_1.ErrorContextMW)({ source: "Teams", component: "TeamsDevPortalClient" })]),
    tslib_1.__metadata("design:type", Function),
    tslib_1.__metadata("design:paramtypes", [String, Object]),
    tslib_1.__metadata("design:returntype", Promise)
], TeamsDevPortalClient.prototype, "updateBotRegistration", null);
exports.TeamsDevPortalClient = TeamsDevPortalClient;
exports.teamsDevPortalClient = new TeamsDevPortalClient();
//# sourceMappingURL=teamsDevPortalClient.js.map